{"version":3,"sources":["utils/util.js","components/Node.js","components/Grid.js","algorithms/path_finding/dijkstras.js","components/Visualize.js","components/Reset.js","components/Clear.js","components/Header.js","App.js","reportWebVitals.js","index.js"],"names":["nodeTypeEnum","Object","freeze","nodeColorClass","none","target","obstacle","start","visited","path","nodeWeight","Infinity","getNodeTypeEnum","key","Node","React","memo","nodeId","size","nodeState","setGridState","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","nodeDim","width","height","style","className","onMouseDown","prevState","slice","onMouseUp","onMouseEnter","onMouseLeave","Grid","rows","cols","padding","nodeSize","gridState","selectedObstacle","useState","nodes","x","y","push","gridDimensions","containerStyle","paddingLeft","paddingRight","paddingBottom","dijkstras","startCord","targetCord","console","log","totalCosts","prevNodes","minPQ","cord","minKey","findMinPriorityNode","setTimeout","createPath","neighbours","getNeighbourNodes","neighbour","currPath","keys","length","node","row","parseInt","split","col","res","array","i","j","Math","floor","random","temp","shuffleArray","minPriority","min","values","Visualize","clearForReRun","setRunningAlgo","run","a","updatedGridState","onClick","Reset","resetBoard","Clear","clearObstacles","Header","App","setSelectedObstacle","setRows","setCols","useEffect","adjustedWinHeight","window","innerHeight","adjustedWinWidth","innerWidth","gridMap","unshift","change","id","currState","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.152304e2.chunk.js","sourcesContent":["const nodeTypeEnum = {\n    'none': 0,\n    'target': 1,\n    'path': 2,\n    'start': 3,\n    'remObstacle': 4,\n    'visited': 5,\n    'obstacle': 6\n};\nObject.freeze(nodeTypeEnum);\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'empty',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.obstacle]: 'obstacle',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path'\n}\nObject.freeze(nodeColorClass);\n\nconst nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.obstacle]: Infinity,\n    [nodeTypeEnum.start]: 1\n}\nObject.freeze(nodeWeight);\n\nexport const getNodeTypeEnum = (key) => {\n    return nodeTypeEnum[key];\n};\n\nexport const getNodeColorClass = (key) => {\n    return nodeColorClass[key];\n};\n\nexport const getNodeWeight = (key) => {\n    return nodeWeight[key];\n};\n\nexport const shuffleArray = (array) => {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n};\n","import React from 'react'\nimport { getNodeColorClass, getNodeTypeEnum } from '../utils/util.js'\n\nconst Node = React.memo(({ nodeId, size, nodeState, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo }) => {\n    const nodeDim = {\n        width: size,\n        height: size\n    };\n\n    const mouseDowned = () => {\n        if (nodeState[0] === getNodeTypeEnum('none') || nodeState[0] === getNodeTypeEnum('path') || nodeState[0] === getNodeTypeEnum('visited')) {\n            setDraggingSelection(getNodeTypeEnum('obstacle'));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [getNodeTypeEnum('obstacle'), ...prevState[nodeId]] }));\n            return;\n        }\n        else if (nodeState[0] === getNodeTypeEnum('obstacle')) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n            setDraggingSelection(getNodeTypeEnum('remObstacle'));\n            return;\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === getNodeTypeEnum('remObstacle') && nodeState[0] >= getNodeTypeEnum('obstacle')) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n        }\n        else if (draggingSelection === getNodeTypeEnum('obstacle') && nodeState[0] !== getNodeTypeEnum('start') && nodeState[0] !== getNodeTypeEnum('target')) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [getNodeTypeEnum('obstacle'), getNodeTypeEnum('none')] }));\n        }\n        else if (draggingSelection === getNodeTypeEnum('start')) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [getNodeTypeEnum('start'), ...prevState[nodeId]] }));\n            setStartCord(nodeId);\n        }\n        else if (draggingSelection === getNodeTypeEnum('target')) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [getNodeTypeEnum('target'), ...prevState[nodeId]] }));\n            setTargetCord(nodeId);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === getNodeTypeEnum('start') || draggingSelection === getNodeTypeEnum('target')) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection !== getNodeTypeEnum('none')) {\n            setDraggingSelection(getNodeTypeEnum('none'));\n        }\n    };\n\n    return (\n        <div style={{ ...nodeDim }} className={`node ${getNodeColorClass(nodeState[0])}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n});\n\nexport default Node\n","import Node from './Node.js'\nimport { useState } from 'react'\nimport { getNodeTypeEnum } from '../utils/util.js'\n\nconst Grid = ({ rows, cols, padding, nodeSize, gridState, setGridState, selectedObstacle, setStartCord, setTargetCord, runningAlgo }) => {\n    const [draggingSelection, setDraggingSelection] = useState(getNodeTypeEnum('none'));\n\n    // fill nodes in the grid\n    // console.log(\"RERENDERING GRID\");\n    const nodes = [];\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let nodeId = `${x}:${y}`\n\n            nodes.push(<Node nodeId={nodeId}\n                size={nodeSize} nodeState={gridState[nodeId]} setGridState={setGridState}\n                draggingSelection={draggingSelection}\n                setDraggingSelection={setDraggingSelection}\n                setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} key={nodeId} />);\n        }\n    }\n\n    const gridDimensions = {\n        width: (cols * nodeSize) + cols,\n        height: (rows * nodeSize) + rows\n    };\n\n    const containerStyle = {\n        paddingLeft: padding,\n        paddingRight: padding,\n        paddingBottom: padding\n    }\n\n    return (\n        <div style={containerStyle}>\n            <div className='grid' style={gridDimensions}>\n                {nodes}\n            </div >\n        </div>\n    )\n}\n\nexport default Grid\n","import { getNodeTypeEnum, getNodeWeight, shuffleArray } from '../../utils/util.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n    console.log(\"STARTING DIJSTRAS\");\n\n    if (startCord === targetCord) {\n        console.log(\"ENDING DIJSTRAS\");\n        return [];\n    }\n\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [minKey]: [getNodeTypeEnum('visited')] }));\n            }, 1);\n        }\n        else if (minKey === targetCord) {\n            console.log(\"ENDING DIJSTRAS\");\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + getNodeWeight(gridState[neighbour][0]);\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n            }\n        }\n    }\n\n    console.log(\"ENDING DIJSTRAS\");\n    return [];\n};\n\nconst createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nconst getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    shuffleArray(res);\n    return res;\n};\n\nconst findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};","import { dijkstras } from '../algorithms/path_finding/dijkstras.js'\nimport { getNodeTypeEnum } from '../utils/util.js'\n\nconst Visualize = ({ rows, cols, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo }) => {\n    const run = async () => {\n        console.log(\"I AM RUNNING\");\n        const updatedGridState = clearForReRun();\n        const path = dijkstras(startCord, targetCord, updatedGridState, setGridState, rows, cols);\n\n        for (let i = path.length; i >= 0; i--) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [path[i]]: [getNodeTypeEnum('path')] }));\n            }, 1);\n        }\n\n        setTimeout(() => {\n            setRunningAlgo(false);\n        }, 1);\n    };\n\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'green'}`} onClick={runningAlgo ? null : run} >\n            Run\n        </div >\n    )\n}\n\nexport default Visualize\n","const Reset = ({ resetBoard, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'red'}`} onClick={runningAlgo ? null : resetBoard}>\n            Reset Grid\n        </div >\n    )\n}\n\nexport default Reset\n","import React from 'react'\n\nconst Clear = ({ clearObstacles, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'orange'}`} onClick={runningAlgo ? null : clearObstacles}>\n            Clear Obstacles\n        </div >\n    )\n}\n\nexport default Clear\n","import Visualize from './Visualize.js'\nimport Reset from './Reset.js'\nimport Clear from './Clear.js'\n\nconst Header = ({ rows, cols, runningAlgo, setRunningAlgo, padding, height, setGridState, startCord, targetCord, resetBoard, clearObstacles, clearForReRun }) => {\n    const style = {\n        padding: padding,\n        height: height\n    };\n\n    return (\n        <div style={style} className='header'>\n            <Reset resetBoard={resetBoard} runningAlgo={runningAlgo} />\n            <Clear clearObstacles={clearObstacles} runningAlgo={runningAlgo} />\n            <Visualize rows={rows} cols={cols} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearForReRun} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} />\n        </div>\n    )\n}\n\nexport default Header\n","import Grid from './components/Grid.js'\nimport Header from './components/Header.js'\nimport { getNodeTypeEnum } from './utils/util.js'\nimport { useState, useEffect } from 'react'\n\nfunction App() {\n  const [gridState, setGridState] = useState({});\n  const [selectedObstacle, setSelectedObstacle] = useState({});\n  const [rows, setRows] = useState(0);\n  const [cols, setCols] = useState(0);\n  const [startCord, setStartCord] = useState('0:0');\n  const [targetCord, setTargetCord] = useState('0:0');\n  const [runningAlgo, setRunningAlgo] = useState(false);\n  const margin = 30;\n  const nodeSize = 28;\n  const navBarHeight = 80;\n\n  useEffect(() => {\n    resetBoard();\n  }, []);\n\n  // useEffect(() => {\n  //   window.addEventListener(\"resize\", resetBoard);\n  //   return () => window.removeEventListener(\"resize\", resetBoard)\n  // }, []);\n\n  const resetBoard = () => {\n    const adjustedWinHeight = window.innerHeight - (navBarHeight + (margin * 2)) - margin;\n    const adjustedWinWidth = window.innerWidth - (2 * margin);\n\n    const rows = parseInt(adjustedWinHeight / (nodeSize + 1));\n    const cols = parseInt(adjustedWinWidth / (nodeSize + 1));\n\n    setRunningAlgo(false);\n    setRows(rows);\n    setCols(cols);\n    setStartCord('0:0');\n    setTargetCord(`${rows - 1}:${cols - 1}`);\n\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let nodeState = [getNodeTypeEnum('none')];\n        if (x === 0 && y === 0) {\n          nodeState.unshift(getNodeTypeEnum('start'));\n        }\n        else if (x === (rows - 1) && y === (cols - 1)) {\n          nodeState.unshift(getNodeTypeEnum('target'));\n        }\n\n        gridMap[`${x}:${y}`] = nodeState;\n      }\n    }\n\n    setGridState(gridMap);\n\n    let defaultSelectedObstacle = {\n      'obstacle': false\n    };\n\n    setSelectedObstacle(defaultSelectedObstacle);\n  };\n\n  const clearObstacles = () => {\n    let gridMap = {};\n    let change = false;\n\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        gridMap[id] = gridState[id];\n        let currState = gridState[id][0];\n\n        if (currState >= getNodeTypeEnum('obstacle')) {\n          gridMap[id] = [getNodeTypeEnum('none')];\n          change = true;\n        }\n      }\n    }\n\n    if (change) {\n      setGridState(prevState => (gridMap));\n    }\n  };\n\n  const clearForReRun = () => {\n    console.log('CLEARING GRID FOR RE RERUN');\n    let gridMap = {};\n    let change = false;\n\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        gridMap[id] = gridState[id];\n        let currState = gridState[id][0];\n\n        if (currState === getNodeTypeEnum('visited') || currState === getNodeTypeEnum('path')) {\n          gridMap[id] = [getNodeTypeEnum('none')];\n          change = true;\n        }\n      }\n    }\n\n    if (change) {\n      console.log(\"DONE CLEARING FOR RE RUN\")\n      setGridState(prevState => (gridMap));\n    }\n\n    setRunningAlgo(true);\n    return gridMap;\n  };\n\n  return (\n    <>\n      <Header rows={rows} cols={cols} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} padding={margin} height={navBarHeight} setGridState={setGridState} startCord={startCord} targetCord={targetCord} resetBoard={resetBoard} clearObstacles={clearObstacles} clearForReRun={clearForReRun} />\n      <Grid rows={rows} cols={cols} padding={margin} nodeSize={nodeSize} gridState={gridState} setGridState={setGridState} selectedObstacle={selectedObstacle} setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} />\n    </>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}