{"version":3,"sources":["utils/helper.js","algorithms/path_finding/dijkstras.js","algorithms/path_finding/dfs.js","algorithms/path_finding/bfs.js","algorithms/path_finding/aStar.js","algorithms/path_finding/greedyBestFirstSearch.js","algorithms/terrain/recursiveDivision.js","algorithms/terrain/simplexNoise.js","algorithms/terrain/random.js","algorithms/terrain/randomWeighted.js","utils/constants.js","components/Node.js","components/Grid.js","components/Reset.js","components/Clear.js","components/Visualize.js","images/down_arrow.svg","images/weight.svg","images/weight_unfilled.svg","images/optimal.svg","images/optimal_unfilled.svg","components/CustomDropdown.js","components/ShowInfo.js","components/ChooseAlgorithm.js","components/GenerateTerrain.js","components/ChooseTerrain.js","components/ChooseObstacle.js","components/Header.js","images/close.svg","components/InfoBox.js","App.js","reportWebVitals.js","index.js"],"names":["getNeighbourNodes","node","rows","cols","gridState","row","parseInt","split","col","res","nodeTypeEnum","wall","push","createPath","startCord","targetCord","prevNodes","cord","path","findMinPriorityNode","minPQ","minPriority","Math","min","Object","values","key","isAlgoUnweighted","algo","unweightedPathAlgos","includes","isTerrainAlgoUnweighted","unweightedTerrainAlgos","sleep","ms","Promise","resolve","setTimeout","getRandomNum","num1","num2","max","floor","random","manhattanDistanceHeuristic","currNodeCord","currRow","currCol","targetRow","targetCol","abs","dijkstras","timeout","a","visited","distance","x","y","Infinity","keys","length","minKey","nodeStateFunc","prevState","slice","neighbours","neighbour","currPath","nodeWeight","visiting","dfs","stack","currCord","none","pop","shift","unvisitedNeighbourFound","unshift","splice","bfs","queue","aStar","openSet","G","H","F","currNode","currGScore","greedyBestFirstSearch","console","log","recursiveDivision","setGridState","setWall","divide","startRow","endRow","startCol","endCol","orientation","width","height","sCol","sRow","skip","randRow","i","randCol","state","start","target","Grad","z","this","prototype","dot2","dot3","grad3","p","perm","Array","gradP","seed","v","F2","sqrt","G2","simplex2","xin","yin","i1","j1","s","j","t","x0","y0","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","simplexNoise","gridMap","value","weighted100","weighted80","weighted60","weighted40","weighted20","newState","randomWeighted","DIJKSTRAS","ASTAR","BFS","DFS","GREEDY_BEST_FIRST_SEARCH","algoFunctions","freeze","algoSleepTimes","allPathAlgos","optimalPathAlgos","RECURSIVE_DIVISION","SIMPLEX_NOISE","RANDOM_UNWEIGHTED","RANDOM_WEIGHTED","allTerrainAlgos","terrainFunctions","terrainAlgoSleepTimes","nodeColorClass","nodeColors","obstacleTypes","obsEnum","codeBlockCustomStyle","fontSize","backgroundColor","borderRadius","padding","lineHeight","maxHeight","marginTop","marginBottom","inLineCodeBlockCustomStyle","display","color","fontWeight","pathfindingAlgoInfo","language","style","atomOneDark","showLineNumbers","wrapLines","customStyle","Node","nodeId","size","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","selectedObstacle","startingState","useState","nodeState","setNodeState","useEffect","nodeColor","colorA","colorB","amount","match","map","c","rA","gA","bA","rB","gB","bB","round","toString","padStart","getNodeColor","nodeStyle","border","cursor","className","remObstacle","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","Grid","React","memo","nodeSize","nodes","gridDimensions","containerStyle","paddingLeft","paddingRight","Reset","clearObstacles","onClick","Clear","clearPath","Visualize","selectedAlgo","clearForReRun","setRunningAlgo","run","CustomDropdown","setSelection","items","disabled","dropDownWidth","isAlgoSelector","isObstacleSelector","isTerrainSelector","dropDownOpen","setDropDownOpen","selectedVal","setSelectedVal","selectedId","setSelectedId","dropdownItems","id","src","weightUnfilled","title","alt","weight","optimal","optimalUnfilled","downArrow","ShowInfo","toggleInfoBox","ChooseAlgorithm","setSelectedAlgo","GenerateTerrain","selectedTerrainAlgo","resetGrid","ChooseTerrain","setSelectedTerrainAlgo","ChooseObstacle","setSelectedObstacle","weightedObsDisabled","obstacleName","Header","paddingBottom","InfoBox","infoBoxOpen","startingPos","dragging","setDragging","boxCord","setBoxCord","disableDragging","e","left","top","onMouseMove","movementX","movementY","closeIcon","summary","description","pseudocode","App","setInfoBoxOpen","setRows","setCols","setWeightedObsDisabled","initializeGrid","adjustedWinHeight","window","innerHeight","adjustedWinWidth","innerWidth","currRows","currCols","currState","updateGrid","prev","algoName","unweightedAlgo","clearWeightedObstacles","navBarHeight","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5eb9b1fb.chunk.js","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors, unweightedTerrainAlgos } from './constants.js'\n\nexport const getNodeColor = (nodeState) => {\n    if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting) && nodeState[1] > nodeTypeEnum.wall) {\n        let colorA = nodeColors[nodeState[0]];\n        const colorB = nodeColors[nodeState[1]];\n        let amount = 0.78;\n\n        if (nodeState[0] === nodeTypeEnum.visiting) {\n            colorA = nodeColors[nodeTypeEnum.visited];\n        }\n        // we need to mix colors\n        const [rA, gA, bA] = colorA.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const [rB, gB, bB] = colorB.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n        const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n        const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n        return '#' + r + g + b;\n    }\n\n    return nodeColors[nodeState[0]];\n};\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isTerrainAlgoUnweighted = (algo) => {\n    return unweightedTerrainAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n\nexport const sleep = (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n};\n\nexport const getRandomNum = (num1, num2) => {\n    if (num1 === num2) {\n        return num1;\n    }\n    const min = Math.min(num1, num2);\n    const max = Math.max(num1, num2);\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N. This is known as the \"Manhattan Distance\"\nexport const manhattanDistanceHeuristic = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};","import { getNeighbourNodes, createPath, findMinPriorityNode, sleep } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dijkstras = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let distance = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    distance[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                distance[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            const nodeStateFunc = gridState[minKey][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = distance[minKey] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < distance[neighbour]) || !(neighbour in minPQ)) {\n                distance[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};","import { getNeighbourNodes, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            visited[currCord] = 1;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};","import { getNeighbourNodes, createPath, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            const nodeStateFunc = gridState[neighbour][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n","import { getNeighbourNodes, createPath, findMinPriorityNode, sleep, manhattanDistanceHeuristic } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const aStar = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let G = { [startCord]: 0 }; // G(n) => tell us the current shortest distance from start node to node n\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = G(n) + H(n)\n    let visited = {};\n    let prevNodes = {};\n\n    // intialize all the scores to infinity for all nodes !== start_node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = G[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currGScore = G[currNode] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (currGScore < G[neighbour]) {\n                if (neighbour !== startCord && neighbour !== targetCord && !(neighbour in visited)) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n                visited[neighbour] = 1;\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                G[neighbour] = currGScore;\n                H[neighbour] = manhattanDistanceHeuristic(neighbour, targetCord);\n                F[neighbour] = G[neighbour] + H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};","import { getNeighbourNodes, createPath, findMinPriorityNode, sleep, manhattanDistanceHeuristic } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const greedyBestFirstSearch = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = H(n)\n    let prevNodes = {};\n    let visited = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (currNode === targetCord) {\n            console.log(\"DONNEE\");\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            if (!(neighbour in visited)) {\n                visited[neighbour] = 1;\n\n                if (neighbour !== startCord && neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n\n                H[neighbour] = manhattanDistanceHeuristic(neighbour, targetCord);\n                F[neighbour] = H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n","import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (let y = 0; y < cols; y++) {\n        const currCord = `${0}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = 1; y < rows; y++) {\n        const currCord = `${y}:${cols - 1}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = cols - 2; y >= 0; y--) {\n        const currCord = `${rows - 1}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = rows - 2; y > 0; y--) {\n        const currCord = `${y}:${0}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            setWall(currCord, startCord, targetCord, gridState, setGridState);\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            setWall(currCord, startCord, targetCord, gridState, setGridState);\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState, setGridState) => {\n    const nodeStateFunc = gridState[currCord][1];\n\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n    if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n    else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n};","import { nodeTypeEnum } from \"../../utils/constants\";\n\nfunction Grad(x, y, z) {\n    this.x = x; this.y = y; this.z = z;\n}\n\nGrad.prototype.dot2 = function (x, y) {\n    return this.x * x + this.y * y;\n};\n\nGrad.prototype.dot3 = function (x, y, z) {\n    return this.x * x + this.y * y + this.z * z;\n};\n\nconst grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\nnew Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\nnew Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n\nconst p = [151, 160, 137, 91, 90, 15,\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\n\n// To remove the need for index wrapping, double the permutation table length\nvar perm = new Array(512);\nvar gradP = new Array(512);\n\n// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nconst seed = (seed) => {\n    if (seed > 0 && seed < 1) {\n        // Scale the seed out\n        seed *= 65536;\n    }\n\n    seed = Math.floor(seed);\n    if (seed < 256) {\n        seed |= seed << 8;\n    }\n\n    for (var i = 0; i < 256; i++) {\n        var v;\n        if (i & 1) {\n            v = p[i] ^ (seed & 255);\n        } else {\n            v = p[i] ^ ((seed >> 8) & 255);\n        }\n\n        perm[i] = perm[i + 256] = v;\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n};\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\n// 2D simplex noise\nconst simplex2 = (xin, yin) => {\n    var n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin + yin) * F2; // Hairy factor for 2D\n    var i = Math.floor(xin + s);\n    var j = Math.floor(yin + s);\n    var t = (i + j) * G2;\n    var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin - j + t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        i1 = 1; j1 = 0;\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        i1 = 0; j1 = 1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    var y1 = y0 - j1 + G2;\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    var y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n    var gi0 = gradP[i + perm[j]];\n    var gi1 = gradP[i + i1 + perm[j + j1]];\n    var gi2 = gradP[i + 1 + perm[j + 1]];\n    // Calculate the contribution from the three corners\n    var t0 = 0.5 - x0 * x0 - y0 * y0;\n    if (t0 < 0) {\n        n0 = 0;\n    } else {\n        t0 *= t0;\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 < 0) {\n        n1 = 0;\n    } else {\n        t1 *= t1;\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    var t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 < 0) {\n        n2 = 0;\n    } else {\n        t2 *= t2;\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n};\n\nconst SCALE = 12;\nexport const simplexNoise = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    seed(Math.random());\n    let gridMap = {};\n    for (let x = 0; x < cols; x++) {\n        for (let y = 0; y < rows; y++) {\n            // All noise functions return values in the range of -1 to 1.\n            const currCord = `${y}:${x}`;\n            const nodeStateFunc = gridState[currCord][1];\n\n            // noise.simplex2 and noise.perlin2 for 2d noise\n            let value = simplex2(x / SCALE, y / SCALE);\n            const state = [nodeTypeEnum.none];\n\n            if (value >= -1 && value <= -0.50) {\n                state.unshift(nodeTypeEnum.wall);\n            }\n            else if (value > -0.50 && value <= -0.20) {\n                state.unshift(nodeTypeEnum.weighted100);\n            }\n            else if (value > -0.20 && value <= 0.10) {\n                state.unshift(nodeTypeEnum.weighted80);\n            }\n            else if (value > 0.10 && value <= 0.40) {\n                state.unshift(nodeTypeEnum.weighted60);\n            }\n            else if (value > 0.40 && value <= 0.70) {\n                state.unshift(nodeTypeEnum.weighted40);\n            }\n            else if (value > 0.70 && value <= 1) {\n                state.unshift(nodeTypeEnum.weighted20);\n            }\n\n            if (currCord === startCord) {\n                state.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                state.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => state);\n            gridMap[currCord] = [state, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};","import { nodeTypeEnum } from '../../utils/constants.js';\nimport { getRandomNum } from '../../utils/helper.js'\n\nexport const random = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(1, 10);\n\n            if (randomNum >= 4) {\n                // don't place wall\n                let newState = [nodeTypeEnum.none];\n\n                if (currCord === startCord) {\n                    newState.unshift(nodeTypeEnum.start);\n                }\n                else if (currCord === targetCord) {\n                    newState.unshift(nodeTypeEnum.target);\n                }\n\n                gridMap[currCord] = [newState, nodeStateFunc];\n                continue;\n            }\n\n            // place wall\n            let newState = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n            if (currCord === startCord) {\n                newState.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                newState.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => newState);\n            gridMap[currCord] = [newState, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};","import { nodeTypeEnum } from '../../utils/constants.js';\nimport { getRandomNum } from '../../utils/helper.js'\n\nexport const randomWeighted = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(1, 10);\n\n            if (randomNum >= 5) {\n                // don't place obstacle\n                let newState = [nodeTypeEnum.none];\n\n                if (currCord === startCord) {\n                    newState.unshift(nodeTypeEnum.start);\n                }\n                else if (currCord === targetCord) {\n                    newState.unshift(nodeTypeEnum.target);\n                }\n\n                gridMap[currCord] = [newState, nodeStateFunc];\n                continue;\n            }\n\n            // place a random obstacle\n            const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20);\n            let newState = [randomObstacle, nodeTypeEnum.none];\n\n            if (currCord === startCord) {\n                newState.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                newState.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => newState);\n            gridMap[currCord] = [newState, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};","import { dijkstras } from '../algorithms/path_finding/dijkstras.js'\nimport { dfs } from '../algorithms/path_finding/dfs.js'\nimport { bfs } from '../algorithms/path_finding/bfs.js'\nimport { aStar } from '../algorithms/path_finding/aStar.js'\nimport { greedyBestFirstSearch } from '../algorithms/path_finding/greedyBestFirstSearch.js';\nimport { recursiveDivision } from '../algorithms/terrain/recursiveDivision.js'\nimport { simplexNoise } from '../algorithms/terrain/simplexNoise.js'\nimport { random } from '../algorithms/terrain/random.js';\nimport { randomWeighted } from '../algorithms/terrain/randomWeighted.js';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { atomOneDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\n// PATHFINDING ALGORITHM CONSTANTS -------------------------------------------\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = 'A* (A-Star)';\nconst BFS = 'Breadth-first Search';\nconst DFS = 'Depth-first Search';\nconst GREEDY_BEST_FIRST_SEARCH = 'Greedy Best-first Search';\n\nconst algoFunctions = {\n    [DIJKSTRAS]: dijkstras,\n    [ASTAR]: aStar,\n    [BFS]: bfs,\n    [DFS]: dfs,\n    [GREEDY_BEST_FIRST_SEARCH]: greedyBestFirstSearch\n};\nObject.freeze(algoFunctions);\n\nconst PATH_CREATION_SLEEP = 7;\nconst algoSleepTimes = {\n    [DIJKSTRAS]: 1,\n    [ASTAR]: 4,\n    [BFS]: 5,\n    [DFS]: 10,\n    [GREEDY_BEST_FIRST_SEARCH]: 11\n};\nObject.freeze(algoSleepTimes);\n\nexport { DIJKSTRAS, ASTAR, BFS, DFS, GREEDY_BEST_FIRST_SEARCH, algoFunctions, PATH_CREATION_SLEEP, algoSleepTimes };\n\nconst allPathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS, GREEDY_BEST_FIRST_SEARCH];\nObject.freeze(allPathAlgos);\nconst unweightedPathAlgos = [DFS, BFS, GREEDY_BEST_FIRST_SEARCH];\nObject.freeze(unweightedPathAlgos);\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\nObject.freeze(optimalPathAlgos);\n\nexport { allPathAlgos, unweightedPathAlgos, optimalPathAlgos };\n\n// TERRAIN ALGORTHIM CONSTANTS -------------------------------------------\nconst MAZE_GENERATION_SLEEP = 5;\nconst RECURSIVE_DIVISION = \"Recursive Division\";\nconst SIMPLEX_NOISE = \"Simplex Noise\";\nconst RANDOM_UNWEIGHTED = \"Random\";\nconst RANDOM_WEIGHTED = \"Random (Weighted)\"\nconst allTerrainAlgos = [RECURSIVE_DIVISION, SIMPLEX_NOISE, RANDOM_UNWEIGHTED, RANDOM_WEIGHTED];\nObject.freeze(allTerrainAlgos);\n\nconst unweightedTerrainAlgos = [RECURSIVE_DIVISION, RANDOM_UNWEIGHTED];\nObject.freeze(unweightedTerrainAlgos);\n\nconst terrainFunctions = {\n    [RECURSIVE_DIVISION]: recursiveDivision,\n    [SIMPLEX_NOISE]: simplexNoise,\n    [RANDOM_UNWEIGHTED]: random,\n    [RANDOM_WEIGHTED]: randomWeighted,\n};\nObject.freeze(terrainFunctions);\n\nconst terrainAlgoSleepTimes = {\n    [RECURSIVE_DIVISION]: 5,\n    [SIMPLEX_NOISE]: 1,\n    [RANDOM_UNWEIGHTED]: 1,\n    [RANDOM_WEIGHTED]: 1\n};\nObject.freeze(terrainAlgoSleepTimes);\n\nexport { MAZE_GENERATION_SLEEP, RECURSIVE_DIVISION, SIMPLEX_NOISE, allTerrainAlgos, unweightedTerrainAlgos, terrainFunctions, terrainAlgoSleepTimes };\n\n// NODE CONSTANTS ------------------------------------------------------------\nconst nodeTypeEnum = {\n    'path': 0,\n    'visited': 1,\n    'visiting': 2,\n    'none': 3,\n    'target': 4,\n    'start': 5,\n    'remObstacle': 6,\n    'wall': 7,\n    'weighted100': 8,\n    'weighted80': 9,\n    'weighted60': 10,\n    'weighted40': 11,\n    'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\n\nexport { nodeTypeEnum };\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'none',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.wall]: 'wall',\n    [nodeTypeEnum.visiting]: 'visiting',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path',\n    [nodeTypeEnum.weighted100]: 'weighted100',\n    [nodeTypeEnum.weighted80]: 'weighted80',\n    [nodeTypeEnum.weighted60]: 'weighted60',\n    [nodeTypeEnum.weighted40]: 'weighted40',\n    [nodeTypeEnum.weighted20]: 'weighted20'\n};\nObject.freeze(nodeColorClass);\n\nexport { nodeColorClass };\n\nconst EMPTY_NODE_BORDER_COLOR = '#3C4046';\nconst nodeColors = {\n    [nodeTypeEnum.none]: 'transparent',\n    [nodeTypeEnum.target]: '#f14846',\n    [nodeTypeEnum.wall]: '#18191c',\n    [nodeTypeEnum.visiting]: '#4988dc',\n    [nodeTypeEnum.start]: '#43b581',\n    [nodeTypeEnum.visited]: '#3f70dd',\n    [nodeTypeEnum.path]: '#f9a719',\n    [nodeTypeEnum.weighted100]: '#1b1c1e',\n    [nodeTypeEnum.weighted80]: '#1c1e21',\n    [nodeTypeEnum.weighted60]: '#222327',\n    [nodeTypeEnum.weighted40]: '#26272b',\n    [nodeTypeEnum.weighted20]: '#2b2c31'\n};\nObject.freeze(nodeColors);\n\nexport { EMPTY_NODE_BORDER_COLOR, nodeColors };\n\nconst nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.wall]: Infinity,\n    [nodeTypeEnum.start]: 1,\n    [nodeTypeEnum.weighted100]: 100,\n    [nodeTypeEnum.weighted80]: 80,\n    [nodeTypeEnum.weighted60]: 60,\n    [nodeTypeEnum.weighted40]: 40,\n    [nodeTypeEnum.weighted20]: 20\n};\nObject.freeze(nodeWeight);\nexport { nodeWeight };\n\n// OBSTACLE TYPES --------------------------------------------------------\nconst obstacleTypes = ['Wall ()', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n    [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n    [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n    [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n    [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n    [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n    [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n};\nObject.freeze(obsEnum);\n\nexport { obstacleTypes, obsEnum };\n\n// ALGO INFO BOX --------------------------------------------------------\n\nconst codeBlockCustomStyle = {\n    fontSize: 13,\n    backgroundColor: '#18191c',\n    borderRadius: 4,\n    padding: 20,\n    lineHeight: 1.5,\n    maxHeight: 250,\n    marginTop: 7,\n    marginBottom: 0\n};\n\nconst inLineCodeBlockCustomStyle = {\n    fontSize: 12,\n    backgroundColor: '#18191c',\n    borderRadius: 4,\n    padding: 4,\n    display: 'inline',\n    color: 'white',\n    fontWeight: 600\n};\n\nconst pathfindingAlgoInfo = {\n    [DIJKSTRAS]: {\n        'summary': <h4>{DIJKSTRAS} is a <strong>greedy</strong> pathfinding algorithm that guarantees <strong>optimal (shortest)</strong> paths, even in <strong>weighted</strong> graphs</h4>,\n        'description': null,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\n    if node != start_node:\n        dist[node] = Infinity\n        min_pq[node] = Infinity\n            \nwhile min_pq.len:\n    curr_node = min_pq.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev) # found path to target\n        \n    for neighbour in curr_node.neighbours:\n        new_cost = distance[curr_node] + \n                   edge(curr_node, neighbour).weight\n\n        if new_cost < dist[neighbour]:\n            # found better path, update the distance\n            dist[neighbour] = new_cost\n            min_pq[neighbour] = new_cost\n            prev[neighbour] = curr_node\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    },\n    [ASTAR]: {\n        'summary': <h4>{ASTAR} is an <strong>informed</strong> pathfinding algorithm that guarantees <strong>optimal (shortest)</strong> paths, even in <strong>weighted</strong> graphs</h4>,\n        'description': <><p>The algorithm explores paths that minimize the function <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>f(node) = g(node) + h(node)</SyntaxHighlighter> where <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>g(node)</SyntaxHighlighter> is the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.start] }}>start_node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> and <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>h(node)</SyntaxHighlighter> is the <strong>heuristic function</strong> which estimates the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.target] }}>target_node</SyntaxHighlighter>.</p><p>The current chosen heuristic function is known as <strong>Manhattan Distance</strong>, which is just a sum of the differences in the <strong>x</strong> and <strong>y</strong> co-ordinates of 2 points. This heuristic was chosen as it works best for grids where there are 4 directions of movement allowed.</p></>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`open_set = min_heap(start_node: 0)\nG = { start_node: 0 } # G(n) => tell us the current shortest distance from start node to node n\nH = { start_node: 0 } # H(n) => tells us the estimated distance from node n to target node\nF = { start_node: 0 } # F(n) = G(n) + H(n)\nprev = {}\n\nfor node in nodes:\n    if node == start_node:\n        continue\n    \n    F[node] = G[node] = H[node] = Infinity\n    \nwhile open_set not empty:\n    curr_node = open_set.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev)\n        \n    for neighbour in curr_node.neighbours:\n        new_G_score = G[curr_node] + weight(edge(curr_node, neighbour))\n        \n        if new_G_score < G[curr_node]:\n            # update all scores\n            G[neighbour] = new_G_score\n            H[neighbour] = manhattan_distance_heuristic(neighbour, targetCord); # get estimated cost from neighbour -> target\n            F[neighbour] = G[neighbour] + H[neighbour];\n            prev[neighbour] = curr_node;\n            openSet[neighbour] = F[neighbour]; # update priority of neighbour in open_set\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    },\n    [BFS]: {\n        'summary': <h4>{BFS} is an <strong>uninformed/blind</strong> search algorithm that gurantees finding the <strong>optimal (shortest)</strong> paths only in <strong>unweighted</strong> graphs</h4>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`queue = [start_node]\nvisited = { start_node: 1 }\nprev = {}\n\nwhile queue.len:\n    curr_node = queue.dequeue()\n    \n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        prev[neighbour] = curr_node\n        queue.enqueue(neighbour)\n        visited[neighbour] = 1\n\n        if neighbour == target_node:\n            # we path to target_node\n            return create_path(prev)\n\n# no path found \nreturn`}\n        </SyntaxHighlighter>\n    },\n    [DFS]: {\n        'summary': <h4>{DFS} is an <strong>uninformed/blind</strong> search algorithm that is <strong>unoptimal (may or may not find shortest path)</strong> and <strong>unweighted</strong></h4>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`stack = [start_node]\nvisited = { start_node: 1 }\n\nwhile stack.len:\n    curr_node = stack.pop()\n    stack.push(curr_node)\n\n    if curr_node == target_node:\n        return stack # our stack is the path to target_node\n    \n    flag = False\n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        stack.push(neighbour)\n        visited[neighbour] = 1\n        flag = True\n\n    if flag:\n        # no neighbours that need to be visited, pop the node from stack\n        stack.pop()\n\n# no path found \nreturn`}\n        </SyntaxHighlighter>\n    },\n    [GREEDY_BEST_FIRST_SEARCH]: {\n        'summary': <h4>{GREEDY_BEST_FIRST_SEARCH} is an <strong>informed</strong> and <strong>greedy</strong> pathfinding algorithm that is <strong>unoptimal</strong> (may or may not find the shortest paths) and <strong>unweighted</strong></h4>,\n        'description': <><p>Similar to {ASTAR}, this algorithm explores paths that minimize the function <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>f(node) = h(node)</SyntaxHighlighter> where <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>h(node)</SyntaxHighlighter> is the <strong>heuristic function</strong> which estimates the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.target] }}>target_node</SyntaxHighlighter>. Unlike {ASTAR}, {GREEDY_BEST_FIRST_SEARCH} does not perform optimally because it only cares about the estimated distance from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.target] }}>target_node</SyntaxHighlighter>, however, fails to optimize for the cost to get from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.start] }}>start_node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter>.</p><p>The current chosen heuristic function is known as <strong>Manhattan Distance</strong>, which is just a sum of the differences in the <strong>x</strong> and <strong>y</strong> co-ordinates of 2 points. This heuristic was chosen as it works best for grids where there are 4 directions of movement allowed.</p></>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`open_set = min_heap(start_node: 0)\nH = { start_node: 0 } # H(n) => tells us the estimated distance from node n to target node\nF = { start_node: 0 } # F(n) = H(n)\nprev = {}\nvisited = {}\n\nfor node in nodes:\n    if node == start_node:\n        continue\n    \n    F[node] = H[node] = Infinity\n    \nwhile open_set not empty:\n    curr_node = open_set.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev)\n        \n    for neighbour in curr_node.neighbours:  # check all unvisited neighbours \n        if neighbout not in visited:\n            # update all scores\n            visited[neighbours] = 1\n            H[neighbour] = manhattan_distance_heuristic(neighbour, targetCord); # get estimated cost from neighbour -> target\n            F[neighbour] = H[neighbour];\n            prev[neighbour] = curr_node;\n            openSet[neighbour] = F[neighbour]; # update priority of neighbour in open_set\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    }\n};\nObject.freeze(pathfindingAlgoInfo);\nexport { pathfindingAlgoInfo };\n\n","import React from 'react'\nimport { useEffect, useState } from 'react'\nimport { EMPTY_NODE_BORDER_COLOR, nodeTypeEnum } from '../utils/constants.js'\nimport { getNodeColor } from '../utils/helper.js'\n\nconst Node = ({ nodeId, size, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo, selectedObstacle, startingState }) => {\n    const [nodeState, setNodeState] = useState(startingState);\n\n    useEffect(() => {\n        setGridState(prevState => ({ ...prevState, [nodeId]: [startingState, setNodeState] }));\n    }, []);\n\n    const nodeColor = getNodeColor(nodeState);\n    let nodeStyle = {\n        width: size,\n        height: size,\n        backgroundColor: nodeColor,\n        border: `1px solid ${nodeState[0] === nodeTypeEnum.none ? EMPTY_NODE_BORDER_COLOR : nodeColor}`\n    };\n\n    if (!runningAlgo) {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            nodeStyle.cursor = 'grabbing';\n        }\n        else if (draggingSelection === nodeTypeEnum.none && (nodeState[0] === nodeTypeEnum.start || nodeState[0] === nodeTypeEnum.target)) {\n            nodeStyle.cursor = 'grab';\n        }\n    }\n\n    const mouseDowned = () => {\n        if (nodeState[0] <= nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum[selectedObstacle]);\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n            return;\n        }\n        else if (nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n            setDraggingSelection(nodeTypeEnum.remObstacle);\n            return;\n        }\n        else if (nodeState[0] === nodeTypeEnum.start || nodeState[0] === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === nodeTypeEnum.remObstacle && nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum[selectedObstacle] && nodeState[0] <= nodeTypeEnum.none) {\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.start) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => prevState.slice(1));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection === nodeTypeEnum.start) {\n            setStartCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setTargetCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        if (draggingSelection !== nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum.none);\n        }\n    };\n\n    return (\n        <div style={nodeStyle} className={`node ${((nodeState[0] >= nodeTypeEnum.wall && draggingSelection === nodeTypeEnum.none) || draggingSelection === nodeTypeEnum.remObstacle) && 'erasing'}\n        ${draggingSelection !== nodeTypeEnum.remObstacle && (nodeState[0] <= nodeTypeEnum.none || draggingSelection >= nodeTypeEnum.wall) && !runningAlgo && 'ready-to-draw'}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n};\n\nexport default Node\n","import Node from './Node.js'\nimport React from 'react'\nimport { useState } from 'react'\nimport { nodeTypeEnum } from '../utils/constants.js'\n\nconst Grid = React.memo(({ rows, cols, padding, nodeSize, setGridState, selectedObstacle, setStartCord, setTargetCord, runningAlgo }) => {\n    const [draggingSelection, setDraggingSelection] = useState(nodeTypeEnum.none);\n\n    // fill nodes in the grid\n    console.log(\"RERENDERING GRID\");\n    const nodes = [];\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let nodeId = `${x}:${y}`\n\n            let startingState = [nodeTypeEnum.none];\n            if (x === 1 && y === 1) {\n                startingState.unshift(nodeTypeEnum.start);\n            }\n            else if (x === (rows - 2) && y === (cols - 2)) {\n                startingState.unshift(nodeTypeEnum.target);\n            }\n\n            nodes.push(<Node nodeId={nodeId}\n                size={nodeSize} setGridState={setGridState}\n                draggingSelection={draggingSelection}\n                setDraggingSelection={setDraggingSelection}\n                setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} selectedObstacle={selectedObstacle} startingState={startingState} key={nodeId} />);\n        }\n    }\n\n    const gridDimensions = {\n        width: (cols * nodeSize) + cols,\n        height: (rows * nodeSize) + rows\n    };\n\n    const containerStyle = {\n        paddingLeft: padding,\n        paddingRight: padding\n    }\n\n    return (\n        <div style={containerStyle}>\n            <div className='grid' style={gridDimensions}>\n                {nodes}\n            </div >\n        </div>\n    )\n});\n\nexport default Grid\n","const Reset = ({ clearObstacles, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'red'}`} onClick={runningAlgo ? null : clearObstacles}>\n            Clear Obstacles\n        </div >\n    )\n}\n\nexport default Reset\n","import React from 'react'\n\nconst Clear = ({ clearPath, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'orange'}`} onClick={runningAlgo ? null : clearPath}>\n            Clear Path\n        </div >\n    )\n}\n\nexport default Clear\n","import { algoFunctions, nodeTypeEnum, PATH_CREATION_SLEEP, algoSleepTimes } from '../utils/constants.js'\nimport { sleep } from '../utils/helper.js'\n\nconst Visualize = ({ rows, cols, selectedAlgo, gridState, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo }) => {\n    const run = async () => {\n        if (startCord === targetCord) {\n            return;\n        }\n\n        clearForReRun();\n        setRunningAlgo(true);\n        console.log(\"STARTING: \", selectedAlgo);\n\n        let path = [];\n        path = await algoFunctions[selectedAlgo](startCord, targetCord, gridState, rows, cols, algoSleepTimes[selectedAlgo]);\n\n        console.log(\"ENDED: \", selectedAlgo);\n\n        for (let i = path.length - 1; i >= 0; i--) {\n            await sleep(PATH_CREATION_SLEEP);\n            const nodeStateFunc = gridState[path[i]][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.path, ...gridState[path[i]][0]]));\n        }\n\n        setRunningAlgo(false);\n    };\n\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'green'}`} onClick={runningAlgo ? null : run} >\n            Run\n        </div >\n    )\n}\n\nexport default Visualize\n","export default __webpack_public_path__ + \"static/media/down_arrow.8fed4a28.svg\";","export default __webpack_public_path__ + \"static/media/weight.e51e9729.svg\";","export default __webpack_public_path__ + \"static/media/weight_unfilled.cc3c5f2f.svg\";","export default __webpack_public_path__ + \"static/media/optimal.5649a19a.svg\";","export default __webpack_public_path__ + \"static/media/optimal_unfilled.e461ee2c.svg\";","import { useState, useEffect } from 'react'\nimport { isAlgoUnweighted, isAlgoOptimal, isTerrainAlgoUnweighted } from '../utils/helper.js'\nimport { nodeColors, nodeTypeEnum, obsEnum } from '../utils/constants.js'\nimport downArrow from '../images/down_arrow.svg';\nimport weight from '../images/weight.svg'\nimport weightUnfilled from '../images/weight_unfilled.svg'\nimport optimal from '../images/optimal.svg'\nimport optimalUnfilled from '../images/optimal_unfilled.svg'\n\nconst CustomDropdown = ({ setSelection, items, disabled, dropDownWidth, isAlgoSelector, isObstacleSelector, isTerrainSelector }) => {\n    const [dropDownOpen, setDropDownOpen] = useState(false);\n    const [selectedVal, setSelectedVal] = useState(items[0]);\n    const [selectedId, setSelectedId] = useState(0);\n\n    useEffect(() => {\n        if (disabled && isObstacleSelector) {\n            setSelectedVal(items[0]);\n            setSelectedId(0);\n            setDropDownOpen(false);\n            setSelection(items[0]);\n        }\n    }, [disabled]);\n\n    useEffect(() => {\n        setSelectedVal(items[0]);\n        setSelectedId(0);\n        setDropDownOpen(false);\n        setSelection(items[0]);\n    }, [items]);\n\n    const toggle = () => {\n        setDropDownOpen(prevState => !prevState);\n    }\n\n    const madeSelection = (id) => {\n        setDropDownOpen(prevState => !prevState);\n        setSelectedVal(items[id]);\n        setSelectedId(id);\n        setSelection(items[id]);\n    };\n\n    const style = {\n        width: dropDownWidth\n    }\n\n    const dropdownItems = [];\n    for (let i = 0; i < items.length; i++) {\n        dropdownItems.push(<div style={style} className={`dropdown-list-item ${i === selectedId && 'selected'} ${i === items.length - 1 && 'last'}`} onClick={() => { madeSelection(i) }} key={i}>\n            {items[i]}\n            {isAlgoSelector && (!isAlgoUnweighted(items[i]) ? <img className=\"algo-property-badge\" src={weight} title={`${items[i]} is a weighted path-finding algorithm.`} alt={`${items[i]} is a weighted path-finding algorithm.`}></img> : <img className=\"algo-property-badge\" src={weightUnfilled} title={`${items[i]} is not a weighted path-finding algorithm.`} alt={`${items[i]} is not a weighted path-finding algorithm.`}></img>)}\n            {isAlgoSelector && (isAlgoOptimal(items[i]) ? <img className=\"algo-property-badge\" src={optimal} title={`${items[i]} guarantees shortest path.`} alt={`${items[i]} guarantees shortest path.`}></img> : <img className=\"algo-property-badge\" src={optimalUnfilled} title={`${items[i]} does not guarantee shortest path.`} alt={`${items[i]} does not guarantee shortest path.`}></img>)}\n            {isObstacleSelector && <div style={{ backgroundColor: nodeColors[nodeTypeEnum[obsEnum[items[i]]]] }} className=\"obstacle-preview\"> </div>}\n            {isTerrainSelector && (!isTerrainAlgoUnweighted(items[i]) ? <img className=\"algo-property-badge\" src={weight} title={`${items[i]} makes use of weighted obstacles.`} alt={`${items[i]} makes use of weighted obstacles.`}></img> : <img className=\"algo-property-badge\" src={weightUnfilled} title={`${items[i]} does not use weighted obstacles.`} alt={`${items[i]} does not use weighted obstacles.`}></img>)}\n        </div >)\n    }\n\n    return (\n        <div className='dropdown'>\n            <div style={style} className={`dropdown-header ${dropDownOpen && 'open'} ${disabled && 'disabled'}`} onClick={disabled ? null : toggle}>\n                {selectedVal}\n                {!disabled && <img className=\"down-arrow\" src={downArrow} alt=\"\"></img>}\n            </div>\n            <div style={{ display: (dropDownOpen ? 'flex' : 'none') }} className='dropdown-list'>\n                {dropdownItems}\n            </div>\n        </div >\n    )\n}\n\nexport default CustomDropdown\n","const ShowInfo = ({ toggleInfoBox }) => {\n    return (\n        <div className={`button blue`} onClick={toggleInfoBox} >\n            Info\n        </div >\n    )\n}\n\nexport default ShowInfo\n","import Visualize from './Visualize.js'\nimport CustomDropdown from './CustomDropdown.js'\nimport ShowInfo from './ShowInfo.js'\n\nimport { allPathAlgos } from '../utils/constants.js'\n\nconst ChooseAlgorithm = ({ rows, cols, gridState, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo, dropDownWidth, toggleInfoBox, selectedAlgo, setSelectedAlgo }) => {\n\n    return (\n        <div className={`choose-algo`}>\n            <CustomDropdown setSelection={setSelectedAlgo} items={allPathAlgos} disabled={runningAlgo} dropDownWidth={dropDownWidth} isAlgoSelector={true} isObstacleSelector={false} />\n            <ShowInfo toggleInfoBox={toggleInfoBox} />\n            <Visualize rows={rows} cols={cols} selectedAlgo={selectedAlgo} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearForReRun} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} />\n        </div >\n    )\n}\n\nexport default ChooseAlgorithm\n","import { terrainFunctions, terrainAlgoSleepTimes } from '../utils/constants.js'\n\nconst GenerateTerrain = ({ rows, cols, selectedTerrainAlgo, gridState, setGridState, startCord, targetCord, runningAlgo, setRunningAlgo, resetGrid }) => {\n    const run = async () => {\n        await resetGrid();\n\n        setRunningAlgo(true);\n        console.log(\"STARTING: \", selectedTerrainAlgo);\n\n        await terrainFunctions[selectedTerrainAlgo](startCord, targetCord, gridState, setGridState, rows, cols, terrainAlgoSleepTimes[selectedTerrainAlgo]);\n\n        console.log(\"ENDED: \", selectedTerrainAlgo);\n        setRunningAlgo(false);\n    };\n\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'green'}`} onClick={runningAlgo ? null : run} >\n            Run\n        </div >\n    )\n}\n\nexport default GenerateTerrain\n","import CustomDropdown from './CustomDropdown.js'\nimport { useState } from 'react'\nimport { allTerrainAlgos, unweightedTerrainAlgos } from '../utils/constants.js'\nimport { isAlgoUnweighted } from '../utils/helper.js'\nimport GenerateTerrain from './GenerateTerrain.js'\n\nconst ChooseTerrain = ({ rows, cols, gridState, setGridState, startCord, targetCord, runningAlgo, setRunningAlgo, dropDownWidth, resetGrid, selectedAlgo }) => {\n    const [selectedTerrainAlgo, setSelectedTerrainAlgo] = useState(allTerrainAlgos[0]);\n\n    return (\n        <div className={`choose-terrain`}>\n            <CustomDropdown setSelection={setSelectedTerrainAlgo} items={isAlgoUnweighted(selectedAlgo) ? unweightedTerrainAlgos : allTerrainAlgos} disabled={false} dropDownWidth={dropDownWidth} isAlgoSelector={false} isObstacleSelector={false} isTerrainSelector={true} />\n            <GenerateTerrain rows={rows} cols={cols} selectedTerrainAlgo={selectedTerrainAlgo} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} resetGrid={resetGrid} />\n        </div >\n    )\n}\n\nexport default ChooseTerrain\n","import CustomDropdown from './CustomDropdown.js'\nimport { obstacleTypes, obsEnum } from '../utils/constants.js'\n\nconst ChooseObstacle = ({ setSelectedObstacle, weightedObsDisabled, dropDownWidth }) => {\n    const setObstacle = (obstacleName) => {\n        console.log(\"selected obs: \", obsEnum[obstacleName]);\n        setSelectedObstacle(obsEnum[obstacleName]);\n    };\n\n    return (\n        <div className={`choose-obstacle`}>\n            <CustomDropdown setSelection={setObstacle} items={obstacleTypes} disabled={weightedObsDisabled} dropDownWidth={dropDownWidth} isAlgoSelector={false} isObstacleSelector={true} />\n        </div >\n    )\n}\n\nexport default ChooseObstacle\n","import Reset from './Reset.js'\nimport Clear from './Clear.js'\nimport ChooseAlgorithm from './ChooseAlgorithm.js'\nimport ChooseTerrain from './ChooseTerrain.js'\nimport ChooseObstacle from './ChooseObstacle.js'\n\nconst Header = ({ rows, cols, runningAlgo, setRunningAlgo, padding, height, gridState, setGridState, startCord, targetCord, clearObstacles, clearPath, setSelectedObstacle, weightedObsDisabled, toggleInfoBox, selectedAlgo, setSelectedAlgo, resetGrid }) => {\n    const style = {\n        padding: padding,\n        paddingBottom: padding / 2,\n        height: height\n    };\n\n    return (\n        <div style={style} className='header'>\n            <Reset clearObstacles={clearObstacles} runningAlgo={runningAlgo} />\n            <Clear clearPath={clearPath} runningAlgo={runningAlgo} />\n            <ChooseAlgorithm rows={rows} cols={cols} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearPath} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} dropDownWidth={260} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} setSelectedAlgo={setSelectedAlgo} />\n            <ChooseObstacle setSelectedObstacle={setSelectedObstacle} weightedObsDisabled={weightedObsDisabled} dropDownWidth={190} />\n            <ChooseTerrain rows={rows} cols={cols} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} resetGrid={resetGrid} selectedAlgo={selectedAlgo} dropDownWidth={200} />\n        </div>\n    )\n}\n\nexport default Header\n","export default __webpack_public_path__ + \"static/media/close.494fd48f.svg\";","import { useState } from 'react'\nimport closeIcon from '../images/close.svg'\nimport { pathfindingAlgoInfo } from '../utils/constants.js'\n\nconst InfoBox = ({ infoBoxOpen, toggleInfoBox, selectedAlgo, startingPos }) => {\n    const [dragging, setDragging] = useState(false);\n    const [boxCord, setBoxCord] = useState(startingPos);\n\n    const enableDragging = (e) => {\n        setDragging(true);\n    };\n\n    const beingDragged = (e) => {\n        if (dragging) {\n            setBoxCord(prevState => [prevState[0] + e.movementX, prevState[1] + e.movementY]);\n        }\n    };\n\n    const disableDragging = (e) => {\n        setDragging(false);\n    };\n\n    return (\n        <div style={{ left: `${boxCord[0]}px`, top: `${boxCord[1]}px` }} className={`info-box ${infoBoxOpen ? 'visible' : 'hidden'}`} onMouseMove={beingDragged} onMouseUp={disableDragging} onMouseLeave={disableDragging}>\n            <img className='close-info-icon' src={closeIcon} onClick={toggleInfoBox} alt='Close info box' />\n            <h1 onMouseDown={enableDragging} >{selectedAlgo}</h1>\n            {(pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].summary) || <p>No information.</p>}\n            {pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].description}\n            {pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].pseudocode && <p className='identifier'>Pseudocode:</p>}\n            {pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].pseudocode}\n        </div >\n    )\n}\n\nexport default InfoBox\n","import Grid from './components/Grid.js'\nimport Header from './components/Header.js'\nimport InfoBox from './components/InfoBox.js'\n\nimport { allPathAlgos, nodeTypeEnum } from './utils/constants.js'\nimport { useState, useEffect } from 'react'\nimport { isAlgoUnweighted } from './utils/helper.js'\n\nfunction App() {\n  const [gridState, setGridState] = useState({});\n  const [selectedObstacle, setSelectedObstacle] = useState('wall');\n  const [infoBoxOpen, setInfoBoxOpen] = useState(false);\n  const [selectedAlgo, setSelectedAlgo] = useState(allPathAlgos[0]);\n  const [rows, setRows] = useState(0);\n  const [cols, setCols] = useState(0);\n  const [startCord, setStartCord] = useState('0:0');\n  const [targetCord, setTargetCord] = useState('0:0');\n  const [runningAlgo, setRunningAlgo] = useState(false);\n  const [weightedObsDisabled, setWeightedObsDisabled] = useState(false);\n  const margin = 30;\n  const nodeSize = 28;\n  const navBarHeight = 90;\n\n  useEffect(() => {\n    console.log(\"RESETTING BOARD\");\n    initializeGrid();\n  }, []);\n\n  // useEffect(() => {\n  //   window.addEventListener(\"resize\", resizeGrid);\n  //   return () => window.removeEventListener(\"resize\", resizeGrid);\n  // }, []);\n\n  const initializeGrid = () => {\n    const adjustedWinHeight = window.innerHeight - (navBarHeight + (margin * 3));\n    const adjustedWinWidth = window.innerWidth - (2 * margin);\n\n    const currRows = parseInt(adjustedWinHeight / (nodeSize + 1));\n    const currCols = parseInt(adjustedWinWidth / (nodeSize + 1));\n\n    setRunningAlgo(false);\n    setRows(currRows);\n    setCols(currCols);\n    setStartCord('1:1');\n    setTargetCord(`${currRows - 2}:${currCols - 2}`);\n  };\n\n  const clearPath = () => {\n    console.log(\"CLEARING PATH\");\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] <= nodeTypeEnum.visiting)) {\n          nodeState.splice(1, 1);\n        }\n        else if (currState <= nodeTypeEnum.visiting) {\n          nodeState.splice(0, 1);\n        }\n\n        nodeStateFunc(prevState => nodeState);\n      }\n    }\n  };\n\n  const clearObstacles = () => {\n    let gridMap = {};\n    let updateGrid = false;\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        gridMap[id] = [nodeState, nodeStateFunc];\n\n        // check under start and target node for obstacle\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] >= nodeTypeEnum.wall)) {\n          updateGrid = true;\n          nodeState.splice(1, 1);\n          nodeStateFunc(prev => nodeState);\n          gridMap[id] = [nodeState, nodeStateFunc];\n          continue;\n        }\n\n        if (currState <= nodeTypeEnum.visiting) {\n          currState = nodeState[1];\n        }\n\n        if (currState >= nodeTypeEnum.wall) {\n          updateGrid = true;\n          nodeStateFunc(prev => [nodeTypeEnum.none]);\n          gridMap[id] = [[nodeTypeEnum.none], nodeStateFunc];\n        }\n      }\n    }\n\n    if (updateGrid) {\n      setGridState(prevState => gridMap);\n    }\n  };\n\n  const clearWeightedObstacles = () => {\n    let gridMap = {};\n    let updateGrid = false;\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        gridMap[id] = [nodeState, nodeStateFunc];\n\n        // check under start and target node for weighted obstacle\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] > nodeTypeEnum.wall)) {\n          updateGrid = true;\n          nodeState.splice(1, 1);\n          nodeStateFunc(prev => nodeState);\n          gridMap[id] = [nodeState, nodeStateFunc];\n          continue;\n        }\n\n        if (currState <= nodeTypeEnum.visiting) {\n          currState = nodeState[1];\n        }\n\n        if (currState > nodeTypeEnum.wall) {\n          updateGrid = true;\n          nodeStateFunc(prev => [nodeTypeEnum.none]);\n          gridMap[id] = [[nodeTypeEnum.none], nodeStateFunc];\n        }\n      }\n    }\n\n    if (updateGrid) {\n      setGridState(prevState => gridMap);\n    }\n  };\n\n  const resetGrid = () => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n        let newState = [nodeTypeEnum.none];\n\n        if (currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) {\n          newState.unshift(currState);\n        }\n\n        nodeStateFunc(prev => newState);\n        gridMap[id] = [newState, nodeStateFunc];\n      }\n    }\n\n    setGridState(prevState => gridMap);\n  };\n\n  const toggleInfoBox = () => {\n    setInfoBoxOpen(prevState => !prevState);\n  };\n\n  const alteredSetSelectedAlgo = (algoName) => {\n    const unweightedAlgo = isAlgoUnweighted(algoName);\n    setWeightedObsDisabled(unweightedAlgo);\n    setSelectedAlgo(algoName);\n    if (unweightedAlgo) {\n      clearPath();\n      clearWeightedObstacles();\n    }\n  };\n\n  return (\n    <>\n      <Header rows={rows} cols={cols} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} padding={margin} height={navBarHeight} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearObstacles={clearObstacles} clearPath={clearPath} setSelectedObstacle={setSelectedObstacle} weightedObsDisabled={weightedObsDisabled} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} setSelectedAlgo={alteredSetSelectedAlgo} resetGrid={resetGrid} />\n      <Grid rows={rows} cols={cols} padding={margin} nodeSize={nodeSize} setGridState={setGridState} selectedObstacle={selectedObstacle} setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} />\n      <InfoBox infoBoxOpen={infoBoxOpen} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} startingPos={[(window.innerWidth / 2) - 285, (navBarHeight + (margin * 2))]} />\n    </>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}