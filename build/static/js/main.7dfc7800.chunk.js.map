{"version":3,"sources":["utils/helper.js","algorithms/path_finding/aStar.js","algorithms/path_finding/bestFirst.js","utils/constants.js","algorithms/path_finding/dijkstras.js","algorithms/path_finding/bfs.js","algorithms/path_finding/dfs.js","components/Node.js","components/Grid.js","components/Reset.js","components/Clear.js","components/Visualize.js","images/down_arrow.svg","images/weight.svg","images/weight_unfilled.svg","images/optimal.svg","images/optimal_unfilled.svg","components/CustomDropdown.js","components/ShowInfo.js","components/ChooseAlgorithm.js","components/ChooseTerrain.js","components/ChooseObstacle.js","components/Header.js","images/close.svg","components/InfoBox.js","App.js","reportWebVitals.js","index.js"],"names":["getNeighbourNodes","node","rows","cols","gridState","row","parseInt","split","col","res","nodeTypeEnum","wall","push","createPath","startCord","targetCord","prevNodes","cord","path","findMinPriorityNode","minPQ","minPriority","Math","min","Object","values","key","isAlgoUnweighted","algo","unweightedPathAlgos","includes","h","currNodeCord","currRow","currCol","targetRow","targetCol","abs","DIJKSTRAS","ASTAR","BFS","DFS","BEST_FIRST","algoFunctions","timeout","totalCosts","visited","x","y","Infinity","keys","length","minKey","nodeStateFunc","setTimeout","prevState","slice","neighbours","neighbour","currPath","nodeWeight","visiting","openSet","G","H","F","currNode","currGScore","queue","currCord","pop","none","unshift","stack","shift","unvisitedNeighbourFound","splice","console","log","freeze","allPathAlgos","optimalPathAlgos","terrainAlgos","pathfindingAlgoInfo","nodeColorClass","target","start","weighted100","weighted80","weighted60","weighted40","weighted20","obstacleTypes","obsEnum","Node","nodeId","size","setGridState","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","selectedObstacle","startingState","useState","nodeState","setNodeState","useEffect","nodeStyle","width","height","cursor","style","className","remObstacle","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","Grid","React","memo","padding","nodeSize","nodes","gridDimensions","containerStyle","paddingLeft","paddingRight","Reset","clearObstacles","onClick","Clear","clearPath","Visualize","selectedAlgo","clearForReRun","setRunningAlgo","run","a","i","CustomDropdown","setSelection","items","disabled","dropDownWidth","dropDownOpen","setDropDownOpen","selectedVal","setSelectedVal","selectedId","setSelectedId","isAlgoSelector","dropdownItems","id","src","weightUnfilled","title","alt","weight","optimal","optimalUnfilled","downArrow","ShowInfo","toggleInfoBox","ChooseAlgorithm","setSelectedAlgo","ChooseTerrain","selectedTerrainAlgo","setSelectedTerrainAlgo","ChooseObstacle","setSelectedObstacle","weightedObsDisabled","obstacleName","Header","paddingBottom","InfoBox","infoBoxOpen","dragging","setDragging","boxCord","setBoxCord","disableDragging","e","left","top","onMouseMove","movementX","movementY","closeIcon","description","optimality","App","setInfoBoxOpen","setRows","setCols","setWeightedObsDisabled","resetBoard","adjustedWinHeight","window","innerHeight","adjustedWinWidth","innerWidth","gridMap","currState","prev","algoName","unweightedAlgo","clearWeightedObstacles","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7dfc7800.chunk.js","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos } from './constants.js'\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n","import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const aStar = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let G = { [startCord]: 0 }; // G(n) => tell us the current shortest distance from start node to node n\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = G(n) + H(n)\n    let visited = {};\n    let prevNodes = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = G[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n            }, timeout);\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currGScore = G[currNode] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (currGScore < G[neighbour]) {\n                if (neighbour !== startCord && neighbour !== targetCord && !(neighbour in visited)) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    setTimeout(() => {\n                        nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                    }, timeout);\n                }\n                visited[neighbour] = 1;\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                G[neighbour] = currGScore;\n                H[neighbour] = h(neighbour, targetCord);\n                F[neighbour] = G[neighbour] + H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst h = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};","import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bestFirst = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = H(n)\n    let prevNodes = {};\n    let visited = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n            }, timeout);\n        }\n        else if (currNode === targetCord) {\n            console.log(\"DONNEE\");\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            if (!(neighbour in visited)) {\n                visited[neighbour] = 1;\n\n                if (neighbour !== startCord && neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    setTimeout(() => {\n                        nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                    }, timeout);\n                }\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                H[neighbour] = h(neighbour, targetCord) + nodeWeight[gridState[neighbour][0][0]];\n                F[neighbour] = H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst h = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};","import { dijkstras } from '../algorithms/path_finding/dijkstras.js'\nimport { dfs } from '../algorithms/path_finding/dfs.js'\nimport { bfs } from '../algorithms/path_finding/bfs.js'\nimport { aStar } from '../algorithms/path_finding/aStar.js'\nimport { bestFirst } from '../algorithms/path_finding/bestFirst.js';\n\n// PATHFINDING ALGORITHM CONSTANTS -------------------------------------------\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = 'A* (A-Star)';\nconst BFS = 'Breadth-first Search';\nconst DFS = 'Depth-first Search';\nconst BEST_FIRST = 'Best-first Search';\n\nconst algoFunctions = {\n    [DIJKSTRAS]: dijkstras,\n    [ASTAR]: aStar,\n    [BFS]: bfs,\n    [DFS]: dfs,\n    [BEST_FIRST]: bestFirst\n}\nObject.freeze(algoFunctions);\n\nexport { DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST, algoFunctions };\n\nconst allPathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST];\nObject.freeze(allPathAlgos);\nconst unweightedPathAlgos = [DFS, BFS];\nObject.freeze(unweightedPathAlgos);\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\nObject.freeze(optimalPathAlgos);\n\nexport { allPathAlgos, unweightedPathAlgos, optimalPathAlgos };\n\n// TERRAIN ALGORTHIM CONSTANTS -------------------------------------------\nconst ALGO1 = \"ALGO 1\";\nconst ALGO2 = \"ALGO 2\";\nconst terrainAlgos = [ALGO1, ALGO2];\nObject.freeze(terrainAlgos);\n\nexport { ALGO1, ALGO2, terrainAlgos };\n\nconst pathfindingAlgoInfo = {\n    [DIJKSTRAS]: {\n        'description': <p>Dijkstra's algorithm to find the shortest path between a and b. It picks the unvisited vertex with the <strong>lowest distance</strong>, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors.</p>,\n        'optimality': <p>Dijkstra's is guranteed to find the shortest path.</p>\n    }\n}\nObject.freeze(pathfindingAlgoInfo);\nexport { pathfindingAlgoInfo };\n\n// NODE TYPES ------------------------------------------------------------\nconst nodeTypeEnum = {\n    'path': 0,\n    'visited': 1,\n    'visiting': 2,\n    'none': 3,\n    'target': 4,\n    'start': 5,\n    'remObstacle': 6,\n    'wall': 7,\n    'weighted100': 8,\n    'weighted80': 9,\n    'weighted60': 10,\n    'weighted40': 11,\n    'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\n\nexport { nodeTypeEnum };\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'none',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.wall]: 'wall',\n    [nodeTypeEnum.visiting]: 'visiting',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path',\n    [nodeTypeEnum.weighted100]: 'weighted100',\n    [nodeTypeEnum.weighted80]: 'weighted80',\n    [nodeTypeEnum.weighted60]: 'weighted60',\n    [nodeTypeEnum.weighted40]: 'weighted40',\n    [nodeTypeEnum.weighted20]: 'weighted20'\n}\nObject.freeze(nodeColorClass);\n\nexport { nodeColorClass };\n\nconst nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.wall]: Infinity,\n    [nodeTypeEnum.start]: 1,\n    [nodeTypeEnum.weighted100]: 100,\n    [nodeTypeEnum.weighted80]: 80,\n    [nodeTypeEnum.weighted60]: 60,\n    [nodeTypeEnum.weighted40]: 40,\n    [nodeTypeEnum.weighted20]: 20\n}\nObject.freeze(nodeWeight);\nexport { nodeWeight };\n\n// OBSTACLE TYPES --------------------------------------------------------\nconst obstacleTypes = ['Wall (âˆž)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n    [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n    [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n    [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n    [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n    [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n    [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n}\nObject.freeze(obsEnum);\nexport { obstacleTypes, obsEnum };","import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            const nodeStateFunc = gridState[minKey][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n            }, timeout);\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    setTimeout(() => {\n                        nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                    }, timeout);\n                }\n            }\n        }\n    }\n\n    return [];\n};","import { getNeighbourNodes, createPath } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bfs = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n            }, timeout);\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            const nodeStateFunc = gridState[neighbour][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n            }, timeout);\n        }\n    }\n\n    return [];\n};\n","import { getNeighbourNodes } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const path = [];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n            }, timeout);\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            path.unshift(currCord);\n            visited[currCord] = 1;\n            const nodeStateFunc = gridState[currCord][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n            }, timeout);\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n    }\n\n    return [];\n};","import React from 'react'\nimport { useEffect, useState } from 'react'\nimport { nodeColorClass, nodeTypeEnum } from '../utils/constants.js'\n\nconst Node = ({ nodeId, size, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo, selectedObstacle, startingState }) => {\n    const [nodeState, setNodeState] = useState(startingState);\n\n    useEffect(() => {\n        setGridState(prevState => ({ ...prevState, [nodeId]: [startingState, setNodeState] }));\n    }, []);\n\n    const nodeStyle = {\n        width: size,\n        height: size\n    };\n\n    if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n        nodeStyle.cursor = 'grabbing';\n    }\n\n    const mouseDowned = () => {\n        if (nodeState[0] <= nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum[selectedObstacle]);\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n            return;\n        }\n        else if (nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n            setDraggingSelection(nodeTypeEnum.remObstacle);\n            return;\n        }\n        else if (nodeState[0] === nodeTypeEnum.start || nodeState[0] === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === nodeTypeEnum.remObstacle && nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum[selectedObstacle] && nodeState[0] <= nodeTypeEnum.none) {\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.start) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => prevState.slice(1));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection === nodeTypeEnum.start) {\n            setStartCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setTargetCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        if (draggingSelection !== nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum.none);\n        }\n    };\n\n    return (\n        <div style={nodeStyle} className={`node ${nodeColorClass[nodeState[0]]} ${draggingSelection === nodeTypeEnum.remObstacle && 'erasing'}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n};\n\nexport default Node\n","import Node from './Node.js'\nimport React from 'react'\nimport { useState } from 'react'\nimport { nodeTypeEnum } from '../utils/constants.js'\n\nconst Grid = React.memo(({ rows, cols, padding, nodeSize, setGridState, selectedObstacle, setStartCord, setTargetCord, runningAlgo }) => {\n    const [draggingSelection, setDraggingSelection] = useState(nodeTypeEnum.none);\n\n    // fill nodes in the grid\n    console.log(\"RERENDERING GRID\");\n    const nodes = [];\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let nodeId = `${x}:${y}`\n\n            let startingState = [nodeTypeEnum.none];\n            if (x === 0 && y === 0) {\n                startingState.unshift(nodeTypeEnum.start);\n            }\n            else if (x === (rows - 1) && y === (cols - 1)) {\n                startingState.unshift(nodeTypeEnum.target);\n            }\n\n            nodes.push(<Node nodeId={nodeId}\n                size={nodeSize} setGridState={setGridState}\n                draggingSelection={draggingSelection}\n                setDraggingSelection={setDraggingSelection}\n                setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} selectedObstacle={selectedObstacle} startingState={startingState} key={nodeId} />);\n        }\n    }\n\n    const gridDimensions = {\n        width: (cols * nodeSize) + cols,\n        height: (rows * nodeSize) + rows\n    };\n\n    const containerStyle = {\n        paddingLeft: padding,\n        paddingRight: padding\n    }\n\n    return (\n        <div style={containerStyle}>\n            <div className='grid' style={gridDimensions}>\n                {nodes}\n            </div >\n        </div>\n    )\n});\n\nexport default Grid\n","const Reset = ({ clearObstacles, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'red'}`} onClick={runningAlgo ? null : clearObstacles}>\n            Clear Obstacles\n        </div >\n    )\n}\n\nexport default Reset\n","import React from 'react'\n\nconst Clear = ({ clearPath, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'orange'}`} onClick={runningAlgo ? null : clearPath}>\n            Clear Path\n        </div >\n    )\n}\n\nexport default Clear\n","import { algoFunctions, nodeTypeEnum } from '../utils/constants.js'\n\nconst Visualize = ({ rows, cols, selectedAlgo, gridState, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo }) => {\n    const run = async () => {\n        if (startCord === targetCord) {\n            return;\n        }\n\n        clearForReRun();\n        setRunningAlgo(true);\n        console.log(\"STARTING: \", selectedAlgo);\n\n        let path = [];\n        let timeout = 1;\n        path = algoFunctions[selectedAlgo](startCord, targetCord, gridState, rows, cols, timeout);\n\n        console.log(\"ENDED: \", selectedAlgo);\n\n        for (let i = path.length - 1; i >= 0; i--) {\n            const nodeStateFunc = gridState[path[i]][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.path, ...prevState]));\n            }, timeout);\n        }\n\n        setTimeout(() => {\n            setRunningAlgo(false);\n        }, timeout);\n    };\n\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'green'}`} onClick={runningAlgo ? null : run} >\n            Run\n        </div >\n    )\n}\n\nexport default Visualize\n","export default __webpack_public_path__ + \"static/media/down_arrow.8fed4a28.svg\";","export default __webpack_public_path__ + \"static/media/weight.e51e9729.svg\";","export default __webpack_public_path__ + \"static/media/weight_unfilled.cc3c5f2f.svg\";","export default __webpack_public_path__ + \"static/media/optimal.5649a19a.svg\";","export default __webpack_public_path__ + \"static/media/optimal_unfilled.e461ee2c.svg\";","import { useState, useEffect } from 'react'\nimport { isAlgoUnweighted, isAlgoOptimal } from '../utils/helper.js'\nimport { allPathAlgos } from '../utils/constants.js'\nimport downArrow from '../images/down_arrow.svg';\nimport weight from '../images/weight.svg'\nimport weightUnfilled from '../images/weight_unfilled.svg'\nimport optimal from '../images/optimal.svg'\nimport optimalUnfilled from '../images/optimal_unfilled.svg'\n\nconst CustomDropdown = ({ setSelection, items, disabled, dropDownWidth }) => {\n    const [dropDownOpen, setDropDownOpen] = useState(false);\n    const [selectedVal, setSelectedVal] = useState(items[0]);\n    const [selectedId, setSelectedId] = useState(0);\n    const isAlgoSelector = (allPathAlgos[0] === items[0]);\n\n    useEffect(() => {\n        if (disabled) {\n            setSelectedVal(items[0]);\n            setSelectedId(0);\n            setDropDownOpen(false);\n            setSelection(items[0]);\n        }\n    }, [disabled])\n\n    const toggle = () => {\n        setDropDownOpen(prevState => !prevState);\n    }\n\n    const madeSelection = (id) => {\n        setDropDownOpen(prevState => !prevState);\n        setSelectedVal(items[id]);\n        setSelectedId(id);\n        setSelection(items[id]);\n    };\n\n    const style = {\n        width: dropDownWidth\n    }\n\n    const dropdownItems = [];\n    for (let i = 0; i < items.length; i++) {\n        dropdownItems.push(<div style={style} className={`dropdown-list-item ${i === selectedId && 'selected'} ${i === items.length - 1 && 'last'}`} onClick={() => { madeSelection(i) }} key={i}>\n            {items[i]}\n            {isAlgoSelector && (!isAlgoUnweighted(items[i]) ? <img className=\"algo-property-badge\" src={weight} title={`${items[i]} is a weighted path-finding algorithm.`} alt={`${items[i]} is a weighted path-finding algorithm.`}></img> : <img className=\"algo-property-badge\" src={weightUnfilled} title={`${items[i]} is not a weighted path-finding algorithm.`} alt={`${items[i]} is not a weighted path-finding algorithm.`}></img>)}\n            {isAlgoSelector && (isAlgoOptimal(items[i]) ? <img className=\"algo-property-badge\" src={optimal} title={`${items[i]} guarantees shortest path.`} alt={`${items[i]} guarantees shortest path.`}></img> : <img className=\"algo-property-badge\" src={optimalUnfilled} title={`${items[i]} does not guarantee shortest path.`} alt={`${items[i]} does not guarantee shortest path.`}></img>)}\n        </div>)\n    }\n\n    return (\n        <div className='dropdown'>\n            <div style={style} className={`dropdown-header ${dropDownOpen && 'open'} ${disabled && 'disabled'}`} onClick={disabled ? null : toggle}>\n                {selectedVal}\n                {!disabled && <img className=\"down-arrow\" src={downArrow} alt=\"\"></img>}\n            </div>\n            {dropDownOpen &&\n                <div className='dropdown-list'>\n                    {dropdownItems}\n                </div>\n            }\n        </div >\n    )\n}\n\nexport default CustomDropdown\n","const ShowInfo = ({ toggleInfoBox }) => {\n    return (\n        <div className={`button blue`} onClick={toggleInfoBox} >\n            Info\n        </div >\n    )\n}\n\nexport default ShowInfo\n","import Visualize from './Visualize.js'\nimport CustomDropdown from './CustomDropdown.js'\nimport ShowInfo from './ShowInfo.js'\n\nimport { allPathAlgos } from '../utils/constants.js'\n\nconst ChooseAlgorithm = ({ rows, cols, gridState, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo, dropDownWidth, toggleInfoBox, selectedAlgo, setSelectedAlgo }) => {\n\n    return (\n        <div className={`choose-algo`}>\n            <CustomDropdown setSelection={setSelectedAlgo} items={allPathAlgos} disabled={false} dropDownWidth={dropDownWidth} />\n            <ShowInfo toggleInfoBox={toggleInfoBox} />\n            <Visualize rows={rows} cols={cols} selectedAlgo={selectedAlgo} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearForReRun} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} />\n        </div >\n    )\n}\n\nexport default ChooseAlgorithm\n","import Visualize from './Visualize.js'\nimport CustomDropdown from './CustomDropdown.js'\nimport { useState } from 'react'\nimport { terrainAlgos } from '../utils/constants.js'\n\nconst ChooseTerrain = ({ rows, cols, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo, dropDownWidth }) => {\n    const [selectedTerrainAlgo, setSelectedTerrainAlgo] = useState(terrainAlgos[0]);\n\n    return (\n        <div className={`choose-terrain`}>\n            <CustomDropdown setSelection={setSelectedTerrainAlgo} items={terrainAlgos} disabled={false} dropDownWidth={dropDownWidth} />\n            <Visualize rows={rows} cols={cols} selectedAlgo={selectedTerrainAlgo} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearForReRun} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} />\n        </div >\n    )\n}\n\nexport default ChooseTerrain\n","import CustomDropdown from './CustomDropdown.js'\nimport { obstacleTypes, obsEnum } from '../utils/constants.js'\n\nconst ChooseObstacle = ({ setSelectedObstacle, weightedObsDisabled, dropDownWidth }) => {\n    const setObstacle = (obstacleName) => {\n        console.log(\"selected obs: \", obsEnum[obstacleName]);\n        setSelectedObstacle(obsEnum[obstacleName]);\n    };\n\n    return (\n        <div className={`choose-obstacle`}>\n            <CustomDropdown setSelection={setObstacle} items={obstacleTypes} disabled={weightedObsDisabled} dropDownWidth={dropDownWidth} />\n        </div >\n    )\n}\n\nexport default ChooseObstacle\n","import Reset from './Reset.js'\nimport Clear from './Clear.js'\nimport ChooseAlgorithm from './ChooseAlgorithm.js'\nimport ChooseTerrain from './ChooseTerrain.js'\nimport ChooseObstacle from './ChooseObstacle.js'\n\nconst Header = ({ rows, cols, runningAlgo, setRunningAlgo, padding, height, gridState, setGridState, startCord, targetCord, clearObstacles, clearPath, setSelectedObstacle, weightedObsDisabled, toggleInfoBox, selectedAlgo, setSelectedAlgo }) => {\n    const style = {\n        padding: padding,\n        paddingBottom: padding / 2,\n        height: height\n    };\n\n    return (\n        <div style={style} className='header'>\n            <Reset clearObstacles={clearObstacles} runningAlgo={runningAlgo} />\n            <Clear clearPath={clearPath} runningAlgo={runningAlgo} />\n            <ChooseAlgorithm rows={rows} cols={cols} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearPath} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} dropDownWidth={250} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} setSelectedAlgo={setSelectedAlgo} />\n            <ChooseObstacle setSelectedObstacle={setSelectedObstacle} weightedObsDisabled={weightedObsDisabled} dropDownWidth={175} />\n            <ChooseTerrain rows={rows} cols={cols} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearPath} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} dropDownWidth={150} />\n        </div>\n    )\n}\n\nexport default Header\n","export default __webpack_public_path__ + \"static/media/close.494fd48f.svg\";","import { useState } from 'react'\nimport closeIcon from '../images/close.svg'\nimport { pathfindingAlgoInfo } from '../utils/constants.js'\n\nconst InfoBox = ({ infoBoxOpen, toggleInfoBox, selectedAlgo }) => {\n    const [dragging, setDragging] = useState(false);\n    const [boxCord, setBoxCord] = useState([300, 0]);\n\n    const enableDragging = (e) => {\n        setDragging(true);\n    };\n\n    const beingDragged = (e) => {\n        if (dragging) {\n            setBoxCord(prevState => [prevState[0] + e.movementX, prevState[1] + e.movementY]);\n        }\n    };\n\n    const disableDragging = (e) => {\n        setDragging(false);\n    };\n\n    return (\n        <div style={{ left: `${boxCord[0]}px`, top: `${boxCord[1]}px` }} className={`info-box ${infoBoxOpen ? 'visible' : 'hidden'}`} onMouseMove={beingDragged} onMouseUp={disableDragging} onMouseLeave={disableDragging}>\n            <img className='close-info-icon' src={closeIcon} onClick={toggleInfoBox} alt='Close info box' />\n            <h1 onMouseDown={enableDragging} >{selectedAlgo}</h1>\n            {(pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].description) || <p>No information.</p>}\n            {(pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].optimality)}\n        </div >\n    )\n}\n\nexport default InfoBox\n","import Grid from './components/Grid.js'\nimport Header from './components/Header.js'\nimport InfoBox from './components/InfoBox.js'\n\nimport { allPathAlgos, nodeTypeEnum } from './utils/constants.js'\nimport { useState, useEffect } from 'react'\nimport { isAlgoUnweighted } from './utils/helper.js'\n\nfunction App() {\n  const [gridState, setGridState] = useState({});\n  const [selectedObstacle, setSelectedObstacle] = useState('wall');\n  const [infoBoxOpen, setInfoBoxOpen] = useState(false);\n  const [selectedAlgo, setSelectedAlgo] = useState(allPathAlgos[0]);\n  const [rows, setRows] = useState(0);\n  const [cols, setCols] = useState(0);\n  const [startCord, setStartCord] = useState('0:0');\n  const [targetCord, setTargetCord] = useState('0:0');\n  const [runningAlgo, setRunningAlgo] = useState(false);\n  const [weightedObsDisabled, setWeightedObsDisabled] = useState(false);\n  const margin = 30;\n  const nodeSize = 28;\n  const navBarHeight = 90;\n\n  useEffect(() => {\n    console.log(\"RESETTING BOARD\");\n    resetBoard();\n  }, []);\n\n  // useEffect(() => {\n  //   window.addEventListener(\"resize\", resetBoard);\n  //   return () => window.removeEventListener(\"resize\", resetBoard)\n  // }, []);\n\n  const resetBoard = () => {\n    const adjustedWinHeight = window.innerHeight - (navBarHeight + (margin * 3));\n    const adjustedWinWidth = window.innerWidth - (2 * margin);\n\n    const rows = parseInt(adjustedWinHeight / (nodeSize + 1));\n    const cols = parseInt(adjustedWinWidth / (nodeSize + 1));\n\n    setRunningAlgo(false);\n    setRows(rows);\n    setCols(cols);\n    setStartCord('0:0');\n    setTargetCord(`${rows - 1}:${cols - 1}`);\n\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let nodeState = [nodeTypeEnum.none];\n        if (x === 0 && y === 0) {\n          nodeState.unshift(nodeTypeEnum.start);\n        }\n        else if (x === (rows - 1) && y === (cols - 1)) {\n          nodeState.unshift(nodeTypeEnum.target);\n        }\n\n        gridMap[`${x}:${y}`] = nodeState;\n      }\n    }\n\n    setGridState(gridMap);\n  };\n\n  const clearPath = () => {\n    console.log(\"CLEARING PATH\");\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] <= nodeTypeEnum.visiting)) {\n          nodeState.splice(1, 1);\n        }\n        nodeStateFunc(prevState => nodeState);\n      }\n    }\n  };\n\n  const clearObstacles = () => {\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        // check under start and target node for obstacle\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] >= nodeTypeEnum.wall)) {\n          nodeState.splice(1, 1);\n          nodeStateFunc(prev => nodeState);\n          setGridState(prevState => ({ ...prevState, [id]: [nodeState, prevState[id][1]] }));\n          continue;\n        }\n\n        if (currState <= nodeTypeEnum.visiting) {\n          currState = nodeState[1];\n        }\n\n        if (currState >= nodeTypeEnum.wall) {\n          nodeStateFunc(prev => [nodeTypeEnum.none]);\n          setGridState(prevState => ({ ...prevState, [id]: [[nodeTypeEnum.none], prevState[id][1]] }));\n        }\n      }\n    }\n  };\n\n  const clearWeightedObstacles = () => {\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        // check under start and target node for weighted obstacle\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] > nodeTypeEnum.wall)) {\n          nodeState.splice(1, 1);\n          nodeStateFunc(prev => nodeState);\n          setGridState(prevState => ({ ...prevState, [id]: [nodeState, prevState[id][1]] }));\n          continue;\n        }\n\n        if (currState <= nodeTypeEnum.visiting) {\n          currState = nodeState[1];\n        }\n\n        if (currState > nodeTypeEnum.wall) {\n          nodeStateFunc(prev => [nodeTypeEnum.none]);\n          setGridState(prevState => ({ ...prevState, [id]: [[nodeTypeEnum.none], prevState[id][1]] }));\n        }\n      }\n    }\n  };\n\n  const toggleInfoBox = () => {\n    setInfoBoxOpen(prevState => !prevState);\n  };\n\n  const alteredSetSelectedAlgo = (algoName) => {\n    const unweightedAlgo = isAlgoUnweighted(algoName);\n    setWeightedObsDisabled(unweightedAlgo);\n    setSelectedAlgo(algoName);\n    if (unweightedAlgo) {\n      clearPath();\n      clearWeightedObstacles();\n    }\n  };\n\n  return (\n    <>\n      <Header rows={rows} cols={cols} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} padding={margin} height={navBarHeight} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearObstacles={clearObstacles} clearPath={clearPath} setSelectedObstacle={setSelectedObstacle} weightedObsDisabled={weightedObsDisabled} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} setSelectedAlgo={alteredSetSelectedAlgo} />\n      <Grid rows={rows} cols={cols} padding={margin} nodeSize={nodeSize} setGridState={setGridState} selectedObstacle={selectedObstacle} setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} />\n      <InfoBox infoBoxOpen={infoBoxOpen} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} />\n    </>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}