{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nexport const randomWeighted = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  let gridMap = {};\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n      const randomNum = getRandomNum(1, 10);\n\n      if (randomNum >= 5) {\n        gridMap[currCord] = [gridState[currCord][0], nodeStateFunc];\n        continue;\n      } // place a random obstacle\n\n\n      const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20);\n      let newState = [randomObstacle, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        newState.unshift(nodeTypeEnum.start);\n      } else if (currCord === targetCord) {\n        newState.unshift(nodeTypeEnum.target);\n      }\n\n      nodeStateFunc(prevState => newState);\n      gridMap[currCord] = [newState, nodeStateFunc];\n      await sleep(timeout);\n    }\n  }\n\n  setGridState(prevState => gridMap);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/randomWeighted.js"],"names":["nodeTypeEnum","sleep","getRandomNum","randomWeighted","startCord","targetCord","gridState","setGridState","rows","cols","timeout","gridMap","x","y","currCord","nodeStateFunc","randomNum","randomObstacle","wall","weighted20","newState","none","unshift","start","target","prevState"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,QAAoC,uBAApC;AAEA,OAAO,MAAMC,cAAc,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,YAAzC,EAAuDC,IAAvD,EAA6DC,IAA7D,EAAmEC,OAAnE,KAA+E;AACzG,MAAIC,OAAO,GAAG,EAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,YAAMC,QAAQ,GAAI,GAAEF,CAAE,IAAGC,CAAE,EAA3B;AACA,YAAME,aAAa,GAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACA,YAAME,SAAS,GAAGd,YAAY,CAAC,CAAD,EAAI,EAAJ,CAA9B;;AAEA,UAAIc,SAAS,IAAI,CAAjB,EAAoB;AAChBL,QAAAA,OAAO,CAACG,QAAD,CAAP,GAAoB,CAACR,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAD,EAAyBC,aAAzB,CAApB;AACA;AACH,OAR0B,CAU3B;;;AACA,YAAME,cAAc,GAAGf,YAAY,CAACF,YAAY,CAACkB,IAAd,EAAoBlB,YAAY,CAACmB,UAAjC,CAAnC;AACA,UAAIC,QAAQ,GAAG,CAACH,cAAD,EAAiBjB,YAAY,CAACqB,IAA9B,CAAf;;AAEA,UAAIP,QAAQ,KAAKV,SAAjB,EAA4B;AACxBgB,QAAAA,QAAQ,CAACE,OAAT,CAAiBtB,YAAY,CAACuB,KAA9B;AACH,OAFD,MAGK,IAAIT,QAAQ,KAAKT,UAAjB,EAA6B;AAC9Be,QAAAA,QAAQ,CAACE,OAAT,CAAiBtB,YAAY,CAACwB,MAA9B;AACH;;AAEDT,MAAAA,aAAa,CAACU,SAAS,IAAIL,QAAd,CAAb;AACAT,MAAAA,OAAO,CAACG,QAAD,CAAP,GAAoB,CAACM,QAAD,EAAWL,aAAX,CAApB;AACA,YAAMd,KAAK,CAACS,OAAD,CAAX;AACH;AACJ;;AAEDH,EAAAA,YAAY,CAACkB,SAAS,IAAId,OAAd,CAAZ;AACH,CA/BM","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nexport const randomWeighted = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(1, 10);\n\n            if (randomNum >= 5) {\n                gridMap[currCord] = [gridState[currCord][0], nodeStateFunc];\n                continue;\n            }\n\n            // place a random obstacle\n            const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20);\n            let newState = [randomObstacle, nodeTypeEnum.none];\n\n            if (currCord === startCord) {\n                newState.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                newState.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => newState);\n            gridMap[currCord] = [newState, nodeStateFunc];\n            await sleep(timeout);\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};"]},"metadata":{},"sourceType":"module"}