{"ast":null,"code":"import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import React from'react';import{nodeColorClass,nodeTypeEnum}from'../utils/constants.js';// import eraser from '../images/eraser.svg'\nimport{jsx as _jsx}from\"react/jsx-runtime\";var Node=/*#__PURE__*/React.memo(function(_ref){var nodeId=_ref.nodeId,size=_ref.size,nodeState=_ref.nodeState,setGridState=_ref.setGridState,draggingSelection=_ref.draggingSelection,setDraggingSelection=_ref.setDraggingSelection,setStartCord=_ref.setStartCord,setTargetCord=_ref.setTargetCord,runningAlgo=_ref.runningAlgo,selectedObstacle=_ref.selectedObstacle;var nodeStyle={width:size,height:size};if(draggingSelection===nodeTypeEnum.start||draggingSelection===nodeTypeEnum.target){nodeStyle.cursor='grabbing';}var mouseDowned=function mouseDowned(){if(nodeState[0]<=nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum[selectedObstacle]);setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none]));});return;}else if(nodeState[0]>=nodeTypeEnum.wall){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,prevState[nodeId].slice(1)));});setDraggingSelection(nodeTypeEnum.remObstacle);return;}setDraggingSelection(nodeState[0]);};var mouseEntered=function mouseEntered(){if(draggingSelection===nodeTypeEnum.remObstacle&&nodeState[0]>=nodeTypeEnum.wall){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,prevState[nodeId].slice(1)));});}else if(draggingSelection===nodeTypeEnum[selectedObstacle]&&nodeState[0]<=nodeTypeEnum.none){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none]));});}else if(draggingSelection===nodeTypeEnum.start){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[draggingSelection].concat(_toConsumableArray(prevState[nodeId]))));});setStartCord(nodeId);}else if(draggingSelection===nodeTypeEnum.target){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[draggingSelection].concat(_toConsumableArray(prevState[nodeId]))));});setTargetCord(nodeId);}};var mouseLeft=function mouseLeft(){if(draggingSelection===nodeTypeEnum.start||draggingSelection===nodeTypeEnum.target){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,prevState[nodeId].slice(1)));});return;}};var mouseUped=function mouseUped(){if(draggingSelection!==nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum.none);}};return/*#__PURE__*/_jsx(\"div\",{style:nodeStyle,className:\"node \".concat(nodeColorClass[nodeState[0]],\" \").concat(draggingSelection===nodeTypeEnum.remObstacle&&'erasing'),onMouseDown:runningAlgo?null:mouseDowned,onMouseUp:runningAlgo?null:mouseUped,onMouseEnter:runningAlgo?null:mouseEntered,onMouseLeave:runningAlgo?null:mouseLeft});});export default Node;","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/components/Node.js"],"names":["React","nodeColorClass","nodeTypeEnum","Node","memo","nodeId","size","nodeState","setGridState","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","selectedObstacle","nodeStyle","width","height","start","target","cursor","mouseDowned","none","prevState","wall","slice","remObstacle","mouseEntered","mouseLeft","mouseUped"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { nodeColorClass, nodeTypeEnum } from '../utils/constants.js'\n// import eraser from '../images/eraser.svg'\n\nconst Node = React.memo(({ nodeId, size, nodeState, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo, selectedObstacle }) => {\n    const nodeStyle = {\n        width: size,\n        height: size\n    };\n\n    if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n        nodeStyle.cursor = 'grabbing';\n    }\n\n    const mouseDowned = () => {\n        if (nodeState[0] <= nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum[selectedObstacle]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none] }));\n            return;\n        }\n        else if (nodeState[0] >= nodeTypeEnum.wall) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n            setDraggingSelection(nodeTypeEnum.remObstacle);\n            return;\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === nodeTypeEnum.remObstacle && nodeState[0] >= nodeTypeEnum.wall) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n        }\n        else if (draggingSelection === nodeTypeEnum[selectedObstacle] && nodeState[0] <= nodeTypeEnum.none) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.start) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [draggingSelection, ...prevState[nodeId]] }));\n            setStartCord(nodeId);\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [draggingSelection, ...prevState[nodeId]] }));\n            setTargetCord(nodeId);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection !== nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum.none);\n        }\n    };\n\n    return (\n        <div style={nodeStyle} className={`node ${nodeColorClass[nodeState[0]]} ${draggingSelection === nodeTypeEnum.remObstacle && 'erasing'}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n});\n\nexport default Node\n"]},"metadata":{},"sourceType":"module"}