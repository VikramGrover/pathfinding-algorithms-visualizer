{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{getNodeTypeEnum,getNodeWeight,getNeighbourNodes}from'../../utils/util.js';export var dijkstras=function dijkstras(startCord,targetCord,gridState,setGridState,rows,cols){var totalCosts={};var prevNodes={};var minPQ={};var visited={};totalCosts[startCord]=0;minPQ[startCord]=0;for(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){totalCosts[cord]=Infinity;}}}var _loop=function _loop(){var minKey=findMinPriorityNode(minPQ);delete minPQ[minKey];visited[minKey]=1;if(minKey!==startCord&&minKey!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},minKey,[getNodeTypeEnum('visited')].concat(_toConsumableArray(prevState[minKey].slice(1)))));});},1);}else if(minKey===targetCord){return{v:createPath(startCord,targetCord,prevNodes)};}var neighbours=getNeighbourNodes(minKey,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{var _loop2=function _loop2(){var neighbour=_step.value;var currPath=totalCosts[minKey]+getNodeWeight(gridState[neighbour][0]);if(neighbour in visited){return\"continue\";}if(neighbour in minPQ&&currPath<totalCosts[neighbour]||!(neighbour in minPQ)){totalCosts[neighbour]=currPath;prevNodes[neighbour]=minKey;minPQ[neighbour]=currPath;if(neighbour!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},neighbour,[getNodeTypeEnum('visiting')].concat(_toConsumableArray(prevState[neighbour]))));});},1);}}};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(Object.keys(minPQ).length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};var createPath=function createPath(startCord,targetCord,prevNodes){var cord=targetCord;var path=[];while(true){cord=prevNodes[cord];if(cord===startCord){break;}path.push(cord);}return path;};var findMinPriorityNode=function findMinPriorityNode(minPQ){var minPriority=Math.min.apply(Math,_toConsumableArray(Object.values(minPQ)));for(var key in minPQ){if(minPQ[key]===minPriority){return key;}}};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNodeTypeEnum","getNodeWeight","getNeighbourNodes","dijkstras","startCord","targetCord","gridState","setGridState","rows","cols","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","minKey","findMinPriorityNode","setTimeout","prevState","slice","createPath","neighbours","neighbour","currPath","Object","keys","length","path","push","minPriority","Math","min","values","key"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight, getNeighbourNodes } from '../../utils/util.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [minKey]: [getNodeTypeEnum('visited'), ...prevState[minKey].slice(1)] }));\n            }, 1);\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + getNodeWeight(gridState[neighbour][0]);\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    setTimeout(() => {\n                        setGridState(prevState => ({ ...prevState, [neighbour]: [getNodeTypeEnum('visiting'), ...prevState[neighbour]] }));\n                    }, 1);\n                }\n            }\n        }\n    }\n\n    return [];\n};\n\nconst createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nconst findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};"]},"metadata":{},"sourceType":"module"}