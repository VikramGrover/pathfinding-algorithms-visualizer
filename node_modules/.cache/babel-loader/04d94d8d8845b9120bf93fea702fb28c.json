{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{nodeTypeEnum}from'../../utils/constants.js';import{sleep,getRandomNum}from'../../utils/helper.js';var HORIZONTAL=0;var VERTICAL=1;export var recursiveDivision=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var x,_loop,y;return _regeneratorRuntime.wrap(function _callee$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:x=0;case 1:if(!(x<rows)){_context2.next=12;break;}_loop=/*#__PURE__*/_regeneratorRuntime.mark(function _loop(){var currCord,nodeStateFunc,state;return _regeneratorRuntime.wrap(function _loop$(_context){while(1){switch(_context.prev=_context.next){case 0:currCord=\"\".concat(x,\":\").concat(y);nodeStateFunc=gridState[currCord][1];if(!(x===0||x===rows-1||y===0||y===cols-1)){_context.next=9;break;}_context.next=5;return sleep(timeout);case 5:state=[nodeTypeEnum.wall,nodeTypeEnum.none];if(currCord===startCord){state=[nodeTypeEnum.start,nodeTypeEnum.wall,nodeTypeEnum.none];}else if(currCord===targetCord){state=[nodeTypeEnum.target,nodeTypeEnum.wall,nodeTypeEnum.none];}nodeStateFunc(function(prevState){return state;});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[state,prevState[currCord][1]]));});case 9:case\"end\":return _context.stop();}}},_loop);});y=0;case 4:if(!(y<cols)){_context2.next=9;break;}return _context2.delegateYield(_loop(),\"t0\",6);case 6:y++;_context2.next=4;break;case 9:x++;_context2.next=1;break;case 12:_context2.next=14;return divide(startCord,targetCord,gridState,setGridState,1,rows-2,1,cols-2,timeout,rows,cols);case 14:case\"end\":return _context2.stop();}}},_callee);}));return function recursiveDivision(_x,_x2,_x3,_x4,_x5,_x6,_x7){return _ref.apply(this,arguments);};}();var divide=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(startCord,targetCord,gridState,setGridState,startRow,endRow,startCol,endCol,timeout,rows,cols){var width,height,orientation,sCol,sRow,skip,randRow,_loop2,i,_ret,_sRow,_sCol,_skip,randCol,_loop3,_i,_ret2;return _regeneratorRuntime.wrap(function _callee2$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:width=endCol-startCol+1;height=endRow-startRow+1;orientation=HORIZONTAL;if(width<height){orientation=HORIZONTAL;}else if(height<width){orientation=VERTICAL;}else{orientation=getRandomNum(HORIZONTAL,VERTICAL);}if(!(orientation===HORIZONTAL)){_context5.next=30;break;}if(!(height<3||startRow%2===1&&height===3)){_context5.next=7;break;}return _context5.abrupt(\"return\");case 7:sCol=startCol;if(startCol%2===1){sCol+=1;}sRow=startRow+2;if(startRow%2===0){sRow=startRow+1;}skip=Math.floor(getRandomNum(sCol,endCol)/2)*2;randRow=getRandomNum(sRow,endRow-2);randRow=Math.floor(randRow/2)*2+1;_loop2=/*#__PURE__*/_regeneratorRuntime.mark(function _loop2(i){var currCord,nodeStateFunc,state;return _regeneratorRuntime.wrap(function _loop2$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(!(i===skip)){_context3.next=2;break;}return _context3.abrupt(\"return\",\"continue\");case 2:currCord=\"\".concat(randRow,\":\").concat(i);nodeStateFunc=gridState[currCord][1];state=[nodeTypeEnum.wall,nodeTypeEnum.none];if(currCord===startCord){state=[nodeTypeEnum.start,nodeTypeEnum.wall,nodeTypeEnum.none];}else if(currCord===targetCord){state=[nodeTypeEnum.target,nodeTypeEnum.wall,nodeTypeEnum.none];}nodeStateFunc(function(prevState){return state;});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[state,prevState[currCord][1]]));});_context3.next=10;return sleep(timeout);case 10:case\"end\":return _context3.stop();}}},_loop2);});i=startCol;case 16:if(!(i<=endCol)){_context5.next=24;break;}return _context5.delegateYield(_loop2(i),\"t0\",18);case 18:_ret=_context5.t0;if(!(_ret===\"continue\")){_context5.next=21;break;}return _context5.abrupt(\"continue\",21);case 21:i++;_context5.next=16;break;case 24:_context5.next=26;return divide(startCord,targetCord,gridState,setGridState,startRow,randRow-1,startCol,endCol,timeout,rows,cols);case 26:_context5.next=28;return divide(startCord,targetCord,gridState,setGridState,randRow+1,endRow,startCol,endCol,timeout,rows,cols);case 28:_context5.next=54;break;case 30:if(!(orientation===VERTICAL)){_context5.next=54;break;}if(!(width<3||startCol%2===1&&width===3)){_context5.next=33;break;}return _context5.abrupt(\"return\");case 33:_sRow=startRow;if(startRow%2===1){_sRow+=1;}_sCol=startCol+2;if(startCol%2===0){_sCol=startCol+1;}_skip=Math.floor(getRandomNum(_sRow,endRow)/2)*2;randCol=getRandomNum(_sCol,endCol-2);randCol=Math.floor(randCol/2)*2+1;_loop3=/*#__PURE__*/_regeneratorRuntime.mark(function _loop3(_i){var currCord,nodeStateFunc,state;return _regeneratorRuntime.wrap(function _loop3$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!(_i===_skip)){_context4.next=2;break;}return _context4.abrupt(\"return\",\"continue\");case 2:currCord=\"\".concat(_i,\":\").concat(randCol);nodeStateFunc=gridState[currCord][1];state=[nodeTypeEnum.wall,nodeTypeEnum.none];if(currCord===startCord){state=[nodeTypeEnum.start,nodeTypeEnum.wall,nodeTypeEnum.none];}else if(currCord===targetCord){state=[nodeTypeEnum.target,nodeTypeEnum.wall,nodeTypeEnum.none];}nodeStateFunc(function(prevState){return state;});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[state,prevState[currCord][1]]));});_context4.next=10;return sleep(timeout);case 10:case\"end\":return _context4.stop();}}},_loop3);});_i=startRow;case 42:if(!(_i<=endRow)){_context5.next=50;break;}return _context5.delegateYield(_loop3(_i),\"t1\",44);case 44:_ret2=_context5.t1;if(!(_ret2===\"continue\")){_context5.next=47;break;}return _context5.abrupt(\"continue\",47);case 47:_i++;_context5.next=42;break;case 50:_context5.next=52;return divide(startCord,targetCord,gridState,setGridState,startRow,endRow,startCol,randCol-1,timeout,rows,cols);case 52:_context5.next=54;return divide(startCord,targetCord,gridState,setGridState,startRow,endRow,randCol+1,endCol,timeout,rows,cols);case 54:case\"end\":return _context5.stop();}}},_callee2);}));return function divide(_x8,_x9,_x10,_x11,_x12,_x13,_x14,_x15,_x16,_x17,_x18){return _ref2.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","x","currCord","y","nodeStateFunc","state","wall","none","start","target","prevState","divide","startRow","endRow","startCol","endCol","width","height","orientation","sCol","sRow","skip","Math","floor","randRow","i","randCol"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (var x = 0; x < rows; x++) {\n        for (var y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            if (x === 0 || x === (rows - 1) || y === 0 || y === (cols - 1)) {\n                await sleep(timeout);\n                let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n                if (currCord === startCord) {\n                    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                else if (currCord === targetCord) {\n                    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                nodeStateFunc(prevState => state);\n                setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            }\n        }\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};"]},"metadata":{},"sourceType":"module"}