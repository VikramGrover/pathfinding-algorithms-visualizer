{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import{getNeighbourNodes,createPath,findMinPriorityNode}from'../../utils/helper.js';import{nodeWeight,nodeTypeEnum}from'../../utils/constants.js';export var dijkstras=function dijkstras(startCord,targetCord,gridState,rows,cols,timeout){var totalCosts={};var prevNodes={};var minPQ={};var visited={};totalCosts[startCord]=0;minPQ[startCord]=0;for(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){totalCosts[cord]=Infinity;}}}while(Object.keys(minPQ).length>0){var minKey=findMinPriorityNode(minPQ);delete minPQ[minKey];visited[minKey]=1;if(minKey!==startCord&&minKey!==targetCord){(function(){var nodeStateFunc=gridState[minKey][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visited].concat(_toConsumableArray(prevState.slice(1)));});},timeout);})();}else if(minKey===targetCord){return createPath(startCord,targetCord,prevNodes);}var neighbours=getNeighbourNodes(minKey,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbour=_step.value;var currPath=totalCosts[minKey]+nodeWeight[gridState[neighbour][0][0]];if(neighbour in visited){continue;}if(neighbour in minPQ&&currPath<totalCosts[neighbour]||!(neighbour in minPQ)){totalCosts[neighbour]=currPath;prevNodes[neighbour]=minKey;minPQ[neighbour]=currPath;if(neighbour!==targetCord){(function(){var nodeStateFunc=gridState[neighbour][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting].concat(_toConsumableArray(prevState));});},timeout);})();}}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","nodeWeight","nodeTypeEnum","dijkstras","startCord","targetCord","gridState","rows","cols","timeout","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","Object","keys","length","minKey","nodeStateFunc","setTimeout","prevState","slice","neighbours","neighbour","currPath","visiting"],"mappings":"0ZAAA,OAASA,iBAAT,CAA4BC,UAA5B,CAAwCC,mBAAxC,KAAmE,uBAAnE,CACA,OAASC,UAAT,CAAqBC,YAArB,KAAyC,0BAAzC,CAEA,MAAO,IAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,SAAxB,CAAmCC,IAAnC,CAAyCC,IAAzC,CAA+CC,OAA/C,CAA2D,CAChF,GAAIC,CAAAA,UAAU,CAAG,EAAjB,CACA,GAAIC,CAAAA,SAAS,CAAG,EAAhB,CACA,GAAIC,CAAAA,KAAK,CAAG,EAAZ,CACA,GAAIC,CAAAA,OAAO,CAAG,EAAd,CAEAH,UAAU,CAACN,SAAD,CAAV,CAAwB,CAAxB,CACAQ,KAAK,CAACR,SAAD,CAAL,CAAmB,CAAnB,CAEA,IAAK,GAAIU,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGP,IAApB,CAA0BO,CAAC,EAA3B,CAA+B,CAC3B,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGP,IAApB,CAA0BO,CAAC,EAA3B,CAA+B,CAC3B,GAAIC,CAAAA,IAAI,WAAMF,CAAN,aAAWC,CAAX,CAAR,CAEA,GAAIC,IAAI,GAAKZ,SAAb,CAAwB,CACpBM,UAAU,CAACM,IAAD,CAAV,CAAmBC,QAAnB,CACH,CACJ,CACJ,CAED,MAAOC,MAAM,CAACC,IAAP,CAAYP,KAAZ,EAAmBQ,MAAnB,CAA4B,CAAnC,CAAsC,CAClC,GAAMC,CAAAA,MAAM,CAAGrB,mBAAmB,CAACY,KAAD,CAAlC,CACA,MAAOA,CAAAA,KAAK,CAACS,MAAD,CAAZ,CACAR,OAAO,CAACQ,MAAD,CAAP,CAAkB,CAAlB,CAEA,GAAIA,MAAM,GAAKjB,SAAX,EAAwBiB,MAAM,GAAKhB,UAAvC,CAAmD,aAC/C,GAAMiB,CAAAA,aAAa,CAAGhB,SAAS,CAACe,MAAD,CAAT,CAAkB,CAAlB,CAAtB,CACAE,UAAU,CAAC,UAAM,CACbD,aAAa,CAAC,SAAAE,SAAS,SAAMtB,YAAY,CAACW,OAAnB,4BAA+BW,SAAS,CAACC,KAAV,CAAgB,CAAhB,CAA/B,IAAV,CAAb,CACH,CAFS,CAEPhB,OAFO,CAAV,CAF+C,KAKlD,CALD,IAMK,IAAIY,MAAM,GAAKhB,UAAf,CAA2B,CAC5B,MAAON,CAAAA,UAAU,CAACK,SAAD,CAAYC,UAAZ,CAAwBM,SAAxB,CAAjB,CACH,CAED,GAAMe,CAAAA,UAAU,CAAG5B,iBAAiB,CAACuB,MAAD,CAASd,IAAT,CAAeC,IAAf,CAAqBF,SAArB,CAApC,CAfkC,yCAgBVoB,UAhBU,YAgBlC,+CAAoC,IAAzBC,CAAAA,SAAyB,aAChC,GAAMC,CAAAA,QAAQ,CAAGlB,UAAU,CAACW,MAAD,CAAV,CAAqBpB,UAAU,CAACK,SAAS,CAACqB,SAAD,CAAT,CAAqB,CAArB,EAAwB,CAAxB,CAAD,CAAhD,CAEA,GAAIA,SAAS,GAAId,CAAAA,OAAjB,CAA0B,CACtB,SACH,CAED,GAAMc,SAAS,GAAIf,CAAAA,KAAd,EAAwBgB,QAAQ,CAAGlB,UAAU,CAACiB,SAAD,CAA9C,EAA8D,EAAEA,SAAS,GAAIf,CAAAA,KAAf,CAAlE,CAAyF,CACrFF,UAAU,CAACiB,SAAD,CAAV,CAAwBC,QAAxB,CACAjB,SAAS,CAACgB,SAAD,CAAT,CAAuBN,MAAvB,CACAT,KAAK,CAACe,SAAD,CAAL,CAAmBC,QAAnB,CACA,GAAID,SAAS,GAAKtB,UAAlB,CAA8B,aAC1B,GAAMiB,CAAAA,aAAa,CAAGhB,SAAS,CAACqB,SAAD,CAAT,CAAqB,CAArB,CAAtB,CACAJ,UAAU,CAAC,UAAM,CACbD,aAAa,CAAC,SAAAE,SAAS,SAAMtB,YAAY,CAAC2B,QAAnB,4BAAgCL,SAAhC,IAAV,CAAb,CACH,CAFS,CAEPf,OAFO,CAAV,CAF0B,KAK7B,CACJ,CACJ,CAlCiC,qDAmCrC,CAED,MAAO,EAAP,CACH,CAzDM","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            const nodeStateFunc = gridState[minKey][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n            }, timeout);\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    setTimeout(() => {\n                        nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                    }, timeout);\n                }\n            }\n        }\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}