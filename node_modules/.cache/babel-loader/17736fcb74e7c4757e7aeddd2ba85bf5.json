{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getNeighbourNodes,createPath,findMinPriorityNode,sleep,manhattanDistanceHeuristic}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var greedyBestFirstSearch=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,rows,cols,timeout){var openSet,H,F,prevNodes,visited,x,y,cord,currNode,nodeStateFunc,neighbours,_iterator,_step,neighbour,_nodeStateFunc;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:openSet=_defineProperty({},startCord,0);H=_defineProperty({},startCord,0);// H(n) => tells us the estimated distance from node n to target node\nF=_defineProperty({},startCord,0);// F(n) = H(n)\nprevNodes={};visited={};// intialize all the scores to infinity for all node !== start node\nfor(x=0;x<rows;x++){for(y=0;y<cols;y++){cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){F[cord]=H[cord]=Infinity;}}}case 6:if(!(Object.keys(openSet).length>0)){_context.next=23;break;}currNode=findMinPriorityNode(openSet);delete openSet[currNode];if(!(currNode!==startCord&&currNode!==targetCord)){_context.next=14;break;}nodeStateFunc=gridState[currNode][1];nodeStateFunc(function(prevState){return[nodeTypeEnum.visited].concat(_toConsumableArray(prevState.slice(1)));});_context.next=16;break;case 14:if(!(currNode===targetCord)){_context.next=16;break;}return _context.abrupt(\"return\",createPath(startCord,targetCord,prevNodes));case 16:neighbours=getNeighbourNodes(currNode,rows,cols,gridState);_iterator=_createForOfIteratorHelper(neighbours);try{for(_iterator.s();!(_step=_iterator.n()).done;){neighbour=_step.value;if(!(neighbour in visited)){visited[neighbour]=1;if(neighbour!==startCord&&neighbour!==targetCord){_nodeStateFunc=gridState[neighbour][1];_nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting].concat(_toConsumableArray(prevState));});}H[neighbour]=manhattanDistanceHeuristic(neighbour,targetCord);F[neighbour]=H[neighbour];prevNodes[neighbour]=currNode;openSet[neighbour]=F[neighbour];}}}catch(err){_iterator.e(err);}finally{_iterator.f();}_context.next=21;return sleep(timeout);case 21:_context.next=6;break;case 23:return _context.abrupt(\"return\",[]);case 24:case\"end\":return _context.stop();}}},_callee);}));return function greedyBestFirstSearch(_x,_x2,_x3,_x4,_x5,_x6){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/greedyBestFirstSearch.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","sleep","manhattanDistanceHeuristic","nodeTypeEnum","greedyBestFirstSearch","startCord","targetCord","gridState","rows","cols","timeout","openSet","H","F","prevNodes","visited","x","y","cord","Infinity","Object","keys","length","currNode","nodeStateFunc","prevState","slice","neighbours","neighbour","visiting"],"mappings":"g9BAAA,OAASA,iBAAT,CAA4BC,UAA5B,CAAwCC,mBAAxC,CAA6DC,KAA7D,CAAoEC,0BAApE,KAAsG,uBAAtG,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,qBAAqB,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,IAAzC,CAA+CC,IAA/C,CAAqDC,OAArD,wOAC7BC,OAD6B,oBAChBN,SADgB,CACJ,CADI,EAE7BO,CAF6B,oBAEtBP,SAFsB,CAEV,CAFU,EAEL;AACxBQ,CAH6B,oBAGtBR,SAHsB,CAGV,CAHU,EAGL;AACxBS,SAJ6B,CAIjB,EAJiB,CAK7BC,OAL6B,CAKnB,EALmB,CAOjC;AACA,IAASC,CAAT,CAAa,CAAb,CAAgBA,CAAC,CAAGR,IAApB,CAA0BQ,CAAC,EAA3B,CAA+B,CAC3B,IAASC,CAAT,CAAa,CAAb,CAAgBA,CAAC,CAAGR,IAApB,CAA0BQ,CAAC,EAA3B,CAA+B,CACvBC,IADuB,WACbF,CADa,aACRC,CADQ,EAG3B,GAAIC,IAAI,GAAKb,SAAb,CAAwB,CACpBQ,CAAC,CAACK,IAAD,CAAD,CAAUN,CAAC,CAACM,IAAD,CAAD,CAAUC,QAApB,CACH,CACJ,CACJ,CAhBgC,YAkB1BC,MAAM,CAACC,IAAP,CAAYV,OAAZ,EAAqBW,MAArB,CAA8B,CAlBJ,2BAmBvBC,QAnBuB,CAmBZvB,mBAAmB,CAACW,OAAD,CAnBP,CAoB7B,MAAOA,CAAAA,OAAO,CAACY,QAAD,CAAd,CApB6B,KAsBzBA,QAAQ,GAAKlB,SAAb,EAA0BkB,QAAQ,GAAKjB,UAtBd,2BAuBnBkB,aAvBmB,CAuBHjB,SAAS,CAACgB,QAAD,CAAT,CAAoB,CAApB,CAvBG,CAwBzBC,aAAa,CAAC,SAAAC,SAAS,SAAMtB,YAAY,CAACY,OAAnB,4BAA+BU,SAAS,CAACC,KAAV,CAAgB,CAAhB,CAA/B,IAAV,CAAb,CAxByB,oCA0BpBH,QAAQ,GAAKjB,UA1BO,2DA4BlBP,UAAU,CAACM,SAAD,CAAYC,UAAZ,CAAwBQ,SAAxB,CA5BQ,UA+BvBa,UA/BuB,CA+BV7B,iBAAiB,CAACyB,QAAD,CAAWf,IAAX,CAAiBC,IAAjB,CAAuBF,SAAvB,CA/BP,sCAgCLoB,UAhCK,MAgC7B,+CAAoC,CAAzBC,SAAyB,aAChC,GAAI,EAAEA,SAAS,GAAIb,CAAAA,OAAf,CAAJ,CAA6B,CACzBA,OAAO,CAACa,SAAD,CAAP,CAAqB,CAArB,CAEA,GAAIA,SAAS,GAAKvB,SAAd,EAA2BuB,SAAS,GAAKtB,UAA7C,CAAyD,CAC/CkB,cAD+C,CAC/BjB,SAAS,CAACqB,SAAD,CAAT,CAAqB,CAArB,CAD+B,CAErDJ,cAAa,CAAC,SAAAC,SAAS,SAAMtB,YAAY,CAAC0B,QAAnB,4BAAgCJ,SAAhC,IAAV,CAAb,CACH,CAEDb,CAAC,CAACgB,SAAD,CAAD,CAAe1B,0BAA0B,CAAC0B,SAAD,CAAYtB,UAAZ,CAAzC,CACAO,CAAC,CAACe,SAAD,CAAD,CAAehB,CAAC,CAACgB,SAAD,CAAhB,CACAd,SAAS,CAACc,SAAD,CAAT,CAAuBL,QAAvB,CACAZ,OAAO,CAACiB,SAAD,CAAP,CAAqBf,CAAC,CAACe,SAAD,CAAtB,CACH,CACJ,CA9C4B,4EAgDvB3B,CAAAA,KAAK,CAACS,OAAD,CAhDkB,uEAmD1B,EAnD0B,yDAAH,kBAArBN,CAAAA,qBAAqB,gEAA3B","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode, sleep, manhattanDistanceHeuristic } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const greedyBestFirstSearch = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = H(n)\n    let prevNodes = {};\n    let visited = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            if (!(neighbour in visited)) {\n                visited[neighbour] = 1;\n\n                if (neighbour !== startCord && neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n\n                H[neighbour] = manhattanDistanceHeuristic(neighbour, targetCord);\n                F[neighbour] = H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n"]},"metadata":{},"sourceType":"module"}