{"ast":null,"code":"// pathfinding algorithm constants\nexport const DIJKSTRAS = \"Dijkstra's\";\nexport const ASTAR = \"A*\";\nexport const BFS = \"BFS\";\nexport const DFS = \"DFS\";\nexport const pathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS];\nexport const unweightedPathAlgos = [DFS, BFS];\nexport const optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS]; // terrain algorithm constants\n\nexport const ALGO1 = \"ALGO1\";\nexport const ALGO2 = \"ALGO2\";\nconst nodeTypeEnum = {\n  'path': 0,\n  'visited': 1,\n  'visiting': 2,\n  'none': 3,\n  'target': 4,\n  'start': 5,\n  'remObstacle': 6,\n  'wall': 7,\n  'weighted100': 8,\n  'weighted80': 9,\n  'weighted60': 10,\n  'weighted40': 11,\n  'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\nexport { nodeTypeEnum };\nconst nodeColorClass = {\n  [nodeTypeEnum.none]: 'empty',\n  [nodeTypeEnum.target]: 'target',\n  [nodeTypeEnum.wall]: 'wall',\n  [nodeTypeEnum.visiting]: 'visiting',\n  [nodeTypeEnum.start]: 'start',\n  [nodeTypeEnum.visited]: 'visited',\n  [nodeTypeEnum.path]: 'path',\n  [nodeTypeEnum.weighted100]: 'weighted-100',\n  [nodeTypeEnum.weighted80]: 'weighted-80',\n  [nodeTypeEnum.weighted60]: 'weighted-60',\n  [nodeTypeEnum.weighted40]: 'weighted-40',\n  [nodeTypeEnum.weighted20]: 'weighted-20'\n};\nObject.freeze(nodeColorClass);\nexport { nodeColorClass };\nexport const nodeWeight = {\n  [nodeTypeEnum.none]: 1,\n  [nodeTypeEnum.target]: 1,\n  [nodeTypeEnum.wall]: Infinity,\n  [nodeTypeEnum.start]: 1,\n  [nodeTypeEnum.weighted100]: 100,\n  [nodeTypeEnum.weighted80]: 80,\n  [nodeTypeEnum.weighted60]: 60,\n  [nodeTypeEnum.weighted40]: 40,\n  [nodeTypeEnum.weighted20]: 20\n};\nObject.freeze(nodeWeight);\nconst terrainAlgos = [\"Algo 1\", \"Algo 2\"];\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n  'Wall (∞)': 'wall',\n  'Weighted (100)': 'weighted-100',\n  'Weighted (80)': 'weighted-80',\n  'Weighted (60)': 'weighted-60',\n  'Weighted (40)': 'weighted-40',\n  'Weighted (20)': 'weighted-20'\n};\nexport const getNodeWeight = key => {\n  return nodeWeight[key];\n};\nexport const getPathAlgos = () => {\n  return pathAlgos;\n};\nexport const getTerrainAlgos = () => {\n  return terrainAlgos;\n};\nexport const getObstacleTypes = () => {\n  return obstacleTypes;\n};\nexport const getObstacleEnum = key => {\n  return obsEnum[key];\n};\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};\nexport const createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\nexport const findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\nexport const isAlgoUnweighted = algo => {\n  return unweightedPathAlgos.includes(algo);\n};\nexport const isAlgoOptimal = algo => {\n  return optimalPathAlgos.includes(algo);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/util.js"],"names":["DIJKSTRAS","ASTAR","BFS","DFS","pathAlgos","unweightedPathAlgos","optimalPathAlgos","ALGO1","ALGO2","nodeTypeEnum","Object","freeze","nodeColorClass","none","target","wall","visiting","start","visited","path","weighted100","weighted80","weighted60","weighted40","weighted20","nodeWeight","Infinity","terrainAlgos","obstacleTypes","obsEnum","getNodeWeight","key","getPathAlgos","getTerrainAlgos","getObstacleTypes","getObstacleEnum","getNeighbourNodes","node","rows","cols","gridState","row","parseInt","split","col","res","push","createPath","startCord","targetCord","prevNodes","cord","findMinPriorityNode","minPQ","minPriority","Math","min","values","isAlgoUnweighted","algo","includes","isAlgoOptimal"],"mappings":"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","sourcesContent":["// pathfinding algorithm constants\nexport const DIJKSTRAS = \"Dijkstra's\";\nexport const ASTAR = \"A*\";\nexport const BFS = \"BFS\";\nexport const DFS = \"DFS\";\n\nexport const pathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS];\nexport const unweightedPathAlgos = [DFS, BFS];\nexport const optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\n\n// terrain algorithm constants\nexport const ALGO1 = \"ALGO1\";\nexport const ALGO2 = \"ALGO2\";\n\nconst nodeTypeEnum = {\n    'path': 0,\n    'visited': 1,\n    'visiting': 2,\n    'none': 3,\n    'target': 4,\n    'start': 5,\n    'remObstacle': 6,\n    'wall': 7,\n    'weighted100': 8,\n    'weighted80': 9,\n    'weighted60': 10,\n    'weighted40': 11,\n    'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\n\nexport { nodeTypeEnum };\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'empty',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.wall]: 'wall',\n    [nodeTypeEnum.visiting]: 'visiting',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path',\n    [nodeTypeEnum.weighted100]: 'weighted-100',\n    [nodeTypeEnum.weighted80]: 'weighted-80',\n    [nodeTypeEnum.weighted60]: 'weighted-60',\n    [nodeTypeEnum.weighted40]: 'weighted-40',\n    [nodeTypeEnum.weighted20]: 'weighted-20'\n}\nObject.freeze(nodeColorClass);\n\nexport { nodeColorClass };\n\nexport const nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.wall]: Infinity,\n    [nodeTypeEnum.start]: 1,\n    [nodeTypeEnum.weighted100]: 100,\n    [nodeTypeEnum.weighted80]: 80,\n    [nodeTypeEnum.weighted60]: 60,\n    [nodeTypeEnum.weighted40]: 40,\n    [nodeTypeEnum.weighted20]: 20\n}\nObject.freeze(nodeWeight);\n\nconst terrainAlgos = [\"Algo 1\", \"Algo 2\"];\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n    'Wall (∞)': 'wall',\n    'Weighted (100)': 'weighted-100',\n    'Weighted (80)': 'weighted-80',\n    'Weighted (60)': 'weighted-60',\n    'Weighted (40)': 'weighted-40',\n    'Weighted (20)': 'weighted-20'\n}\n\nexport const getNodeWeight = (key) => {\n    return nodeWeight[key];\n};\n\nexport const getPathAlgos = () => {\n    return pathAlgos;\n};\n\nexport const getTerrainAlgos = () => {\n    return terrainAlgos;\n};\n\nexport const getObstacleTypes = () => {\n    return obstacleTypes;\n}\n\nexport const getObstacleEnum = (key) => {\n    return obsEnum[key];\n};\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n"]},"metadata":{},"sourceType":"module"}