{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getNeighbourNodes,sleep}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var dfs=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,rows,cols,timeout){var stack,visited,currCord,nodeStateFunc,_nodeStateFunc,neighbours,unvisitedNeighbourFound,_iterator,_step,neighbour;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:stack=[startCord];visited=_defineProperty({},startCord,1);case 2:if(!(stack.length>0)){_context.next=37;break;}currCord=stack[0];if(currCord!==targetCord&&currCord!==startCord){nodeStateFunc=gridState[currCord][1];nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting,nodeTypeEnum.none];});}if(!(currCord===targetCord)){_context.next=9;break;}stack.pop();stack.shift();return _context.abrupt(\"return\",stack);case 9:if(currCord!==startCord){visited[currCord]=1;_nodeStateFunc=gridState[currCord][1];_nodeStateFunc(function(prevState){return[nodeTypeEnum.visited,nodeTypeEnum.none];});}neighbours=getNeighbourNodes(currCord,rows,cols,gridState);unvisitedNeighbourFound=false;_iterator=_createForOfIteratorHelper(neighbours);_context.prev=13;_iterator.s();case 15:if((_step=_iterator.n()).done){_context.next=24;break;}neighbour=_step.value;if(!(neighbour in visited)){_context.next=19;break;}return _context.abrupt(\"continue\",22);case 19:stack.unshift(neighbour);unvisitedNeighbourFound=true;return _context.abrupt(\"break\",24);case 22:_context.next=15;break;case 24:_context.next=29;break;case 26:_context.prev=26;_context.t0=_context[\"catch\"](13);_iterator.e(_context.t0);case 29:_context.prev=29;_iterator.f();return _context.finish(29);case 32:if(!unvisitedNeighbourFound){stack.splice(0,1);}_context.next=35;return sleep(timeout);case 35:_context.next=2;break;case 37:return _context.abrupt(\"return\",[]);case 38:case\"end\":return _context.stop();}}},_callee,null,[[13,26,29,32]]);}));return function dfs(_x,_x2,_x3,_x4,_x5,_x6){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNeighbourNodes","sleep","nodeTypeEnum","dfs","startCord","targetCord","gridState","rows","cols","timeout","stack","visited","length","currCord","nodeStateFunc","prevState","visiting","none","pop","shift","neighbours","unvisitedNeighbourFound","neighbour","unshift","splice"],"mappings":"2wBAAA,OAASA,iBAAT,CAA4BC,KAA5B,KAAyC,uBAAzC,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,GAAG,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,IAAzC,CAA+CC,IAA/C,CAAqDC,OAArD,uOACTC,KADS,CACD,CAACN,SAAD,CADC,CAETO,OAFS,oBAEIP,SAFJ,CAEgB,CAFhB,cAIRM,KAAK,CAACE,MAAN,CAAe,CAJP,2BAKLC,QALK,CAKMH,KAAK,CAAC,CAAD,CALX,CAMX,GAAIG,QAAQ,GAAKR,UAAb,EAA2BQ,QAAQ,GAAKT,SAA5C,CAAuD,CAC7CU,aAD6C,CAC7BR,SAAS,CAACO,QAAD,CAAT,CAAoB,CAApB,CAD6B,CAEnDC,aAAa,CAAC,SAAAC,SAAS,QAAK,CAACb,YAAY,CAACc,QAAd,CAAwBd,YAAY,CAACe,IAArC,CAAL,EAAV,CAAb,CACH,CATU,KAWPJ,QAAQ,GAAKR,UAXN,0BAYPK,KAAK,CAACQ,GAAN,GACAR,KAAK,CAACS,KAAN,GAbO,gCAcAT,KAdA,SAiBX,GAAIG,QAAQ,GAAKT,SAAjB,CAA4B,CACxBO,OAAO,CAACE,QAAD,CAAP,CAAoB,CAApB,CACMC,cAFkB,CAEFR,SAAS,CAACO,QAAD,CAAT,CAAoB,CAApB,CAFE,CAGxBC,cAAa,CAAC,SAAAC,SAAS,QAAK,CAACb,YAAY,CAACS,OAAd,CAAuBT,YAAY,CAACe,IAApC,CAAL,EAAV,CAAb,CACH,CAEKG,UAvBK,CAuBQpB,iBAAiB,CAACa,QAAD,CAAWN,IAAX,CAAiBC,IAAjB,CAAuBF,SAAvB,CAvBzB,CAwBPe,uBAxBO,CAwBmB,KAxBnB,sCAyBaD,UAzBb,gGAyBAE,SAzBA,kBA0BHA,SAAS,GAAIX,CAAAA,OA1BV,yEA8BPD,KAAK,CAACa,OAAN,CAAcD,SAAd,EACAD,uBAAuB,CAAG,IAA1B,CA/BO,+PAmCX,GAAI,CAACA,uBAAL,CAA8B,CAC1BX,KAAK,CAACc,MAAN,CAAa,CAAb,CAAgB,CAAhB,EACH,CArCU,uBAuCLvB,CAAAA,KAAK,CAACQ,OAAD,CAvCA,uEA0CR,EA1CQ,8EAAH,kBAAHN,CAAAA,GAAG,gEAAT","sourcesContent":["import { getNeighbourNodes, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            visited[currCord] = 1;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}