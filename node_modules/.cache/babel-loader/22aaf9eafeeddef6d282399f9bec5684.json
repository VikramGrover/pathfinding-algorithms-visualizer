{"ast":null,"code":"import { getNeighbourNodes, sleep } from '../../utils/helper.js';\nimport { nodeTypeEnum } from '../../utils/constants.js';\nexport const dfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n  const stack = [startCord];\n  const visited = {\n    [startCord]: 1\n  };\n\n  while (stack.length > 0) {\n    const currCord = stack[0];\n\n    if (currCord !== targetCord && currCord !== startCord) {\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.visiting, nodeTypeEnum.none]);\n    }\n\n    if (currCord === targetCord) {\n      stack.pop();\n      stack.shift();\n      return stack;\n    }\n\n    if (currCord !== startCord) {\n      visited[currCord] = 1;\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.visited, nodeTypeEnum.none]);\n    }\n\n    const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n    let unvisitedNeighbourFound = false;\n\n    for (const neighbour of neighbours) {\n      if (neighbour in visited) {\n        continue;\n      }\n\n      stack.unshift(neighbour);\n      unvisitedNeighbourFound = true;\n      break;\n    }\n\n    if (!unvisitedNeighbourFound) {\n      stack.splice(0, 1);\n    }\n\n    await sleep(timeout);\n  }\n\n  return [];\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNeighbourNodes","sleep","nodeTypeEnum","dfs","startCord","targetCord","gridState","rows","cols","timeout","stack","visited","length","currCord","nodeStateFunc","prevState","visiting","none","pop","shift","neighbours","unvisitedNeighbourFound","neighbour","unshift","splice"],"mappings":"AAAA,SAASA,iBAAT,EAA4BC,KAA5B,QAAyC,uBAAzC;AACA,SAASC,YAAT,QAA6B,0BAA7B;AAEA,OAAO,MAAMC,GAAG,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,IAAzC,EAA+CC,IAA/C,EAAqDC,OAArD,KAAiE;AAChF,QAAMC,KAAK,GAAG,CAACN,SAAD,CAAd;AACA,QAAMO,OAAO,GAAG;AAAE,KAACP,SAAD,GAAa;AAAf,GAAhB;;AAEA,SAAOM,KAAK,CAACE,MAAN,GAAe,CAAtB,EAAyB;AACrB,UAAMC,QAAQ,GAAGH,KAAK,CAAC,CAAD,CAAtB;;AACA,QAAIG,QAAQ,KAAKR,UAAb,IAA2BQ,QAAQ,KAAKT,SAA5C,EAAuD;AACnD,YAAMU,aAAa,GAAGR,SAAS,CAACO,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACAC,MAAAA,aAAa,CAACC,SAAS,IAAK,CAACb,YAAY,CAACc,QAAd,EAAwBd,YAAY,CAACe,IAArC,CAAf,CAAb;AACH;;AAED,QAAIJ,QAAQ,KAAKR,UAAjB,EAA6B;AACzBK,MAAAA,KAAK,CAACQ,GAAN;AACAR,MAAAA,KAAK,CAACS,KAAN;AACA,aAAOT,KAAP;AACH;;AAED,QAAIG,QAAQ,KAAKT,SAAjB,EAA4B;AACxBO,MAAAA,OAAO,CAACE,QAAD,CAAP,GAAoB,CAApB;AACA,YAAMC,aAAa,GAAGR,SAAS,CAACO,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACAC,MAAAA,aAAa,CAACC,SAAS,IAAK,CAACb,YAAY,CAACS,OAAd,EAAuBT,YAAY,CAACe,IAApC,CAAf,CAAb;AACH;;AAED,UAAMG,UAAU,GAAGpB,iBAAiB,CAACa,QAAD,EAAWN,IAAX,EAAiBC,IAAjB,EAAuBF,SAAvB,CAApC;AACA,QAAIe,uBAAuB,GAAG,KAA9B;;AACA,SAAK,MAAMC,SAAX,IAAwBF,UAAxB,EAAoC;AAChC,UAAIE,SAAS,IAAIX,OAAjB,EAA0B;AACtB;AACH;;AAEDD,MAAAA,KAAK,CAACa,OAAN,CAAcD,SAAd;AACAD,MAAAA,uBAAuB,GAAG,IAA1B;AACA;AACH;;AAED,QAAI,CAACA,uBAAL,EAA8B;AAC1BX,MAAAA,KAAK,CAACc,MAAN,CAAa,CAAb,EAAgB,CAAhB;AACH;;AAED,UAAMvB,KAAK,CAACQ,OAAD,CAAX;AACH;;AAED,SAAO,EAAP;AACH,CA3CM","sourcesContent":["import { getNeighbourNodes, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            visited[currCord] = 1;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}