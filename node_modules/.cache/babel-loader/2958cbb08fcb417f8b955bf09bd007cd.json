{"ast":null,"code":"import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import React from'react';import{nodeColorClass,nodeTypeEnum}from'../utils/constants.js';import{jsx as _jsx}from\"react/jsx-runtime\";var Node=/*#__PURE__*/React.memo(function(_ref){var nodeId=_ref.nodeId,size=_ref.size,nodeState=_ref.nodeState,setGridState=_ref.setGridState,draggingSelection=_ref.draggingSelection,setDraggingSelection=_ref.setDraggingSelection,setStartCord=_ref.setStartCord,setTargetCord=_ref.setTargetCord,runningAlgo=_ref.runningAlgo,selectedObstacle=_ref.selectedObstacle;var nodeDim={width:size,height:size};var mouseDowned=function mouseDowned(){if(nodeState[0]<=nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum[selectedObstacle]);setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none]));});return;}else if(nodeState[0]>=nodeTypeEnum.wall){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,prevState[nodeId].slice(1)));});setDraggingSelection(nodeTypeEnum.remObstacle);return;}setDraggingSelection(nodeState[0]);};var mouseEntered=function mouseEntered(){if(draggingSelection===nodeTypeEnum.remObstacle&&nodeState[0]>=nodeTypeEnum.wall){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,prevState[nodeId].slice(1)));});}else if(draggingSelection===nodeTypeEnum[selectedObstacle]&&nodeState[0]<=nodeTypeEnum.none){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none]));});}else if(draggingSelection===nodeTypeEnum.start){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[draggingSelection].concat(_toConsumableArray(prevState[nodeId]))));});setStartCord(nodeId);}else if(draggingSelection===nodeTypeEnum.target){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[draggingSelection].concat(_toConsumableArray(prevState[nodeId]))));});setTargetCord(nodeId);}};var mouseLeft=function mouseLeft(){if(draggingSelection===nodeTypeEnum.start||draggingSelection===nodeTypeEnum.target){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,prevState[nodeId].slice(1)));});return;}};var mouseUped=function mouseUped(){if(draggingSelection!==nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum.none);}};return/*#__PURE__*/_jsx(\"div\",{style:_objectSpread({},nodeDim),className:\"node \".concat(nodeColorClass[nodeState[0]]),onMouseDown:runningAlgo?null:mouseDowned,onMouseUp:runningAlgo?null:mouseUped,onMouseEnter:runningAlgo?null:mouseEntered,onMouseLeave:runningAlgo?null:mouseLeft});});export default Node;","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/components/Node.js"],"names":["React","nodeColorClass","nodeTypeEnum","Node","memo","nodeId","size","nodeState","setGridState","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","selectedObstacle","nodeDim","width","height","mouseDowned","none","prevState","wall","slice","remObstacle","mouseEntered","start","target","mouseLeft","mouseUped"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { nodeColorClass, nodeTypeEnum } from '../utils/constants.js'\n\nconst Node = React.memo(({ nodeId, size, nodeState, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo, selectedObstacle }) => {\n    const nodeDim = {\n        width: size,\n        height: size\n    };\n\n    const mouseDowned = () => {\n        if (nodeState[0] <= nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum[selectedObstacle]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none] }));\n            return;\n        }\n        else if (nodeState[0] >= nodeTypeEnum.wall) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n            setDraggingSelection(nodeTypeEnum.remObstacle);\n            return;\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === nodeTypeEnum.remObstacle && nodeState[0] >= nodeTypeEnum.wall) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n        }\n        else if (draggingSelection === nodeTypeEnum[selectedObstacle] && nodeState[0] <= nodeTypeEnum.none) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.start) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [draggingSelection, ...prevState[nodeId]] }));\n            setStartCord(nodeId);\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [draggingSelection, ...prevState[nodeId]] }));\n            setTargetCord(nodeId);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: prevState[nodeId].slice(1) }));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection !== nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum.none);\n        }\n    };\n\n    return (\n        <div style={{ ...nodeDim }} className={`node ${nodeColorClass[nodeState[0]]}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n});\n\nexport default Node\n"]},"metadata":{},"sourceType":"module"}