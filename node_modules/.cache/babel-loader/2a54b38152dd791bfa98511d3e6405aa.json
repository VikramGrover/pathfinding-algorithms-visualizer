{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{nodeTypeEnum}from\"../../utils/constants\";import{sleep}from\"../../utils/helper\";function Grad(x,y,z){this.x=x;this.y=y;this.z=z;}Grad.prototype.dot2=function(x,y){return this.x*x+this.y*y;};Grad.prototype.dot3=function(x,y,z){return this.x*x+this.y*y+this.z*z;};var grad3=[new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];var p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];// To remove the need for index wrapping, double the permutation table length\nvar perm=new Array(512);var gradP=new Array(512);// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nvar seed=function seed(_seed){if(_seed>0&&_seed<1){// Scale the seed out\n_seed*=65536;}_seed=Math.floor(_seed);if(_seed<256){_seed|=_seed<<8;}for(var i=0;i<256;i++){var v;if(i&1){v=p[i]^_seed&255;}else{v=p[i]^_seed>>8&255;}perm[i]=perm[i+256]=v;gradP[i]=gradP[i+256]=grad3[v%12];}};// Skewing and unskewing factors for 2, 3, and 4 dimensions\nvar F2=0.5*(Math.sqrt(3)-1);var G2=(3-Math.sqrt(3))/6;// 2D simplex noise\nvar simplex2=function simplex2(xin,yin){var n0,n1,n2;// Noise contributions from the three corners\n// Skew the input space to determine which simplex cell we're in\nvar s=(xin+yin)*F2;// Hairy factor for 2D\nvar i=Math.floor(xin+s);var j=Math.floor(yin+s);var t=(i+j)*G2;var x0=xin-i+t;// The x,y distances from the cell origin, unskewed.\nvar y0=yin-j+t;// For the 2D case, the simplex shape is an equilateral triangle.\n// Determine which simplex we are in.\nvar i1,j1;// Offsets for second (middle) corner of simplex in (i,j) coords\nif(x0>y0){// lower triangle, XY order: (0,0)->(1,0)->(1,1)\ni1=1;j1=0;}else{// upper triangle, YX order: (0,0)->(0,1)->(1,1)\ni1=0;j1=1;}// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n// c = (3-sqrt(3))/6\nvar x1=x0-i1+G2;// Offsets for middle corner in (x,y) unskewed coords\nvar y1=y0-j1+G2;var x2=x0-1+2*G2;// Offsets for last corner in (x,y) unskewed coords\nvar y2=y0-1+2*G2;// Work out the hashed gradient indices of the three simplex corners\ni&=255;j&=255;var gi0=gradP[i+perm[j]];var gi1=gradP[i+i1+perm[j+j1]];var gi2=gradP[i+1+perm[j+1]];// Calculate the contribution from the three corners\nvar t0=0.5-x0*x0-y0*y0;if(t0<0){n0=0;}else{t0*=t0;n0=t0*t0*gi0.dot2(x0,y0);// (x,y) of grad3 used for 2D gradient\n}var t1=0.5-x1*x1-y1*y1;if(t1<0){n1=0;}else{t1*=t1;n1=t1*t1*gi1.dot2(x1,y1);}var t2=0.5-x2*x2-y2*y2;if(t2<0){n2=0;}else{t2*=t2;n2=t2*t2*gi2.dot2(x2,y2);}// Add contributions from each corner to get the final noise value.\n// The result is scaled to return values in the interval [-1,1].\nreturn 70*(n0+n1+n2);};var SCALE=12;export var perlinNoise=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var gridMap,x,_loop,y;return _regeneratorRuntime.wrap(function _callee$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:seed(Math.random());gridMap={};x=0;case 3:if(!(x<cols)){_context2.next=14;break;}_loop=/*#__PURE__*/_regeneratorRuntime.mark(function _loop(y){var currCord,nodeStateFunc,value,state;return _regeneratorRuntime.wrap(function _loop$(_context){while(1){switch(_context.prev=_context.next){case 0:// All noise functions return values in the range of -1 to 1.\ncurrCord=\"\".concat(y,\":\").concat(x);nodeStateFunc=gridState[currCord][1];// noise.simplex2 and noise.perlin2 for 2d noise\nvalue=simplex2(x/SCALE,y/SCALE);state=[nodeTypeEnum.none];if(value>=-1&&value<=-0.50){state.unshift(nodeTypeEnum.wall);}else if(value>-0.50&&value<=-0.20){state.unshift(nodeTypeEnum.weighted100);}else if(value>-0.20&&value<=0.10){state.unshift(nodeTypeEnum.weighted80);}else if(value>0.10&&value<=0.40){state.unshift(nodeTypeEnum.weighted60);}else if(value>0.40&&value<=0.70){state.unshift(nodeTypeEnum.weighted40);}else if(value>0.70&&value<=1){state.unshift(nodeTypeEnum.weighted20);}if(currCord===startCord){state.unshift(nodeTypeEnum.start);}else if(currCord===targetCord){state.unshift(nodeTypeEnum.target);}nodeStateFunc(function(prevState){return state;});gridMap[currCord]=[state,nodeStateFunc];_context.next=10;return sleep(timeout);case 10:case\"end\":return _context.stop();}}},_loop);});y=0;case 6:if(!(y<rows)){_context2.next=11;break;}return _context2.delegateYield(_loop(y),\"t0\",8);case 8:y++;_context2.next=6;break;case 11:x++;_context2.next=3;break;case 14:setGridState(function(prevState){return gridMap;});case 15:case\"end\":return _context2.stop();}}},_callee);}));return function perlinNoise(_x,_x2,_x3,_x4,_x5,_x6,_x7){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/perlin.js"],"names":["nodeTypeEnum","sleep","Grad","x","y","z","prototype","dot2","dot3","grad3","p","perm","Array","gradP","seed","Math","floor","i","v","F2","sqrt","G2","simplex2","xin","yin","n0","n1","n2","s","j","t","x0","y0","i1","j1","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","SCALE","perlinNoise","startCord","targetCord","gridState","setGridState","rows","cols","timeout","random","gridMap","currCord","nodeStateFunc","value","state","none","unshift","wall","weighted100","weighted80","weighted60","weighted40","weighted20","start","target","prevState"],"mappings":"uXAAA,OAASA,YAAT,KAA6B,uBAA7B,CACA,OAASC,KAAT,KAAsB,oBAAtB,CAEA,QAASC,CAAAA,IAAT,CAAcC,CAAd,CAAiBC,CAAjB,CAAoBC,CAApB,CAAuB,CACnB,KAAKF,CAAL,CAASA,CAAT,CAAY,KAAKC,CAAL,CAASA,CAAT,CAAY,KAAKC,CAAL,CAASA,CAAT,CAC3B,CAEDH,IAAI,CAACI,SAAL,CAAeC,IAAf,CAAsB,SAAUJ,CAAV,CAAaC,CAAb,CAAgB,CAClC,MAAO,MAAKD,CAAL,CAASA,CAAT,CAAa,KAAKC,CAAL,CAASA,CAA7B,CACH,CAFD,CAIAF,IAAI,CAACI,SAAL,CAAeE,IAAf,CAAsB,SAAUL,CAAV,CAAaC,CAAb,CAAgBC,CAAhB,CAAmB,CACrC,MAAO,MAAKF,CAAL,CAASA,CAAT,CAAa,KAAKC,CAAL,CAASA,CAAtB,CAA0B,KAAKC,CAAL,CAASA,CAA1C,CACH,CAFD,CAIA,GAAMI,CAAAA,KAAK,CAAG,CAAC,GAAIP,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAZ,CAAe,CAAf,CAAD,CAAoB,GAAIA,CAAAA,IAAJ,CAAS,CAAC,CAAV,CAAa,CAAb,CAAgB,CAAhB,CAApB,CAAwC,GAAIA,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAC,CAAb,CAAgB,CAAhB,CAAxC,CAA4D,GAAIA,CAAAA,IAAJ,CAAS,CAAC,CAAV,CAAa,CAAC,CAAd,CAAiB,CAAjB,CAA5D,CACd,GAAIA,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAZ,CAAe,CAAf,CADc,CACK,GAAIA,CAAAA,IAAJ,CAAS,CAAC,CAAV,CAAa,CAAb,CAAgB,CAAhB,CADL,CACyB,GAAIA,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAZ,CAAe,CAAC,CAAhB,CADzB,CAC6C,GAAIA,CAAAA,IAAJ,CAAS,CAAC,CAAV,CAAa,CAAb,CAAgB,CAAC,CAAjB,CAD7C,CAEd,GAAIA,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAZ,CAAe,CAAf,CAFc,CAEK,GAAIA,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAC,CAAb,CAAgB,CAAhB,CAFL,CAEyB,GAAIA,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAZ,CAAe,CAAC,CAAhB,CAFzB,CAE6C,GAAIA,CAAAA,IAAJ,CAAS,CAAT,CAAY,CAAC,CAAb,CAAgB,CAAC,CAAjB,CAF7C,CAAd,CAIA,GAAMQ,CAAAA,CAAC,CAAG,CAAC,GAAD,CAAM,GAAN,CAAW,GAAX,CAAgB,EAAhB,CAAoB,EAApB,CAAwB,EAAxB,CACN,GADM,CACD,EADC,CACG,GADH,CACQ,EADR,CACY,EADZ,CACgB,EADhB,CACoB,GADpB,CACyB,GADzB,CAC8B,CAD9B,CACiC,GADjC,CACsC,GADtC,CAC2C,EAD3C,CAC+C,GAD/C,CACoD,EADpD,CACwD,EADxD,CAC4D,GAD5D,CACiE,CADjE,CACoE,EADpE,CACwE,EADxE,CAC4E,GAD5E,CACiF,EADjF,CACqF,EADrF,CACyF,EADzF,CAEN,GAFM,CAED,CAFC,CAEE,GAFF,CAEO,GAFP,CAEY,GAFZ,CAEiB,GAFjB,CAEsB,EAFtB,CAE0B,CAF1B,CAE6B,EAF7B,CAEiC,GAFjC,CAEsC,EAFtC,CAE0C,EAF1C,CAE8C,GAF9C,CAEmD,GAFnD,CAEwD,GAFxD,CAE6D,GAF7D,CAEkE,EAFlE,CAEsE,EAFtE,CAE0E,EAF1E,CAE8E,EAF9E,CAEkF,GAFlF,CAEuF,EAFvF,CAGN,EAHM,CAGF,GAHE,CAGG,GAHH,CAGQ,EAHR,CAGY,EAHZ,CAGgB,GAHhB,CAGqB,EAHrB,CAGyB,GAHzB,CAG8B,GAH9B,CAGmC,GAHnC,CAGwC,GAHxC,CAG6C,EAH7C,CAGiD,GAHjD,CAGsD,EAHtD,CAG0D,GAH1D,CAG+D,EAH/D,CAGmE,GAHnE,CAGwE,GAHxE,CAG6E,EAH7E,CAGiF,EAHjF,CAGqF,GAHrF,CAIN,EAJM,CAIF,GAJE,CAIG,GAJH,CAIQ,GAJR,CAIa,EAJb,CAIiB,GAJjB,CAIsB,GAJtB,CAI2B,GAJ3B,CAIgC,EAJhC,CAIoC,GAJpC,CAIyC,GAJzC,CAI8C,GAJ9C,CAImD,GAJnD,CAIwD,GAJxD,CAI6D,EAJ7D,CAIiE,EAJjE,CAIqE,EAJrE,CAIyE,EAJzE,CAI6E,GAJ7E,CAIkF,EAJlF,CAIsF,GAJtF,CAKN,GALM,CAKD,GALC,CAKI,EALJ,CAKQ,EALR,CAKY,EALZ,CAKgB,EALhB,CAKoB,GALpB,CAKyB,CALzB,CAK4B,GAL5B,CAKiC,EALjC,CAKqC,EALrC,CAKyC,GALzC,CAK8C,EAL9C,CAKkD,GALlD,CAKuD,GALvD,CAK4D,GAL5D,CAKiE,EALjE,CAKqE,EALrE,CAKyE,GALzE,CAK8E,GAL9E,CAKmF,GALnF,CAMN,GANM,CAMD,GANC,CAMI,GANJ,CAMS,GANT,CAMc,GANd,CAMmB,EANnB,CAMuB,GANvB,CAM4B,GAN5B,CAMiC,GANjC,CAMsC,GANtC,CAM2C,GAN3C,CAMgD,GANhD,CAMqD,CANrD,CAMwD,EANxD,CAM4D,EAN5D,CAMgE,GANhE,CAMqE,GANrE,CAM0E,GAN1E,CAM+E,GAN/E,CAMoF,GANpF,CAON,CAPM,CAOH,GAPG,CAOE,EAPF,CAOM,GAPN,CAOW,GAPX,CAOgB,GAPhB,CAOqB,GAPrB,CAO0B,EAP1B,CAO8B,EAP9B,CAOkC,GAPlC,CAOuC,GAPvC,CAO4C,GAP5C,CAOiD,EAPjD,CAOqD,GAPrD,CAO0D,EAP1D,CAO8D,EAP9D,CAOkE,EAPlE,CAOsE,EAPtE,CAO0E,GAP1E,CAO+E,GAP/E,CAOoF,EAPpF,CAOwF,EAPxF,CAQN,GARM,CAQD,GARC,CAQI,GARJ,CAQS,GART,CAQc,GARd,CAQmB,GARnB,CAQwB,GARxB,CAQ6B,CAR7B,CAQgC,EARhC,CAQoC,GARpC,CAQyC,GARzC,CAQ8C,EAR9C,CAQkD,GARlD,CAQuD,GARvD,CAQ4D,GAR5D,CAQiE,GARjE,CAQsE,GARtE,CAQ2E,EAR3E,CAQ+E,GAR/E,CAQoF,CARpF,CASN,GATM,CASD,EATC,CASG,EATH,CASO,GATP,CASY,EATZ,CASgB,EAThB,CASoB,GATpB,CASyB,GATzB,CAS8B,EAT9B,CASkC,GATlC,CASuC,GATvC,CAS4C,GAT5C,CASiD,GATjD,CASsD,GATtD,CAS2D,GAT3D,CASgE,GAThE,CASqE,GATrE,CAS0E,GAT1E,CAS+E,EAT/E,CASmF,GATnF,CAUN,GAVM,CAUD,EAVC,CAUG,GAVH,CAUQ,GAVR,CAUa,GAVb,CAUkB,GAVlB,CAUuB,GAVvB,CAU4B,EAV5B,CAUgC,GAVhC,CAUqC,GAVrC,CAU0C,GAV1C,CAU+C,GAV/C,CAUoD,EAVpD,CAUwD,EAVxD,CAU4D,GAV5D,CAUiE,GAVjE,CAUsE,GAVtE,CAU2E,EAV3E,CAU+E,GAV/E,CAUoF,GAVpF,CAWN,EAXM,CAWF,GAXE,CAWG,GAXH,CAWQ,EAXR,CAWY,GAXZ,CAWiB,GAXjB,CAWsB,GAXtB,CAW2B,GAX3B,CAWgC,GAXhC,CAWqC,EAXrC,CAWyC,GAXzC,CAW8C,GAX9C,CAWmD,GAXnD,CAWwD,GAXxD,CAW6D,EAX7D,CAWiE,EAXjE,CAWqE,GAXrE,CAW0E,CAX1E,CAW6E,GAX7E,CAWkF,GAXlF,CAYN,GAZM,CAYD,GAZC,CAYI,GAZJ,CAYS,EAZT,CAYa,GAZb,CAYkB,GAZlB,CAYuB,EAZvB,CAY2B,EAZ3B,CAY+B,EAZ/B,CAYmC,EAZnC,CAYuC,GAZvC,CAY4C,GAZ5C,CAYiD,GAZjD,CAYsD,GAZtD,CAY2D,EAZ3D,CAY+D,EAZ/D,CAYmE,GAZnE,CAYwE,EAZxE,CAY4E,GAZ5E,CAYiF,GAZjF,CAAV,CAcA;AACA,GAAIC,CAAAA,IAAI,CAAG,GAAIC,CAAAA,KAAJ,CAAU,GAAV,CAAX,CACA,GAAIC,CAAAA,KAAK,CAAG,GAAID,CAAAA,KAAJ,CAAU,GAAV,CAAZ,CAEA;AACA;AACA,GAAME,CAAAA,IAAI,CAAG,cAACA,KAAD,CAAU,CACnB,GAAIA,KAAI,CAAG,CAAP,EAAYA,KAAI,CAAG,CAAvB,CAA0B,CACtB;AACAA,KAAI,EAAI,KAAR,CACH,CAEDA,KAAI,CAAGC,IAAI,CAACC,KAAL,CAAWF,KAAX,CAAP,CACA,GAAIA,KAAI,CAAG,GAAX,CAAgB,CACZA,KAAI,EAAIA,KAAI,EAAI,CAAhB,CACH,CAED,IAAK,GAAIG,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAG,GAApB,CAAyBA,CAAC,EAA1B,CAA8B,CAC1B,GAAIC,CAAAA,CAAJ,CACA,GAAID,CAAC,CAAG,CAAR,CAAW,CACPC,CAAC,CAAGR,CAAC,CAACO,CAAD,CAAD,CAAQH,KAAI,CAAG,GAAnB,CACH,CAFD,IAEO,CACHI,CAAC,CAAGR,CAAC,CAACO,CAAD,CAAD,CAASH,KAAI,EAAI,CAAT,CAAc,GAA1B,CACH,CAEDH,IAAI,CAACM,CAAD,CAAJ,CAAUN,IAAI,CAACM,CAAC,CAAG,GAAL,CAAJ,CAAgBC,CAA1B,CACAL,KAAK,CAACI,CAAD,CAAL,CAAWJ,KAAK,CAACI,CAAC,CAAG,GAAL,CAAL,CAAiBR,KAAK,CAACS,CAAC,CAAG,EAAL,CAAjC,CACH,CACJ,CAtBD,CAwBA;AACA,GAAMC,CAAAA,EAAE,CAAG,KAAOJ,IAAI,CAACK,IAAL,CAAU,CAAV,EAAe,CAAtB,CAAX,CACA,GAAMC,CAAAA,EAAE,CAAG,CAAC,EAAIN,IAAI,CAACK,IAAL,CAAU,CAAV,CAAL,EAAqB,CAAhC,CAEA;AACA,GAAME,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAACC,GAAD,CAAMC,GAAN,CAAc,CAC3B,GAAIC,CAAAA,EAAJ,CAAQC,EAAR,CAAYC,EAAZ,CAAgB;AAChB;AACA,GAAIC,CAAAA,CAAC,CAAG,CAACL,GAAG,CAAGC,GAAP,EAAcL,EAAtB,CAA0B;AAC1B,GAAIF,CAAAA,CAAC,CAAGF,IAAI,CAACC,KAAL,CAAWO,GAAG,CAAGK,CAAjB,CAAR,CACA,GAAIC,CAAAA,CAAC,CAAGd,IAAI,CAACC,KAAL,CAAWQ,GAAG,CAAGI,CAAjB,CAAR,CACA,GAAIE,CAAAA,CAAC,CAAG,CAACb,CAAC,CAAGY,CAAL,EAAUR,EAAlB,CACA,GAAIU,CAAAA,EAAE,CAAGR,GAAG,CAAGN,CAAN,CAAUa,CAAnB,CAAsB;AACtB,GAAIE,CAAAA,EAAE,CAAGR,GAAG,CAAGK,CAAN,CAAUC,CAAnB,CACA;AACA;AACA,GAAIG,CAAAA,EAAJ,CAAQC,EAAR,CAAY;AACZ,GAAIH,EAAE,CAAGC,EAAT,CAAa,CAAE;AACXC,EAAE,CAAG,CAAL,CAAQC,EAAE,CAAG,CAAL,CACX,CAFD,IAEO,CAAK;AACRD,EAAE,CAAG,CAAL,CAAQC,EAAE,CAAG,CAAL,CACX,CACD;AACA;AACA;AACA,GAAIC,CAAAA,EAAE,CAAGJ,EAAE,CAAGE,EAAL,CAAUZ,EAAnB,CAAuB;AACvB,GAAIe,CAAAA,EAAE,CAAGJ,EAAE,CAAGE,EAAL,CAAUb,EAAnB,CACA,GAAIgB,CAAAA,EAAE,CAAGN,EAAE,CAAG,CAAL,CAAS,EAAIV,EAAtB,CAA0B;AAC1B,GAAIiB,CAAAA,EAAE,CAAGN,EAAE,CAAG,CAAL,CAAS,EAAIX,EAAtB,CACA;AACAJ,CAAC,EAAI,GAAL,CACAY,CAAC,EAAI,GAAL,CACA,GAAIU,CAAAA,GAAG,CAAG1B,KAAK,CAACI,CAAC,CAAGN,IAAI,CAACkB,CAAD,CAAT,CAAf,CACA,GAAIW,CAAAA,GAAG,CAAG3B,KAAK,CAACI,CAAC,CAAGgB,EAAJ,CAAStB,IAAI,CAACkB,CAAC,CAAGK,EAAL,CAAd,CAAf,CACA,GAAIO,CAAAA,GAAG,CAAG5B,KAAK,CAACI,CAAC,CAAG,CAAJ,CAAQN,IAAI,CAACkB,CAAC,CAAG,CAAL,CAAb,CAAf,CACA;AACA,GAAIa,CAAAA,EAAE,CAAG,IAAMX,EAAE,CAAGA,EAAX,CAAgBC,EAAE,CAAGA,EAA9B,CACA,GAAIU,EAAE,CAAG,CAAT,CAAY,CACRjB,EAAE,CAAG,CAAL,CACH,CAFD,IAEO,CACHiB,EAAE,EAAIA,EAAN,CACAjB,EAAE,CAAGiB,EAAE,CAAGA,EAAL,CAAUH,GAAG,CAAChC,IAAJ,CAASwB,EAAT,CAAaC,EAAb,CAAf,CAAkC;AACrC,CACD,GAAIW,CAAAA,EAAE,CAAG,IAAMR,EAAE,CAAGA,EAAX,CAAgBC,EAAE,CAAGA,EAA9B,CACA,GAAIO,EAAE,CAAG,CAAT,CAAY,CACRjB,EAAE,CAAG,CAAL,CACH,CAFD,IAEO,CACHiB,EAAE,EAAIA,EAAN,CACAjB,EAAE,CAAGiB,EAAE,CAAGA,EAAL,CAAUH,GAAG,CAACjC,IAAJ,CAAS4B,EAAT,CAAaC,EAAb,CAAf,CACH,CACD,GAAIQ,CAAAA,EAAE,CAAG,IAAMP,EAAE,CAAGA,EAAX,CAAgBC,EAAE,CAAGA,EAA9B,CACA,GAAIM,EAAE,CAAG,CAAT,CAAY,CACRjB,EAAE,CAAG,CAAL,CACH,CAFD,IAEO,CACHiB,EAAE,EAAIA,EAAN,CACAjB,EAAE,CAAGiB,EAAE,CAAGA,EAAL,CAAUH,GAAG,CAAClC,IAAJ,CAAS8B,EAAT,CAAaC,EAAb,CAAf,CACH,CACD;AACA;AACA,MAAO,KAAMb,EAAE,CAAGC,EAAL,CAAUC,EAAhB,CAAP,CACH,CAvDD,CAyDA,GAAMkB,CAAAA,KAAK,CAAG,EAAd,CACA,MAAO,IAAMC,CAAAA,WAAW,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,YAAzC,CAAuDC,IAAvD,CAA6DC,IAA7D,CAAmEC,OAAnE,2IACvBvC,IAAI,CAACC,IAAI,CAACuC,MAAL,EAAD,CAAJ,CACIC,OAFmB,CAET,EAFS,CAGdpD,CAHc,CAGV,CAHU,aAGPA,CAAC,CAAGiD,IAHG,uFAIVhD,CAJU,uJAKf;AACMoD,QANS,WAMKpD,CANL,aAMUD,CANV,EAOTsD,aAPS,CAOOR,SAAS,CAACO,QAAD,CAAT,CAAoB,CAApB,CAPP,CASf;AACIE,KAVW,CAUHpC,QAAQ,CAACnB,CAAC,CAAG0C,KAAL,CAAYzC,CAAC,CAAGyC,KAAhB,CAVL,CAWTc,KAXS,CAWD,CAAC3D,YAAY,CAAC4D,IAAd,CAXC,CAaf,GAAIF,KAAK,EAAI,CAAC,CAAV,EAAeA,KAAK,EAAI,CAAC,IAA7B,CAAmC,CAC/BC,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAAC8D,IAA3B,EACH,CAFD,IAGK,IAAIJ,KAAK,CAAG,CAAC,IAAT,EAAiBA,KAAK,EAAI,CAAC,IAA/B,CAAqC,CACtCC,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAAC+D,WAA3B,EACH,CAFI,IAGA,IAAIL,KAAK,CAAG,CAAC,IAAT,EAAiBA,KAAK,EAAI,IAA9B,CAAoC,CACrCC,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAACgE,UAA3B,EACH,CAFI,IAGA,IAAIN,KAAK,CAAG,IAAR,EAAgBA,KAAK,EAAI,IAA7B,CAAmC,CACpCC,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAACiE,UAA3B,EACH,CAFI,IAGA,IAAIP,KAAK,CAAG,IAAR,EAAgBA,KAAK,EAAI,IAA7B,CAAmC,CACpCC,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAACkE,UAA3B,EACH,CAFI,IAGA,IAAIR,KAAK,CAAG,IAAR,EAAgBA,KAAK,EAAI,CAA7B,CAAgC,CACjCC,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAACmE,UAA3B,EACH,CAED,GAAIX,QAAQ,GAAKT,SAAjB,CAA4B,CACxBY,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAACoE,KAA3B,EACH,CAFD,IAGK,IAAIZ,QAAQ,GAAKR,UAAjB,CAA6B,CAC9BW,KAAK,CAACE,OAAN,CAAc7D,YAAY,CAACqE,MAA3B,EACH,CAEDZ,aAAa,CAAC,SAAAa,SAAS,QAAIX,CAAAA,KAAJ,EAAV,CAAb,CACAJ,OAAO,CAACC,QAAD,CAAP,CAAoB,CAACG,KAAD,CAAQF,aAAR,CAApB,CAxCe,uBAyCTxD,CAAAA,KAAK,CAACoD,OAAD,CAzCI,wDAIVjD,CAJU,CAIN,CAJM,aAIHA,CAAC,CAAG+C,IAJD,iEAIV/C,CAJU,iBAIOA,CAAC,EAJR,gCAGGD,CAAC,EAHJ,gCA6CvB+C,YAAY,CAAC,SAAAoB,SAAS,QAAIf,CAAAA,OAAJ,EAAV,CAAZ,CA7CuB,wDAAH,kBAAXT,CAAAA,WAAW,oEAAjB","sourcesContent":["import { nodeTypeEnum } from \"../../utils/constants\";\nimport { sleep } from \"../../utils/helper\";\n\nfunction Grad(x, y, z) {\n    this.x = x; this.y = y; this.z = z;\n}\n\nGrad.prototype.dot2 = function (x, y) {\n    return this.x * x + this.y * y;\n};\n\nGrad.prototype.dot3 = function (x, y, z) {\n    return this.x * x + this.y * y + this.z * z;\n};\n\nconst grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\nnew Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\nnew Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n\nconst p = [151, 160, 137, 91, 90, 15,\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\n\n// To remove the need for index wrapping, double the permutation table length\nvar perm = new Array(512);\nvar gradP = new Array(512);\n\n// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nconst seed = (seed) => {\n    if (seed > 0 && seed < 1) {\n        // Scale the seed out\n        seed *= 65536;\n    }\n\n    seed = Math.floor(seed);\n    if (seed < 256) {\n        seed |= seed << 8;\n    }\n\n    for (var i = 0; i < 256; i++) {\n        var v;\n        if (i & 1) {\n            v = p[i] ^ (seed & 255);\n        } else {\n            v = p[i] ^ ((seed >> 8) & 255);\n        }\n\n        perm[i] = perm[i + 256] = v;\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n};\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\n// 2D simplex noise\nconst simplex2 = (xin, yin) => {\n    var n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin + yin) * F2; // Hairy factor for 2D\n    var i = Math.floor(xin + s);\n    var j = Math.floor(yin + s);\n    var t = (i + j) * G2;\n    var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin - j + t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        i1 = 1; j1 = 0;\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        i1 = 0; j1 = 1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    var y1 = y0 - j1 + G2;\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    var y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n    var gi0 = gradP[i + perm[j]];\n    var gi1 = gradP[i + i1 + perm[j + j1]];\n    var gi2 = gradP[i + 1 + perm[j + 1]];\n    // Calculate the contribution from the three corners\n    var t0 = 0.5 - x0 * x0 - y0 * y0;\n    if (t0 < 0) {\n        n0 = 0;\n    } else {\n        t0 *= t0;\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 < 0) {\n        n1 = 0;\n    } else {\n        t1 *= t1;\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    var t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 < 0) {\n        n2 = 0;\n    } else {\n        t2 *= t2;\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n};\n\nconst SCALE = 12;\nexport const perlinNoise = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    seed(Math.random());\n    let gridMap = {};\n    for (let x = 0; x < cols; x++) {\n        for (let y = 0; y < rows; y++) {\n            // All noise functions return values in the range of -1 to 1.\n            const currCord = `${y}:${x}`;\n            const nodeStateFunc = gridState[currCord][1];\n\n            // noise.simplex2 and noise.perlin2 for 2d noise\n            let value = simplex2(x / SCALE, y / SCALE);\n            const state = [nodeTypeEnum.none];\n\n            if (value >= -1 && value <= -0.50) {\n                state.unshift(nodeTypeEnum.wall);\n            }\n            else if (value > -0.50 && value <= -0.20) {\n                state.unshift(nodeTypeEnum.weighted100);\n            }\n            else if (value > -0.20 && value <= 0.10) {\n                state.unshift(nodeTypeEnum.weighted80);\n            }\n            else if (value > 0.10 && value <= 0.40) {\n                state.unshift(nodeTypeEnum.weighted60);\n            }\n            else if (value > 0.40 && value <= 0.70) {\n                state.unshift(nodeTypeEnum.weighted40);\n            }\n            else if (value > 0.70 && value <= 1) {\n                state.unshift(nodeTypeEnum.weighted20);\n            }\n\n            if (currCord === startCord) {\n                state.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                state.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => state);\n            gridMap[currCord] = [state, nodeStateFunc];\n            await sleep(timeout);\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};"]},"metadata":{},"sourceType":"module"}