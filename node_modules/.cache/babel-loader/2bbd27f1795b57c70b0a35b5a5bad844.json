{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNeighbourNodes}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var dfs=function dfs(startCord,targetCord,gridState,rows,cols,timeout){var stack=[startCord];var path=[];var visited=_defineProperty({},startCord,1);while(stack.length>0){var currCord=stack[0];if(currCord!==targetCord&&currCord!==startCord){(function(){var nodeStateFunc=gridState[currCord][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting,nodeTypeEnum.none];});},timeout);})();}if(currCord===targetCord){stack.pop();stack.shift();return stack;}if(currCord!==startCord){(function(){path.unshift(currCord);visited[currCord]=1;var nodeStateFunc=gridState[currCord][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visited,nodeTypeEnum.none];});},timeout);})();}var neighbours=getNeighbourNodes(currCord,rows,cols,gridState);var unvisitedNeighbourFound=false;var _iterator=_createForOfIteratorHelper(neighbours),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbour=_step.value;if(neighbour in visited){continue;}stack.unshift(neighbour);unvisitedNeighbourFound=true;break;}}catch(err){_iterator.e(err);}finally{_iterator.f();}if(!unvisitedNeighbourFound){stack.splice(0,1);}}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNeighbourNodes","nodeTypeEnum","dfs","startCord","targetCord","gridState","rows","cols","timeout","stack","path","visited","length","currCord","nodeStateFunc","setTimeout","prevState","visiting","none","pop","shift","unshift","neighbours","unvisitedNeighbourFound","neighbour","splice"],"mappings":"oZAAA,OAASA,iBAAT,KAAkC,uBAAlC,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,SAAxB,CAAmCC,IAAnC,CAAyCC,IAAzC,CAA+CC,OAA/C,CAA2D,CAC1E,GAAMC,CAAAA,KAAK,CAAG,CAACN,SAAD,CAAd,CACA,GAAMO,CAAAA,IAAI,CAAG,EAAb,CACA,GAAMC,CAAAA,OAAO,oBAAMR,SAAN,CAAkB,CAAlB,CAAb,CAEA,MAAOM,KAAK,CAACG,MAAN,CAAe,CAAtB,CAAyB,CACrB,GAAMC,CAAAA,QAAQ,CAAGJ,KAAK,CAAC,CAAD,CAAtB,CACA,GAAII,QAAQ,GAAKT,UAAb,EAA2BS,QAAQ,GAAKV,SAA5C,CAAuD,aACnD,GAAMW,CAAAA,aAAa,CAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB,CACAE,UAAU,CAAC,UAAM,CACbD,aAAa,CAAC,SAAAE,SAAS,QAAK,CAACf,YAAY,CAACgB,QAAd,CAAwBhB,YAAY,CAACiB,IAArC,CAAL,EAAV,CAAb,CACH,CAFS,CAEPV,OAFO,CAAV,CAFmD,KAKtD,CAED,GAAIK,QAAQ,GAAKT,UAAjB,CAA6B,CACzBK,KAAK,CAACU,GAAN,GACAV,KAAK,CAACW,KAAN,GACA,MAAOX,CAAAA,KAAP,CACH,CAED,GAAII,QAAQ,GAAKV,SAAjB,CAA4B,aACxBO,IAAI,CAACW,OAAL,CAAaR,QAAb,EACAF,OAAO,CAACE,QAAD,CAAP,CAAoB,CAApB,CACA,GAAMC,CAAAA,aAAa,CAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB,CACAE,UAAU,CAAC,UAAM,CACbD,aAAa,CAAC,SAAAE,SAAS,QAAK,CAACf,YAAY,CAACU,OAAd,CAAuBV,YAAY,CAACiB,IAApC,CAAL,EAAV,CAAb,CACH,CAFS,CAEPV,OAFO,CAAV,CAJwB,KAO3B,CAED,GAAMc,CAAAA,UAAU,CAAGtB,iBAAiB,CAACa,QAAD,CAAWP,IAAX,CAAiBC,IAAjB,CAAuBF,SAAvB,CAApC,CACA,GAAIkB,CAAAA,uBAAuB,CAAG,KAA9B,CAzBqB,yCA0BGD,UA1BH,YA0BrB,+CAAoC,IAAzBE,CAAAA,SAAyB,aAChC,GAAIA,SAAS,GAAIb,CAAAA,OAAjB,CAA0B,CACtB,SACH,CAEDF,KAAK,CAACY,OAAN,CAAcG,SAAd,EACAD,uBAAuB,CAAG,IAA1B,CACA,MACH,CAlCoB,qDAoCrB,GAAI,CAACA,uBAAL,CAA8B,CAC1Bd,KAAK,CAACgB,MAAN,CAAa,CAAb,CAAgB,CAAhB,EACH,CACJ,CAED,MAAO,EAAP,CACH,CA/CM","sourcesContent":["import { getNeighbourNodes } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const path = [];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n            }, timeout);\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            path.unshift(currCord);\n            visited[currCord] = 1;\n            const nodeStateFunc = gridState[currCord][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n            }, timeout);\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}