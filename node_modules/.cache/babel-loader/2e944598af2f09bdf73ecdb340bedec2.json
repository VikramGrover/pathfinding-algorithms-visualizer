{"ast":null,"code":"import { getNodeTypeEnum, getNodeWeight } from '../../utils/util.js';\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n  console.log(\"STARTING DIJSTRAS\");\n  let totalCosts = {};\n  let prevNodes = {};\n  let minPQ = {};\n  let visited = {};\n  totalCosts[startCord] = 0;\n  minPQ[startCord] = 0;\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      let cord = `${x}:${y}`;\n\n      if (cord !== startCord) {\n        totalCosts[cord] = Infinity;\n      }\n    }\n  }\n\n  while (Object.keys(minPQ).length > 0) {\n    const minKey = findMinPriorityNode(minPQ);\n    delete minPQ[minKey];\n    visited[minKey] = 1;\n\n    if (minKey !== startCord && minKey !== targetCord) {\n      setTimeout(() => {\n        setGridState(prevState => ({ ...prevState,\n          [minKey]: [getNodeTypeEnum('visited')]\n        }));\n      }, 200);\n    } else if (minKey === targetCord) {\n      console.log(\"ENDING DIJSTRAS\");\n      return createPath(startCord, targetCord, prevNodes, setGridState);\n    }\n\n    const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n\n    for (const neighbour of neighbours) {\n      const currPath = totalCosts[minKey] + getNodeWeight(gridState[neighbour][0]);\n\n      if (neighbour in visited) {\n        continue;\n      }\n\n      if (neighbour in minPQ && currPath < totalCosts[neighbour] || !(neighbour in minPQ)) {\n        totalCosts[neighbour] = currPath;\n        prevNodes[neighbour] = minKey;\n        minPQ[neighbour] = currPath;\n      }\n    }\n  }\n\n  console.log(\"ENDING DIJSTRAS\");\n  return [];\n};\n\nconst sleep = ms => {\n  const date = Date.now();\n  let currentDate = null;\n\n  do {\n    currentDate = Date.now();\n  } while (currentDate - date < ms);\n};\n\nconst createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\n\nconst getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0] !== getNodeTypeEnum('obstacle')) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0] !== getNodeTypeEnum('obstacle')) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0] !== getNodeTypeEnum('obstacle')) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0] !== getNodeTypeEnum('obstacle')) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  return res;\n};\n\nconst findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNodeTypeEnum","getNodeWeight","dijkstras","startCord","targetCord","gridState","setGridState","rows","cols","console","log","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","Object","keys","length","minKey","findMinPriorityNode","setTimeout","prevState","createPath","neighbours","getNeighbourNodes","neighbour","currPath","sleep","ms","date","Date","now","currentDate","path","push","node","row","parseInt","split","col","res","minPriority","Math","min","values","key"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight } from '../../utils/util.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n    console.log(\"STARTING DIJSTRAS\");\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [minKey]: [getNodeTypeEnum('visited')] }));\n            }, 200);\n        }\n        else if (minKey === targetCord) {\n            console.log(\"ENDING DIJSTRAS\");\n            return createPath(startCord, targetCord, prevNodes, setGridState);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + getNodeWeight(gridState[neighbour][0]);\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n            }\n        }\n    }\n\n    console.log(\"ENDING DIJSTRAS\");\n    return [];\n};\n\nconst sleep = (ms) => {\n    const date = Date.now();\n    let currentDate = null;\n    do {\n        currentDate = Date.now();\n    } while (currentDate - date < ms);\n};\n\nconst createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nconst getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row}:${col - 1}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row}:${col + 1}`)\n    }\n\n    return res;\n};\n\nconst findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};"]},"metadata":{},"sourceType":"module"}