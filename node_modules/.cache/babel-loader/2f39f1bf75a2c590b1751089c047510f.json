{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNeighbourNodes,createPath}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var bfs=function bfs(startCord,targetCord,gridState,rows,cols,timeout){var queue=[startCord];var visited=_defineProperty({},startCord,1);var prevNodes={};while(queue.length>0){var currCord=queue.pop();if(currCord!==startCord&&currCord!==targetCord){(function(){var nodeStateFunc=gridState[currCord][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visited,nodeTypeEnum.none];});},timeout);})();}var neighbours=getNeighbourNodes(currCord,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{var _loop=function _loop(){var neighbour=_step.value;if(neighbour in visited){return\"continue\";}prevNodes[neighbour]=currCord;queue.unshift(neighbour);visited[neighbour]=1;if(neighbour===targetCord){return{v:createPath(startCord,targetCord,prevNodes)};}var nodeStateFunc=gridState[neighbour][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting,nodeTypeEnum.none];});},timeout);};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret=_loop();if(_ret===\"continue\")continue;if(typeof _ret===\"object\")return _ret.v;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bfs.js"],"names":["getNeighbourNodes","createPath","nodeTypeEnum","bfs","startCord","targetCord","gridState","rows","cols","timeout","queue","visited","prevNodes","length","currCord","pop","nodeStateFunc","setTimeout","prevState","none","neighbours","neighbour","unshift","visiting"],"mappings":"oZAAA,OAASA,iBAAT,CAA4BC,UAA5B,KAA8C,uBAA9C,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,SAAxB,CAAmCC,IAAnC,CAAyCC,IAAzC,CAA+CC,OAA/C,CAA2D,CAC1E,GAAIC,CAAAA,KAAK,CAAG,CAACN,SAAD,CAAZ,CACA,GAAIO,CAAAA,OAAO,oBAAMP,SAAN,CAAkB,CAAlB,CAAX,CACA,GAAIQ,CAAAA,SAAS,CAAG,EAAhB,CAEA,MAAOF,KAAK,CAACG,MAAN,CAAe,CAAtB,CAAyB,CACrB,GAAMC,CAAAA,QAAQ,CAAGJ,KAAK,CAACK,GAAN,EAAjB,CACA,GAAID,QAAQ,GAAKV,SAAb,EAA0BU,QAAQ,GAAKT,UAA3C,CAAuD,aACnD,GAAMW,CAAAA,aAAa,CAAGV,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB,CACAG,UAAU,CAAC,UAAM,CACbD,aAAa,CAAC,SAAAE,SAAS,QAAK,CAAChB,YAAY,CAACS,OAAd,CAAuBT,YAAY,CAACiB,IAApC,CAAL,EAAV,CAAb,CACH,CAFS,CAEPV,OAFO,CAAV,CAFmD,KAKtD,CACD,GAAMW,CAAAA,UAAU,CAAGpB,iBAAiB,CAACc,QAAD,CAAWP,IAAX,CAAiBC,IAAjB,CAAuBF,SAAvB,CAApC,CARqB,yCAUGc,UAVH,0CAUVC,CAAAA,SAVU,aAWjB,GAAIA,SAAS,GAAIV,CAAAA,OAAjB,CAA0B,CACtB,iBACH,CAEDC,SAAS,CAACS,SAAD,CAAT,CAAuBP,QAAvB,CACAJ,KAAK,CAACY,OAAN,CAAcD,SAAd,EACAV,OAAO,CAACU,SAAD,CAAP,CAAqB,CAArB,CAEA,GAAIA,SAAS,GAAKhB,UAAlB,CAA8B,CAC1B,SAAOJ,UAAU,CAACG,SAAD,CAAYC,UAAZ,CAAwBO,SAAxB,CAAjB,EACH,CAED,GAAMI,CAAAA,aAAa,CAAGV,SAAS,CAACe,SAAD,CAAT,CAAqB,CAArB,CAAtB,CACAJ,UAAU,CAAC,UAAM,CACbD,aAAa,CAAC,SAAAE,SAAS,QAAK,CAAChB,YAAY,CAACqB,QAAd,CAAwBrB,YAAY,CAACiB,IAArC,CAAL,EAAV,CAAb,CACH,CAFS,CAEPV,OAFO,CAAV,CAxBiB,EAUrB,+CAAoC,uCAE5B,SAF4B,wCAiBnC,CA3BoB,qDA4BxB,CAED,MAAO,EAAP,CACH,CApCM","sourcesContent":["import { getNeighbourNodes, createPath } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bfs = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n            }, timeout);\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            const nodeStateFunc = gridState[neighbour][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n            }, timeout);\n        }\n    }\n\n    return [];\n};\n"]},"metadata":{},"sourceType":"module"}