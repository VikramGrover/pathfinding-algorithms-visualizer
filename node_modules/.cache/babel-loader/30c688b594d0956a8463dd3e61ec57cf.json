{"ast":null,"code":"import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React from'react';import{useEffect,useState}from'react';import{EMPTY_NODE_BORDER_COLOR,nodeColors,nodeTypeEnum}from'../utils/constants.js';import{getNodeColor}from'../utils/helper.js';import{jsx as _jsx}from\"react/jsx-runtime\";var Node=function Node(_ref){var nodeId=_ref.nodeId,size=_ref.size,setGridState=_ref.setGridState,draggingSelection=_ref.draggingSelection,setDraggingSelection=_ref.setDraggingSelection,setStartCord=_ref.setStartCord,setTargetCord=_ref.setTargetCord,runningAlgo=_ref.runningAlgo,selectedObstacle=_ref.selectedObstacle,startingState=_ref.startingState;var _useState=useState(startingState),_useState2=_slicedToArray(_useState,2),nodeState=_useState2[0],setNodeState=_useState2[1];useEffect(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[startingState,setNodeState]));});},[]);var nodeColor=getNodeColor(nodeState);var nodeStyle={width:size,height:size,backgroundColor:nodeColor,border:\"1px solid \".concat(nodeState[0]===nodeTypeEnum.none?EMPTY_NODE_BORDER_COLOR:nodeColor)};if(draggingSelection===nodeTypeEnum.start||draggingSelection===nodeTypeEnum.target){nodeStyle.cursor='grabbing';}var mouseDowned=function mouseDowned(){if(nodeState[0]<=nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum[selectedObstacle]);setNodeState(function(prevState){return[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none];});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none],setNodeState]));});return;}else if(nodeState[0]>=nodeTypeEnum.wall){setNodeState(function(prevState){return prevState.slice(1);});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState.slice(1),setNodeState]));});setDraggingSelection(nodeTypeEnum.remObstacle);return;}else if(nodeState[0]===nodeTypeEnum.start||nodeState[0]===nodeTypeEnum.target){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState.slice(1),setNodeState]));});}setDraggingSelection(nodeState[0]);};var mouseEntered=function mouseEntered(){if(draggingSelection===nodeTypeEnum.remObstacle&&nodeState[0]>=nodeTypeEnum.wall){setNodeState(function(prevState){return prevState.slice(1);});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState.slice(1),setNodeState]));});}else if(draggingSelection===nodeTypeEnum[selectedObstacle]&&nodeState[0]<=nodeTypeEnum.none){setNodeState(function(prevState){return[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none];});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none],setNodeState]));});}else if(draggingSelection===nodeTypeEnum.start){setNodeState(function(prevState){return[draggingSelection].concat(_toConsumableArray(prevState));});}else if(draggingSelection===nodeTypeEnum.target){setNodeState(function(prevState){return[draggingSelection].concat(_toConsumableArray(prevState));});}};var mouseLeft=function mouseLeft(){if(draggingSelection===nodeTypeEnum.start||draggingSelection===nodeTypeEnum.target){setNodeState(function(prevState){return prevState.slice(1);});return;}};var mouseUped=function mouseUped(){if(draggingSelection===nodeTypeEnum.start){setStartCord(nodeId);setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState,setNodeState]));});}else if(draggingSelection===nodeTypeEnum.target){setTargetCord(nodeId);setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState,setNodeState]));});}if(draggingSelection!==nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum.none);}};return/*#__PURE__*/_jsx(\"div\",{style:nodeStyle,className:\"node \".concat(draggingSelection===nodeTypeEnum.remObstacle&&'erasing'),onMouseDown:runningAlgo?null:mouseDowned,onMouseUp:runningAlgo?null:mouseUped,onMouseEnter:runningAlgo?null:mouseEntered,onMouseLeave:runningAlgo?null:mouseLeft});};export default Node;","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/components/Node.js"],"names":["React","useEffect","useState","EMPTY_NODE_BORDER_COLOR","nodeColors","nodeTypeEnum","getNodeColor","Node","nodeId","size","setGridState","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","selectedObstacle","startingState","nodeState","setNodeState","prevState","nodeColor","nodeStyle","width","height","backgroundColor","border","none","start","target","cursor","mouseDowned","wall","slice","remObstacle","mouseEntered","mouseLeft","mouseUped"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { useEffect, useState } from 'react'\nimport { EMPTY_NODE_BORDER_COLOR, nodeColors, nodeTypeEnum } from '../utils/constants.js'\nimport { getNodeColor } from '../utils/helper.js'\n\nconst Node = ({ nodeId, size, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo, selectedObstacle, startingState }) => {\n    const [nodeState, setNodeState] = useState(startingState);\n\n    useEffect(() => {\n        setGridState(prevState => ({ ...prevState, [nodeId]: [startingState, setNodeState] }));\n    }, []);\n\n    const nodeColor = getNodeColor(nodeState);\n    const nodeStyle = {\n        width: size,\n        height: size,\n        backgroundColor: nodeColor,\n        border: `1px solid ${nodeState[0] === nodeTypeEnum.none ? EMPTY_NODE_BORDER_COLOR : nodeColor}`\n    };\n\n    if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n        nodeStyle.cursor = 'grabbing';\n    }\n\n    const mouseDowned = () => {\n        if (nodeState[0] <= nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum[selectedObstacle]);\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n            return;\n        }\n        else if (nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n            setDraggingSelection(nodeTypeEnum.remObstacle);\n            return;\n        }\n        else if (nodeState[0] === nodeTypeEnum.start || nodeState[0] === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === nodeTypeEnum.remObstacle && nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum[selectedObstacle] && nodeState[0] <= nodeTypeEnum.none) {\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.start) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => prevState.slice(1));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection === nodeTypeEnum.start) {\n            setStartCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setTargetCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        if (draggingSelection !== nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum.none);\n        }\n    };\n\n    return (\n        <div style={nodeStyle} className={`node ${draggingSelection === nodeTypeEnum.remObstacle && 'erasing'}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n};\n\nexport default Node\n"]},"metadata":{},"sourceType":"module"}