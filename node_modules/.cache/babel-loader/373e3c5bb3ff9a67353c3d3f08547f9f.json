{"ast":null,"code":"import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors } from './constants.js';\nexport const getNodeColor = nodeState => {\n  if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visited) && nodeState[1] > nodeTypeEnum.wall) {\n    // we need to mix colors\n    const [rA, gA, bA] = colorA.match(/\\w\\w/g).map(c => parseInt(c, 16));\n    const [rB, gB, bB] = colorB.match(/\\w\\w/g).map(c => parseInt(c, 16));\n    const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n    const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n    const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n    return '#' + r + g + b;\n  }\n\n  return nodeColors[nodeState[0]];\n};\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};\nexport const createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\nexport const findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\nexport const isAlgoUnweighted = algo => {\n  return unweightedPathAlgos.includes(algo);\n};\nexport const isAlgoOptimal = algo => {\n  return optimalPathAlgos.includes(algo);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/helper.js"],"names":["nodeTypeEnum","unweightedPathAlgos","optimalPathAlgos","nodeColors","getNodeColor","nodeState","visited","wall","rA","gA","bA","colorA","match","map","c","parseInt","rB","gB","bB","colorB","r","Math","round","amount","toString","padStart","g","b","getNeighbourNodes","node","rows","cols","gridState","row","split","col","res","push","createPath","startCord","targetCord","prevNodes","cord","path","findMinPriorityNode","minPQ","minPriority","min","Object","values","key","isAlgoUnweighted","algo","includes","isAlgoOptimal"],"mappings":"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","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors } from './constants.js'\n\nexport const getNodeColor = (nodeState) => {\n    if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visited) && nodeState[1] > nodeTypeEnum.wall) {\n        // we need to mix colors\n        const [rA, gA, bA] = colorA.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const [rB, gB, bB] = colorB.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n        const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n        const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n        return '#' + r + g + b;\n    }\n\n    return nodeColors[nodeState[0]];\n};\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n"]},"metadata":{},"sourceType":"module"}