{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNeighbourNodes,createPath,findMinPriorityNode}from'../../utils/helper.js';import{nodeWeight,nodeTypeEnum}from'../../utils/constants.js';export var bestFirst=function bestFirst(startCord,targetCord,gridState,rows,cols,timeout){var openSet=_defineProperty({},startCord,0);var H=_defineProperty({},startCord,0);// H(n) => tells us the estimated distance from node n to target node\nvar F=_defineProperty({},startCord,0);// F(n) = H(n)\nvar prevNodes={};var visited={};// intialize all the scores to infinity for all node !== start node\nfor(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){F[cord]=H[cord]=Infinity;}}}while(Object.keys(openSet).length>0){var currNode=findMinPriorityNode(openSet);delete openSet[currNode];if(currNode!==startCord&&currNode!==targetCord){(function(){var nodeStateFunc=gridState[currNode][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visited].concat(_toConsumableArray(prevState.slice(1)));});},timeout);})();}else if(currNode===targetCord){console.log(\"DONNEE\");// we have reached target, return path\nreturn createPath(startCord,targetCord,prevNodes);}var neighbours=getNeighbourNodes(currNode,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbour=_step.value;if(!(neighbour in visited)){visited[neighbour]=1;if(neighbour!==startCord&&neighbour!==targetCord){(function(){var nodeStateFunc=gridState[neighbour][1];setTimeout(function(){nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting].concat(_toConsumableArray(prevState));});},timeout);})();}// newly calculated G score of neighbour is lower than the one in the table\n// update all the scores\nH[neighbour]=h(neighbour,targetCord)+nodeWeight[gridState[neighbour][0][0]];F[neighbour]=H[neighbour];prevNodes[neighbour]=currNode;openSet[neighbour]=F[neighbour];}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return[];};// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nvar h=function h(currNodeCord,targetCord){if(currNodeCord===targetCord){return 0;}var currRow=parseInt(currNodeCord.split(':')[0]);var currCol=parseInt(currNodeCord.split(':')[1]);var targetRow=parseInt(targetCord.split(':')[0]);var targetCol=parseInt(targetCord.split(':')[1]);return Math.abs(currRow-targetRow)+Math.abs(currCol-targetCol);};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bestFirst.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","nodeWeight","nodeTypeEnum","bestFirst","startCord","targetCord","gridState","rows","cols","timeout","openSet","H","F","prevNodes","visited","x","y","cord","Infinity","Object","keys","length","currNode","nodeStateFunc","setTimeout","prevState","slice","console","log","neighbours","neighbour","visiting","h","currNodeCord","currRow","parseInt","split","currCol","targetRow","targetCol","Math","abs"],"mappings":"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","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bestFirst = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = H(n)\n    let prevNodes = {};\n    let visited = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n            }, timeout);\n        }\n        else if (currNode === targetCord) {\n            console.log(\"DONNEE\");\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            if (!(neighbour in visited)) {\n                visited[neighbour] = 1;\n\n                if (neighbour !== startCord && neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    setTimeout(() => {\n                        nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                    }, timeout);\n                }\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                H[neighbour] = h(neighbour, targetCord) + nodeWeight[gridState[neighbour][0][0]];\n                F[neighbour] = H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst h = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};"]},"metadata":{},"sourceType":"module"}