{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNeighbourNodes,createPath}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var bfs=function bfs(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var queue=[startCord];var visited=_defineProperty({},startCord,1);var prevNodes={};var _loop=function _loop(){var currCord=queue.pop();if(currCord!==startCord&&currCord!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[nodeTypeEnum.visited,nodeTypeEnum.none]));});},timeout);}var neighbours=getNeighbourNodes(currCord,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{var _loop2=function _loop2(){var neighbour=_step.value;if(neighbour in visited){return\"continue\";}prevNodes[neighbour]=currCord;queue.unshift(neighbour);visited[neighbour]=1;if(neighbour===targetCord){return{v:{v:createPath(startCord,targetCord,prevNodes)}};}setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},neighbour,[nodeTypeEnum.visiting,nodeTypeEnum.none]));});},timeout);};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;if(typeof _ret2===\"object\")return _ret2.v;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(queue.length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bfs.js"],"names":["getNeighbourNodes","createPath","nodeTypeEnum","bfs","startCord","targetCord","gridState","setGridState","rows","cols","timeout","queue","visited","prevNodes","currCord","pop","setTimeout","prevState","none","neighbours","neighbour","unshift","visiting","length"],"mappings":"glBAAA,OAASA,iBAAT,CAA4BC,UAA5B,KAA8C,uBAA9C,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,SAAxB,CAAmCC,YAAnC,CAAiDC,IAAjD,CAAuDC,IAAvD,CAA6DC,OAA7D,CAAyE,CACxF,GAAIC,CAAAA,KAAK,CAAG,CAACP,SAAD,CAAZ,CACA,GAAIQ,CAAAA,OAAO,oBAAMR,SAAN,CAAkB,CAAlB,CAAX,CACA,GAAIS,CAAAA,SAAS,CAAG,EAAhB,CAHwF,2BAMpF,GAAMC,CAAAA,QAAQ,CAAGH,KAAK,CAACI,GAAN,EAAjB,CACA,GAAID,QAAQ,GAAKV,SAAb,EAA0BU,QAAQ,GAAKT,UAA3C,CAAuD,CACnDW,UAAU,CAAC,UAAM,CACbT,YAAY,CAAC,SAAAU,SAAS,wCAAUA,SAAV,wBAAsBH,QAAtB,CAAiC,CAACZ,YAAY,CAACU,OAAd,CAAuBV,YAAY,CAACgB,IAApC,CAAjC,IAAV,CAAZ,CACH,CAFS,CAEPR,OAFO,CAAV,CAGH,CACD,GAAMS,CAAAA,UAAU,CAAGnB,iBAAiB,CAACc,QAAD,CAAWN,IAAX,CAAiBC,IAAjB,CAAuBH,SAAvB,CAApC,CAZoF,yCAc5Da,UAd4D,4CAczEC,CAAAA,SAdyE,aAehF,GAAIA,SAAS,GAAIR,CAAAA,OAAjB,CAA0B,CACtB,iBACH,CAEDC,SAAS,CAACO,SAAD,CAAT,CAAuBN,QAAvB,CACAH,KAAK,CAACU,OAAN,CAAcD,SAAd,EACAR,OAAO,CAACQ,SAAD,CAAP,CAAqB,CAArB,CAEA,GAAIA,SAAS,GAAKf,UAAlB,CAA8B,CAC1B,YAAOJ,UAAU,CAACG,SAAD,CAAYC,UAAZ,CAAwBQ,SAAxB,CAAjB,GACH,CAEDG,UAAU,CAAC,UAAM,CACbT,YAAY,CAAC,SAAAU,SAAS,wCAAUA,SAAV,wBAAsBG,SAAtB,CAAkC,CAAClB,YAAY,CAACoB,QAAd,CAAwBpB,YAAY,CAACgB,IAArC,CAAlC,IAAV,CAAZ,CACH,CAFS,CAEPR,OAFO,CAAV,CA3BgF,EAcpF,+CAAoC,0CAE5B,SAF4B,0CAgBnC,CA9BmF,uDAKxF,MAAOC,KAAK,CAACY,MAAN,CAAe,CAAtB,CAAyB,0DA0BxB,CAED,MAAO,EAAP,CACH,CAlCM","sourcesContent":["import { getNeighbourNodes, createPath } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bfs = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [nodeTypeEnum.visited, nodeTypeEnum.none] }));\n            }, timeout);\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [neighbour]: [nodeTypeEnum.visiting, nodeTypeEnum.none] }));\n            }, timeout);\n        }\n    }\n\n    return [];\n};\n"]},"metadata":{},"sourceType":"module"}