{"ast":null,"code":"import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js';\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js';\nexport const dijkstras = (startCord, targetCord, gridState, rows, cols, timeout) => {\n  let totalCosts = {};\n  let prevNodes = {};\n  let minPQ = {};\n  let visited = {};\n  totalCosts[startCord] = 0;\n  minPQ[startCord] = 0;\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      let cord = `${x}:${y}`;\n\n      if (cord !== startCord) {\n        totalCosts[cord] = Infinity;\n      }\n    }\n  }\n\n  while (Object.keys(minPQ).length > 0) {\n    const minKey = findMinPriorityNode(minPQ);\n    delete minPQ[minKey];\n    visited[minKey] = 1;\n\n    if (minKey !== startCord && minKey !== targetCord) {\n      const nodeStateFunc = gridState[minKey][1]; // setTimeout(() => {\n\n      nodeStateFunc(prevState => [nodeTypeEnum.visited, ...prevState.slice(1)]); // }, timeout);\n    } else if (minKey === targetCord) {\n      return createPath(startCord, targetCord, prevNodes);\n    }\n\n    const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n\n    for (const neighbour of neighbours) {\n      const currPath = totalCosts[minKey] + nodeWeight[gridState[neighbour][0][0]];\n\n      if (neighbour in visited) {\n        continue;\n      }\n\n      if (neighbour in minPQ && currPath < totalCosts[neighbour] || !(neighbour in minPQ)) {\n        totalCosts[neighbour] = currPath;\n        prevNodes[neighbour] = minKey;\n        minPQ[neighbour] = currPath;\n\n        if (neighbour !== targetCord) {\n          const nodeStateFunc = gridState[neighbour][1]; // setTimeout(() => {\n\n          nodeStateFunc(prevState => [nodeTypeEnum.visiting, ...prevState]); // }, timeout);\n        }\n      }\n    }\n  }\n\n  return [];\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","nodeWeight","nodeTypeEnum","dijkstras","startCord","targetCord","gridState","rows","cols","timeout","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","Object","keys","length","minKey","nodeStateFunc","prevState","slice","neighbours","neighbour","currPath","visiting"],"mappings":"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","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            const nodeStateFunc = gridState[minKey][1];\n            // setTimeout(() => {\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n            // }, timeout);\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    // setTimeout(() => {\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                    // }, timeout);\n                }\n            }\n        }\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}