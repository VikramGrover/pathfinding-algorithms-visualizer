{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNodeTypeEnum,getNeighbourNodes}from'../../utils/util.js';export var dfs=function dfs(startCord,targetCord,gridState,setGridState,rows,cols){var stack=[startCord];var path=[];var visited=_defineProperty({},startCord,1);var _loop=function _loop(){var currCord=stack[0];if(currCord!==targetCord&&currCord!==startCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[getNodeTypeEnum('visiting'),getNodeTypeEnum('none')]));});},1);}if(currCord===targetCord){stack.pop();stack.shift();return{v:stack};}if(currCord!==startCord){path.unshift(currCord);visited[currCord]=1;setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[getNodeTypeEnum('visited'),getNodeTypeEnum('none')]));});},1);}var neighbours=getNeighbourNodes(currCord,rows,cols,gridState);var unvisitedNeighbourFound=false;var _iterator=_createForOfIteratorHelper(neighbours),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbour=_step.value;if(neighbour in visited){continue;}stack.unshift(neighbour);unvisitedNeighbourFound=true;break;}}catch(err){_iterator.e(err);}finally{_iterator.f();}if(!unvisitedNeighbourFound){stack.splice(0,1);}};while(stack.length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNodeTypeEnum","getNeighbourNodes","dfs","startCord","targetCord","gridState","setGridState","rows","cols","stack","path","visited","currCord","setTimeout","prevState","pop","shift","unshift","neighbours","unvisitedNeighbourFound","neighbour","splice","length"],"mappings":"glBAAA,OAASA,eAAT,CAA0BC,iBAA1B,KAAmD,qBAAnD,CAEA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,SAAxB,CAAmCC,YAAnC,CAAiDC,IAAjD,CAAuDC,IAAvD,CAAgE,CAC/E,GAAMC,CAAAA,KAAK,CAAG,CAACN,SAAD,CAAd,CACA,GAAMO,CAAAA,IAAI,CAAG,EAAb,CACA,GAAMC,CAAAA,OAAO,oBAAMR,SAAN,CAAkB,CAAlB,CAAb,CAH+E,2BAM3E,GAAMS,CAAAA,QAAQ,CAAGH,KAAK,CAAC,CAAD,CAAtB,CACA,GAAIG,QAAQ,GAAKR,UAAb,EAA2BQ,QAAQ,GAAKT,SAA5C,CAAuD,CACnDU,UAAU,CAAC,UAAM,CACbP,YAAY,CAAC,SAAAQ,SAAS,wCAAUA,SAAV,wBAAsBF,QAAtB,CAAiC,CAACZ,eAAe,CAAC,UAAD,CAAhB,CAA8BA,eAAe,CAAC,MAAD,CAA7C,CAAjC,IAAV,CAAZ,CACH,CAFS,CAEP,CAFO,CAAV,CAGH,CAED,GAAIY,QAAQ,GAAKR,UAAjB,CAA6B,CACzBK,KAAK,CAACM,GAAN,GACAN,KAAK,CAACO,KAAN,GACA,SAAOP,KAAP,EACH,CAED,GAAIG,QAAQ,GAAKT,SAAjB,CAA4B,CACxBO,IAAI,CAACO,OAAL,CAAaL,QAAb,EACAD,OAAO,CAACC,QAAD,CAAP,CAAoB,CAApB,CACAC,UAAU,CAAC,UAAM,CACbP,YAAY,CAAC,SAAAQ,SAAS,wCAAUA,SAAV,wBAAsBF,QAAtB,CAAiC,CAACZ,eAAe,CAAC,SAAD,CAAhB,CAA6BA,eAAe,CAAC,MAAD,CAA5C,CAAjC,IAAV,CAAZ,CACH,CAFS,CAEP,CAFO,CAAV,CAGH,CAED,GAAMkB,CAAAA,UAAU,CAAGjB,iBAAiB,CAACW,QAAD,CAAWL,IAAX,CAAiBC,IAAjB,CAAuBH,SAAvB,CAApC,CACA,GAAIc,CAAAA,uBAAuB,CAAG,KAA9B,CA5B2E,yCA6BnDD,UA7BmD,YA6B3E,+CAAoC,IAAzBE,CAAAA,SAAyB,aAChC,GAAIA,SAAS,GAAIT,CAAAA,OAAjB,CAA0B,CACtB,SACH,CAEDF,KAAK,CAACQ,OAAN,CAAcG,SAAd,EACAD,uBAAuB,CAAG,IAA1B,CACA,MACH,CArC0E,qDAuC3E,GAAI,CAACA,uBAAL,CAA8B,CAC1BV,KAAK,CAACY,MAAN,CAAa,CAAb,CAAgB,CAAhB,EACH,CAzC0E,EAK/E,MAAOZ,KAAK,CAACa,MAAN,CAAe,CAAtB,CAAyB,0DAqCxB,CAED,MAAO,EAAP,CACH,CA7CM","sourcesContent":["import { getNodeTypeEnum, getNeighbourNodes } from '../../utils/util.js'\n\nexport const dfs = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n    const stack = [startCord];\n    const path = [];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [getNodeTypeEnum('visiting'), getNodeTypeEnum('none')] }));\n            }, 1);\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            path.unshift(currCord);\n            visited[currCord] = 1;\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [getNodeTypeEnum('visited'), getNodeTypeEnum('none')] }));\n            }, 1);\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}