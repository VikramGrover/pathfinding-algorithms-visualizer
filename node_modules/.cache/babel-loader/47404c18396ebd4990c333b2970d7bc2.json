{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (var y = 0; y < cols; y++) {\n    const currCord = `${0}:${y}`;\n    setWall(currCord, startCord, targetCord, gridState);\n    await sleep(timeout);\n  }\n\n  for (var y = 0; y < rows; y++) {\n    const currCord = `${y}:${cols - 1}`;\n    setWall(currCord, startCord, targetCord, gridState);\n    await sleep(timeout);\n  }\n\n  for (var y = 0; y < cols; y++) {\n    const currCord = `${rows - 1}:${y}`;\n    setWall(currCord, startCord, targetCord, gridState);\n    await sleep(timeout);\n  }\n\n  for (var y = rows - 2; y > 0; y--) {\n    const currCord = `${y}:${0}`;\n    setWall(currCord, startCord, targetCord, gridState);\n    await sleep(timeout);\n  } // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n\n\n  await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n  const width = endCol - startCol + 1;\n  const height = endRow - startRow + 1;\n  let orientation = HORIZONTAL;\n\n  if (width < height) {\n    orientation = HORIZONTAL;\n  } else if (height < width) {\n    orientation = VERTICAL;\n  } else {\n    orientation = getRandomNum(HORIZONTAL, VERTICAL);\n  }\n\n  if (orientation === HORIZONTAL) {\n    // cutting horizontally\n    if (height < 3 || startRow % 2 === 1 && height === 3) {\n      return;\n    }\n\n    let sCol = startCol;\n\n    if (startCol % 2 === 1) {\n      sCol += 1;\n    }\n\n    let sRow = startRow + 2;\n\n    if (startRow % 2 === 0) {\n      sRow = startRow + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n    let randRow = getRandomNum(sRow, endRow - 2);\n    randRow = Math.floor(randRow / 2) * 2 + 1;\n\n    for (let i = startCol; i <= endCol; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${randRow}:${i}`;\n      const nodeStateFunc = gridState[currCord][1];\n      let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n      } else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n      }\n\n      nodeStateFunc(prevState => state);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [state, prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n  } else if (orientation === VERTICAL) {\n    // divide vertically \n    if (width < 3 || startCol % 2 === 1 && width === 3) {\n      return;\n    }\n\n    let sRow = startRow;\n\n    if (startRow % 2 === 1) {\n      sRow += 1;\n    }\n\n    let sCol = startCol + 2;\n\n    if (startCol % 2 === 0) {\n      sCol = startCol + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n    let randCol = getRandomNum(sCol, endCol - 2);\n    randCol = Math.floor(randCol / 2) * 2 + 1;\n\n    for (let i = startRow; i <= endRow; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${i}:${randCol}`;\n      const nodeStateFunc = gridState[currCord][1];\n      let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n      } else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n      }\n\n      nodeStateFunc(prevState => state);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [state, prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n  }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState) => {\n  const nodeStateFunc = gridState[currCord][1];\n  let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n  if (currCord === startCord) {\n    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n  } else if (currCord === targetCord) {\n    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n  }\n\n  nodeStateFunc(prevState => state);\n  setGridState(prevState => ({ ...prevState,\n    [currCord]: [state, prevState[currCord][1]]\n  }));\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","y","currCord","setWall","divide","startRow","endRow","startCol","endCol","width","height","orientation","sCol","sRow","skip","Math","floor","randRow","i","nodeStateFunc","state","wall","none","start","target","prevState","randCol"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n\n    // make border around the screen\n    for (var y = 0; y < cols; y++) {\n        const currCord = `${0}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState);\n        await sleep(timeout);\n    }\n\n    for (var y = 0; y < rows; y++) {\n        const currCord = `${y}:${cols - 1}`;\n        setWall(currCord, startCord, targetCord, gridState);\n        await sleep(timeout);\n    }\n\n    for (var y = 0; y < cols; y++) {\n        const currCord = `${rows - 1}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState);\n        await sleep(timeout);\n    }\n\n    for (var y = rows - 2; y > 0; y--) {\n        const currCord = `${y}:${0}`;\n        setWall(currCord, startCord, targetCord, gridState);\n        await sleep(timeout);\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState) => {\n    const nodeStateFunc = gridState[currCord][1];\n\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n    if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n    else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n};"]},"metadata":{},"sourceType":"module"}