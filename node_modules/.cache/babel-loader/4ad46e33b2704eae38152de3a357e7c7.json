{"ast":null,"code":"import { getNeighbourNodes, createPath, sleep } from '../../utils/helper.js';\nimport { nodeTypeEnum } from '../../utils/constants.js';\nexport const bfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n  let queue = [startCord];\n  let visited = {\n    [startCord]: 1\n  };\n  let prevNodes = {};\n\n  while (queue.length > 0) {\n    const currCord = queue.pop();\n\n    if (currCord !== startCord && currCord !== targetCord) {\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.visited, nodeTypeEnum.none]);\n    }\n\n    const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n    for (const neighbour of neighbours) {\n      if (neighbour in visited) {\n        continue;\n      }\n\n      prevNodes[neighbour] = currCord;\n      queue.unshift(neighbour);\n      visited[neighbour] = 1;\n\n      if (neighbour === targetCord) {\n        return createPath(startCord, targetCord, prevNodes);\n      }\n\n      const nodeStateFunc = gridState[neighbour][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.visiting, nodeTypeEnum.none]);\n    }\n\n    await sleep(timeout);\n  }\n\n  return [];\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bfs.js"],"names":["getNeighbourNodes","createPath","sleep","nodeTypeEnum","bfs","startCord","targetCord","gridState","rows","cols","timeout","queue","visited","prevNodes","length","currCord","pop","nodeStateFunc","prevState","none","neighbours","neighbour","unshift","visiting"],"mappings":"AAAA,SAASA,iBAAT,EAA4BC,UAA5B,EAAwCC,KAAxC,QAAqD,uBAArD;AACA,SAASC,YAAT,QAA6B,0BAA7B;AAEA,OAAO,MAAMC,GAAG,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,IAAzC,EAA+CC,IAA/C,EAAqDC,OAArD,KAAiE;AAChF,MAAIC,KAAK,GAAG,CAACN,SAAD,CAAZ;AACA,MAAIO,OAAO,GAAG;AAAE,KAACP,SAAD,GAAa;AAAf,GAAd;AACA,MAAIQ,SAAS,GAAG,EAAhB;;AAEA,SAAOF,KAAK,CAACG,MAAN,GAAe,CAAtB,EAAyB;AACrB,UAAMC,QAAQ,GAAGJ,KAAK,CAACK,GAAN,EAAjB;;AACA,QAAID,QAAQ,KAAKV,SAAb,IAA0BU,QAAQ,KAAKT,UAA3C,EAAuD;AACnD,YAAMW,aAAa,GAAGV,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACAE,MAAAA,aAAa,CAACC,SAAS,IAAK,CAACf,YAAY,CAACS,OAAd,EAAuBT,YAAY,CAACgB,IAApC,CAAf,CAAb;AACH;;AACD,UAAMC,UAAU,GAAGpB,iBAAiB,CAACe,QAAD,EAAWP,IAAX,EAAiBC,IAAjB,EAAuBF,SAAvB,CAApC;;AAEA,SAAK,MAAMc,SAAX,IAAwBD,UAAxB,EAAoC;AAChC,UAAIC,SAAS,IAAIT,OAAjB,EAA0B;AACtB;AACH;;AAEDC,MAAAA,SAAS,CAACQ,SAAD,CAAT,GAAuBN,QAAvB;AACAJ,MAAAA,KAAK,CAACW,OAAN,CAAcD,SAAd;AACAT,MAAAA,OAAO,CAACS,SAAD,CAAP,GAAqB,CAArB;;AAEA,UAAIA,SAAS,KAAKf,UAAlB,EAA8B;AAC1B,eAAOL,UAAU,CAACI,SAAD,EAAYC,UAAZ,EAAwBO,SAAxB,CAAjB;AACH;;AAED,YAAMI,aAAa,GAAGV,SAAS,CAACc,SAAD,CAAT,CAAqB,CAArB,CAAtB;AACAJ,MAAAA,aAAa,CAACC,SAAS,IAAK,CAACf,YAAY,CAACoB,QAAd,EAAwBpB,YAAY,CAACgB,IAArC,CAAf,CAAb;AACH;;AAED,UAAMjB,KAAK,CAACQ,OAAD,CAAX;AACH;;AAED,SAAO,EAAP;AACH,CAlCM","sourcesContent":["import { getNeighbourNodes, createPath, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            const nodeStateFunc = gridState[neighbour][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n"]},"metadata":{},"sourceType":"module"}