{"ast":null,"code":"import { nodeTypeEnum } from \"../../utils/constants\";\nimport { sleep } from \"../../utils/helper\";\n\nfunction Grad(x, y, z) {\n  this.x = x;\n  this.y = y;\n  this.z = z;\n}\n\n_c = Grad;\n\nGrad.prototype.dot2 = function (x, y) {\n  return this.x * x + this.y * y;\n};\n\nGrad.prototype.dot3 = function (x, y, z) {\n  return this.x * x + this.y * y + this.z * z;\n};\n\nconst grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\nconst p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; // To remove the need for index wrapping, double the permutation table length\n\nvar perm = new Array(512);\nvar gradP = new Array(512); // This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\n\nconst seed = seed => {\n  if (seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 65536;\n  }\n\n  seed = Math.floor(seed);\n\n  if (seed < 256) {\n    seed |= seed << 8;\n  }\n\n  for (var i = 0; i < 256; i++) {\n    var v;\n\n    if (i & 1) {\n      v = p[i] ^ seed & 255;\n    } else {\n      v = p[i] ^ seed >> 8 & 255;\n    }\n\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n}; // Skewing and unskewing factors for 2, 3, and 4 dimensions\n\n\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6; // 2D simplex noise\n\nconst simplex2 = (xin, yin) => {\n  var n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin) * F2; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var t = (i + j) * G2;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t; // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n  if (x0 > y0) {\n    // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1 = 1;\n    j1 = 0;\n  } else {\n    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1 = 0;\n    j1 = 1;\n  } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n\n\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n\n  var y2 = y0 - 1 + 2 * G2; // Work out the hashed gradient indices of the three simplex corners\n\n  i &= 255;\n  j &= 255;\n  var gi0 = gradP[i + perm[j]];\n  var gi1 = gradP[i + i1 + perm[j + j1]];\n  var gi2 = gradP[i + 1 + perm[j + 1]]; // Calculate the contribution from the three corners\n\n  var t0 = 0.5 - x0 * x0 - y0 * y0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.5 - x1 * x1 - y1 * y1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n\n  var t2 = 0.5 - x2 * x2 - y2 * y2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 70 * (n0 + n1 + n2);\n};\n\nexport const perlinNoise = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  seed(Math.random());\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      // All noise functions return values in the range of -1 to 1.\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1]; // noise.simplex2 and noise.perlin2 for 2d noise\n\n      let value = simplex2(x / 100, y / 100);\n      const state = [nodeTypeEnum.none];\n\n      if (value >= -1 && value <= -0.66) {\n        state.unshift(nodeTypeEnum.wall);\n      } else if (value > -0.66 && value <= -0.33) {\n        state.unshift(nodeTypeEnum.weighted100);\n      } else if (value > -0.33 && value <= 0) {\n        state.unshift(nodeTypeEnum.weighted80);\n      } else if (value > 0 && value <= 0.33) {\n        state = nodeTypeEnum.weighted60;\n      } else if (value > 0.33 && value <= 0.66) {\n        state = nodeTypeEnum.weighted40;\n      } else if (value > 0.66 && value <= 1) {\n        state = nodeTypeEnum.weighted20;\n      }\n\n      nodeStateFunc(prevState => [obstacle, nodeTypeEnum.none]);\n      await sleep(timeout);\n    }\n  }\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"Grad\");","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/perlin.js"],"names":["nodeTypeEnum","sleep","Grad","x","y","z","prototype","dot2","dot3","grad3","p","perm","Array","gradP","seed","Math","floor","i","v","F2","sqrt","G2","simplex2","xin","yin","n0","n1","n2","s","j","t","x0","y0","i1","j1","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","perlinNoise","startCord","targetCord","gridState","setGridState","rows","cols","timeout","random","currCord","nodeStateFunc","value","state","none","unshift","wall","weighted100","weighted80","weighted60","weighted40","weighted20","prevState","obstacle"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from \"../../utils/constants\";\nimport { sleep } from \"../../utils/helper\";\n\nfunction Grad(x, y, z) {\n    this.x = x; this.y = y; this.z = z;\n}\n\nGrad.prototype.dot2 = function (x, y) {\n    return this.x * x + this.y * y;\n};\n\nGrad.prototype.dot3 = function (x, y, z) {\n    return this.x * x + this.y * y + this.z * z;\n};\n\nconst grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\nnew Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\nnew Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n\nconst p = [151, 160, 137, 91, 90, 15,\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\n\n// To remove the need for index wrapping, double the permutation table length\nvar perm = new Array(512);\nvar gradP = new Array(512);\n\n// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nconst seed = (seed) => {\n    if (seed > 0 && seed < 1) {\n        // Scale the seed out\n        seed *= 65536;\n    }\n\n    seed = Math.floor(seed);\n    if (seed < 256) {\n        seed |= seed << 8;\n    }\n\n    for (var i = 0; i < 256; i++) {\n        var v;\n        if (i & 1) {\n            v = p[i] ^ (seed & 255);\n        } else {\n            v = p[i] ^ ((seed >> 8) & 255);\n        }\n\n        perm[i] = perm[i + 256] = v;\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n};\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\n// 2D simplex noise\nconst simplex2 = (xin, yin) => {\n    var n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin + yin) * F2; // Hairy factor for 2D\n    var i = Math.floor(xin + s);\n    var j = Math.floor(yin + s);\n    var t = (i + j) * G2;\n    var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin - j + t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        i1 = 1; j1 = 0;\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        i1 = 0; j1 = 1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    var y1 = y0 - j1 + G2;\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    var y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n    var gi0 = gradP[i + perm[j]];\n    var gi1 = gradP[i + i1 + perm[j + j1]];\n    var gi2 = gradP[i + 1 + perm[j + 1]];\n    // Calculate the contribution from the three corners\n    var t0 = 0.5 - x0 * x0 - y0 * y0;\n    if (t0 < 0) {\n        n0 = 0;\n    } else {\n        t0 *= t0;\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 < 0) {\n        n1 = 0;\n    } else {\n        t1 *= t1;\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    var t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 < 0) {\n        n2 = 0;\n    } else {\n        t2 *= t2;\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n};\n\nexport const perlinNoise = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    seed(Math.random());\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            // All noise functions return values in the range of -1 to 1.\n            const currCord = `${x}:${y}`;\n\n            const nodeStateFunc = gridState[currCord][1];\n\n            // noise.simplex2 and noise.perlin2 for 2d noise\n            let value = simplex2(x / 100, y / 100);\n            const state = [nodeTypeEnum.none];\n\n            if (value >= -1 && value <= -0.66) {\n                state.unshift(nodeTypeEnum.wall);\n            }\n            else if (value > -0.66 && value <= -0.33) {\n                state.unshift(nodeTypeEnum.weighted100);\n            }\n            else if (value > -0.33 && value <= 0) {\n                state.unshift(nodeTypeEnum.weighted80);\n            }\n            else if (value > 0 && value <= 0.33) {\n                state = nodeTypeEnum.weighted60;\n            }\n            else if (value > 0.33 && value <= 0.66) {\n                state = nodeTypeEnum.weighted40;\n            }\n            else if (value > 0.66 && value <= 1) {\n                state = nodeTypeEnum.weighted20;\n            }\n\n            nodeStateFunc(prevState => [obstacle, nodeTypeEnum.none]);\n            await sleep(timeout);\n        }\n    }\n};"]},"metadata":{},"sourceType":"module"}