{"ast":null,"code":"// pathfinding algorithm constants\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = \"A*\";\nconst BFS = \"BFS\";\nconst DFS = \"DFS\";\nexport { DIJKSTRAS, ASTAR, BFS, DFS };\nconst pathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS];\nconst unweightedPathAlgos = [DFS, BFS];\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\nexport { pathAlgos, unweightedPathAlgos, optimalPathAlgos }; // terrain algorithm constants\n\nconst ALGO1 = \"ALGO 1\";\nconst ALGO2 = \"ALGO 2\";\nconst terrainAlgos = [ALGO1, ALGO2];\nexport { ALGO1, ALGO2, terrainAlgos }; // NODE TYPES \n\nconst nodeTypeEnum = {\n  'path': 0,\n  'visited': 1,\n  'visiting': 2,\n  'none': 3,\n  'target': 4,\n  'start': 5,\n  'remObstacle': 6,\n  'wall': 7,\n  'weighted100': 8,\n  'weighted80': 9,\n  'weighted60': 10,\n  'weighted40': 11,\n  'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\nexport { nodeTypeEnum };\nconst nodeColorClass = {\n  [nodeTypeEnum.none]: 'none',\n  [nodeTypeEnum.target]: 'target',\n  [nodeTypeEnum.wall]: 'wall',\n  [nodeTypeEnum.visiting]: 'visiting',\n  [nodeTypeEnum.start]: 'start',\n  [nodeTypeEnum.visited]: 'visited',\n  [nodeTypeEnum.path]: 'path',\n  [nodeTypeEnum.weighted100]: 'weighted100',\n  [nodeTypeEnum.weighted80]: 'weighted80',\n  [nodeTypeEnum.weighted60]: 'weighted60',\n  [nodeTypeEnum.weighted40]: 'weighted40',\n  [nodeTypeEnum.weighted20]: 'weighted20'\n};\nObject.freeze(nodeColorClass);\nexport { nodeColorClass };\nconst nodeWeight = {\n  [nodeTypeEnum.none]: 1,\n  [nodeTypeEnum.target]: 1,\n  [nodeTypeEnum.wall]: Infinity,\n  [nodeTypeEnum.start]: 1,\n  [nodeTypeEnum.weighted100]: 100,\n  [nodeTypeEnum.weighted80]: 80,\n  [nodeTypeEnum.weighted60]: 60,\n  [nodeTypeEnum.weighted40]: 40,\n  [nodeTypeEnum.weighted20]: 20\n};\nObject.freeze(nodeWeight);\nexport { nodeWeight }; // OBSTACLE TYPES\n\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n  [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n  [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n  [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n  [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n  [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n  [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n};\nObject.freeze(obsEnum);\nexport { obstacleTypes, obsEnum };\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};\nexport const createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\nexport const findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\nexport const isAlgoUnweighted = algo => {\n  return unweightedPathAlgos.includes(algo);\n};\nexport const isAlgoOptimal = algo => {\n  return optimalPathAlgos.includes(algo);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/util.js"],"names":["DIJKSTRAS","ASTAR","BFS","DFS","pathAlgos","unweightedPathAlgos","optimalPathAlgos","ALGO1","ALGO2","terrainAlgos","nodeTypeEnum","Object","freeze","nodeColorClass","none","target","wall","visiting","start","visited","path","weighted100","weighted80","weighted60","weighted40","weighted20","nodeWeight","Infinity","obstacleTypes","obsEnum","getNeighbourNodes","node","rows","cols","gridState","row","parseInt","split","col","res","push","createPath","startCord","targetCord","prevNodes","cord","findMinPriorityNode","minPQ","minPriority","Math","min","values","key","isAlgoUnweighted","algo","includes","isAlgoOptimal"],"mappings":"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","sourcesContent":["// pathfinding algorithm constants\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = \"A*\";\nconst BFS = \"BFS\";\nconst DFS = \"DFS\";\n\nexport { DIJKSTRAS, ASTAR, BFS, DFS };\n\nconst pathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS];\nconst unweightedPathAlgos = [DFS, BFS];\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\n\nexport { pathAlgos, unweightedPathAlgos, optimalPathAlgos };\n\n// terrain algorithm constants\nconst ALGO1 = \"ALGO 1\";\nconst ALGO2 = \"ALGO 2\";\nconst terrainAlgos = [ALGO1, ALGO2];\n\nexport { ALGO1, ALGO2, terrainAlgos };\n\n// NODE TYPES \nconst nodeTypeEnum = {\n    'path': 0,\n    'visited': 1,\n    'visiting': 2,\n    'none': 3,\n    'target': 4,\n    'start': 5,\n    'remObstacle': 6,\n    'wall': 7,\n    'weighted100': 8,\n    'weighted80': 9,\n    'weighted60': 10,\n    'weighted40': 11,\n    'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\n\nexport { nodeTypeEnum };\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'none',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.wall]: 'wall',\n    [nodeTypeEnum.visiting]: 'visiting',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path',\n    [nodeTypeEnum.weighted100]: 'weighted100',\n    [nodeTypeEnum.weighted80]: 'weighted80',\n    [nodeTypeEnum.weighted60]: 'weighted60',\n    [nodeTypeEnum.weighted40]: 'weighted40',\n    [nodeTypeEnum.weighted20]: 'weighted20'\n}\nObject.freeze(nodeColorClass);\n\nexport { nodeColorClass };\n\nconst nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.wall]: Infinity,\n    [nodeTypeEnum.start]: 1,\n    [nodeTypeEnum.weighted100]: 100,\n    [nodeTypeEnum.weighted80]: 80,\n    [nodeTypeEnum.weighted60]: 60,\n    [nodeTypeEnum.weighted40]: 40,\n    [nodeTypeEnum.weighted20]: 20\n}\nObject.freeze(nodeWeight);\nexport { nodeWeight };\n\n// OBSTACLE TYPES\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n    [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n    [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n    [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n    [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n    [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n    [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n}\nObject.freeze(obsEnum);\nexport { obstacleTypes, obsEnum };\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n"]},"metadata":{},"sourceType":"module"}