{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (var x = 0; x < rows; x++) {\n    for (var y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n\n      if (x === 0 || x === rows - 1 || y === 0 || y === cols - 1) {\n        await sleep(timeout);\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n        if (currCord === startCord) {\n          state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        } else if (currCord === targetCord) {\n          state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n        setGridState(prevState => ({ ...prevState,\n          [currCord]: [state, prevState[currCord][1]]\n        }));\n      }\n    }\n  } // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n\n\n  await divide(startCord, targetCord, gridState, setGridState, 1, rows - 1, 1, cols - 1, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n  const width = endCol - startCol;\n  const height = endRow - startRow;\n  let orientation = HORIZONTAL;\n\n  if (width < height) {\n    orientation = HORIZONTAL;\n  } else if (height >= width) {\n    orientation = VERTICAL;\n  }\n\n  if (orientation === HORIZONTAL) {\n    // cutting horizontally\n    if (height < 3) {\n      return;\n    }\n\n    const skip = Math.floor(getRandomNum(startCol + 1, endCol) / 2) * 2;\n    let randRow = getRandomNum(startRow + 1, endRow - 3);\n    randRow = Math.floor(randRow / 2) * 2 + 1;\n\n    for (let i = startCol; i <= endCol; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${randRow}:${i}`;\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    if (randRow - 1 > 0) {\n      await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n    }\n\n    if (randRow + 1 < rows) {\n      await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n  } else if (orientation === VERTICAL) {\n    // divide vertically \n    if (width < 3) {\n      return;\n    }\n\n    const skip = Math.floor(getRandomNum(startRow + 1, endRow) / 2) * 2;\n    let randCol = getRandomNum(startCol + 1, endCol - 3);\n    randCol = Math.floor(randCol / 2) * 2 + 1;\n\n    for (let i = startRow; i <= endRow; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${i}:${randCol}`;\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    if (randCol - 1 > 0) {\n      await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n    }\n\n    if (randCol + 1 < cols) {\n      await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n  }\n}; // const divide = async (x, y, height, width, gridState, setGridState, timeout) => {\n//     let orientation = HORIZONTAL; // horizontal\n//     let newWall = 0;\n//     let newGap = 0;\n//     let newHeight = 0;\n//     let newWidth = 0;\n//     let yPair = 0;\n//     let xPair = 0;\n//     let newHeightPair = 0;\n//     let newWidthPair = 0;\n//     if (width < height) {\n//         orientation = HORIZONTAL;\n//     }\n//     else if (height > width) {\n//         orientation = VERTICAL;\n//     }\n//     else {\n//         orientation = getRandomNum(HORIZONTAL, VERTICAL);\n//     }\n//     if (orientation === HORIZONTAL) {\n//         // cutting horizontally\n//         if (height < 5) {\n//             return;\n//         }\n//         let randomWall = getRandomNum(2, height - 3);\n//         let randomGap = getRandomNum(1, width - 2);\n//         newWall = y + Math.floor(randomWall / 2) * 2; // make sure the wall is on an odd co-ordinate\n//         newGap = x + (Math.floor(randomGap / 2) * 2) + 1; // make sure the gap is on an even co-ordinate\n//         for (let i = x; i < (x + width - 1); i++) {\n//             if (i === newGap) {\n//                 continue;\n//             }\n//             const currCord = `${newWall}:${i}`;\n//             console.log(\"currCord:\", currCord, \", y :\", y);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n//         newHeight = newWall - y + 1;\n//         newWidth = width\n//         yPair = newWall;\n//         xPair = x;\n//         newHeightPair = y + height - newWall;\n//         newWidthPair = width;\n//     }\n//     else if (orientation === VERTICAL) {\n//         // cutting vertically\n//         if (width < 5) {\n//             return;\n//         }\n//         let randomWall = getRandomNum(2, width - 3);\n//         let randomGap = getRandomNum(1, height - 2);\n//         newWall = x + Math.floor(randomWall / 2) * 2; // make sure the wall is on an even co-ordinate\n//         newGap = y + (Math.floor(randomGap / 2) * 2) + 1; // make sure the gap is on an odd co-ordinate\n//         for (let i = y; i < (y + height - 1); i++) {\n//             if (i === newGap) {\n//                 continue;\n//             }\n//             const currCord = `${i}:${newWall}`;\n//             console.log(\"currCord:\", currCord, \", x :\", x);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n//         newHeight = height;\n//         newWidth = newWall - x + 1;\n//         yPair = y;\n//         xPair = newWall;\n//         newHeightPair = height;\n//         newWidthPair = x + width - newWall;\n//     }\n//     await divide(y, x, newHeight, newWidth, gridState, setGridState, timeout);\n//     await divide(yPair, xPair, newHeightPair, newWidthPair, gridState, setGridState, timeout);\n// };","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","x","y","currCord","nodeStateFunc","state","wall","none","start","target","prevState","divide","startRow","endRow","startCol","endCol","width","height","orientation","skip","Math","floor","randRow","i","randCol"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (var x = 0; x < rows; x++) {\n        for (var y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            if (x === 0 || x === (rows - 1) || y === 0 || y === (cols - 1)) {\n                await sleep(timeout);\n                let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n                if (currCord === startCord) {\n                    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                else if (currCord === targetCord) {\n                    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                nodeStateFunc(prevState => state);\n                setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            }\n        }\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 1, 1, cols - 1, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol;\n    const height = endRow - startRow;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height >= width) {\n        orientation = VERTICAL;\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3) {\n            return;\n        }\n        const skip = Math.floor(getRandomNum(startCol + 1, endCol) / 2) * 2;\n        let randRow = getRandomNum(startRow + 1, endRow - 3);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        if (randRow - 1 > 0) {\n            await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        }\n        if ((randRow + 1) < rows) {\n            await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n        }\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3) {\n            return;\n        }\n        const skip = Math.floor(getRandomNum(startRow + 1, endRow) / 2) * 2;\n        let randCol = getRandomNum(startCol + 1, endCol - 3);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        if (randCol - 1 > 0) {\n            await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n        }\n        if (randCol + 1 < cols) {\n            await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n        }\n    }\n};\n\n// const divide = async (x, y, height, width, gridState, setGridState, timeout) => {\n//     let orientation = HORIZONTAL; // horizontal\n//     let newWall = 0;\n//     let newGap = 0;\n//     let newHeight = 0;\n//     let newWidth = 0;\n//     let yPair = 0;\n//     let xPair = 0;\n//     let newHeightPair = 0;\n//     let newWidthPair = 0;\n\n//     if (width < height) {\n//         orientation = HORIZONTAL;\n//     }\n//     else if (height > width) {\n//         orientation = VERTICAL;\n//     }\n//     else {\n//         orientation = getRandomNum(HORIZONTAL, VERTICAL);\n//     }\n\n//     if (orientation === HORIZONTAL) {\n//         // cutting horizontally\n//         if (height < 5) {\n//             return;\n//         }\n\n//         let randomWall = getRandomNum(2, height - 3);\n//         let randomGap = getRandomNum(1, width - 2);\n\n//         newWall = y + Math.floor(randomWall / 2) * 2; // make sure the wall is on an odd co-ordinate\n//         newGap = x + (Math.floor(randomGap / 2) * 2) + 1; // make sure the gap is on an even co-ordinate\n\n//         for (let i = x; i < (x + width - 1); i++) {\n//             if (i === newGap) {\n//                 continue;\n//             }\n//             const currCord = `${newWall}:${i}`;\n//             console.log(\"currCord:\", currCord, \", y :\", y);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n\n//         newHeight = newWall - y + 1;\n//         newWidth = width\n\n//         yPair = newWall;\n//         xPair = x;\n//         newHeightPair = y + height - newWall;\n//         newWidthPair = width;\n//     }\n//     else if (orientation === VERTICAL) {\n//         // cutting vertically\n//         if (width < 5) {\n//             return;\n//         }\n\n//         let randomWall = getRandomNum(2, width - 3);\n//         let randomGap = getRandomNum(1, height - 2);\n\n//         newWall = x + Math.floor(randomWall / 2) * 2; // make sure the wall is on an even co-ordinate\n//         newGap = y + (Math.floor(randomGap / 2) * 2) + 1; // make sure the gap is on an odd co-ordinate\n\n//         for (let i = y; i < (y + height - 1); i++) {\n//             if (i === newGap) {\n//                 continue;\n//             }\n\n//             const currCord = `${i}:${newWall}`;\n//             console.log(\"currCord:\", currCord, \", x :\", x);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n\n//         newHeight = height;\n//         newWidth = newWall - x + 1;\n\n//         yPair = y;\n//         xPair = newWall;\n//         newHeightPair = height;\n//         newWidthPair = x + width - newWall;\n//     }\n\n//     await divide(y, x, newHeight, newWidth, gridState, setGridState, timeout);\n//     await divide(yPair, xPair, newHeightPair, newWidthPair, gridState, setGridState, timeout);\n// };"]},"metadata":{},"sourceType":"module"}