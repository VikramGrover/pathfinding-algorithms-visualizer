{"ast":null,"code":"import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors } from './constants.js';\nexport const getNodeColor = nodeState => {\n  if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting || nodeState[0] === nodeTypeEnum.path) && nodeState[1] > nodeTypeEnum.wall) {\n    let colorA = nodeColors[nodeState[0]];\n    const colorB = nodeColors[nodeState[1]];\n    let amount = 0.85;\n\n    if (nodeState[0] === nodeTypeEnum.visiting) {\n      colorA = nodeColors[nodeTypeEnum.visited];\n    } // we need to mix colors\n\n\n    const [rA, gA, bA] = colorA.match(/\\w\\w/g).map(c => parseInt(c, 16));\n    const [rB, gB, bB] = colorB.match(/\\w\\w/g).map(c => parseInt(c, 16));\n    const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n    const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n    const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n    return '#' + r + g + b;\n  }\n\n  return nodeColors[nodeState[0]];\n};\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};\nexport const createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\nexport const findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\nexport const isAlgoUnweighted = algo => {\n  return unweightedPathAlgos.includes(algo);\n};\nexport const isAlgoOptimal = algo => {\n  return optimalPathAlgos.includes(algo);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/helper.js"],"names":["nodeTypeEnum","unweightedPathAlgos","optimalPathAlgos","nodeColors","getNodeColor","nodeState","visited","visiting","path","wall","colorA","colorB","amount","rA","gA","bA","match","map","c","parseInt","rB","gB","bB","r","Math","round","toString","padStart","g","b","getNeighbourNodes","node","rows","cols","gridState","row","split","col","res","push","createPath","startCord","targetCord","prevNodes","cord","findMinPriorityNode","minPQ","minPriority","min","Object","values","key","isAlgoUnweighted","algo","includes","isAlgoOptimal"],"mappings":"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","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors } from './constants.js'\n\nexport const getNodeColor = (nodeState) => {\n    if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting || nodeState[0] === nodeTypeEnum.path) && nodeState[1] > nodeTypeEnum.wall) {\n        let colorA = nodeColors[nodeState[0]];\n        const colorB = nodeColors[nodeState[1]];\n        let amount = 0.85;\n\n        if (nodeState[0] === nodeTypeEnum.visiting) {\n            colorA = nodeColors[nodeTypeEnum.visited];\n        }\n        // we need to mix colors\n        const [rA, gA, bA] = colorA.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const [rB, gB, bB] = colorB.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n        const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n        const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n        return '#' + r + g + b;\n    }\n\n    return nodeColors[nodeState[0]];\n};\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n"]},"metadata":{},"sourceType":"module"}