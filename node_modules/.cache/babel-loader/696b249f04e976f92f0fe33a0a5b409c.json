{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep } from '../../utils/helper.js';\nexport const recursiveDivision = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (var x = 0; x < rows; x++) {\n    for (var y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n\n      if (x === 0 || x === rows - 1 || y === 0 || y === cols - 1) {\n        await sleep(timeout);\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n        if (currCord === startCord) {\n          state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        } else if (currCord === targetCord) {\n          state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n      }\n    }\n  }\n\n  await divideScreen(startCord, targetCord, gridState, 1, rows - 1, 1, cols - 1, timeout, 1);\n};\n\nconst divideScreen = async (startCord, targetCord, gridState, startRow, endRow, startCol, endCol, timeout, direction) => {\n  if (startRow === endRow || startCol === endCol) {\n    return;\n  }\n\n  if (direction === 1) {\n    // divide horizontally\n    const skip = Math.floor(Math.random() * endCol + startCol);\n    const halfRow = startRow + (startRow + endRow) / 2;\n\n    for (let i = startCol; i < endCol; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${halfRow}:${i}`;\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n      await sleep(timeout);\n    }\n\n    await divideScreen(startCord, targetCord, gridState, startRow, halfRow - 1, startCol, endCol, timeout, 0);\n    await divideScreen(startCord, targetCord, gridState, halfRow + 1, endRow, startCol, endCol, timeout, 0);\n  } else {\n    // divide vertically \n    const skip = Math.floor(Math.random() * endRow + startRow);\n    const halfCol = startCol + (startCol + endCol) / 2;\n\n    for (let i = startRow; i < endRow; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${i}:${halfCol}`;\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n      await sleep(timeout);\n    }\n\n    await divideScreen(startCord, targetCord, gridState, startRow, endRow, startCol, halfCol - 1, timeout, 1);\n    await divideScreen(startCord, targetCord, gridState, startRow, endRow, halfCol + 1, endCol, timeout, 1);\n  }\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","recursiveDivision","startCord","targetCord","gridState","rows","cols","timeout","x","y","currCord","nodeStateFunc","state","wall","none","start","target","prevState","divideScreen","startRow","endRow","startCol","endCol","direction","skip","Math","floor","random","halfRow","i","halfCol"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep } from '../../utils/helper.js'\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (var x = 0; x < rows; x++) {\n        for (var y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            if (x === 0 || x === (rows - 1) || y === 0 || y === (cols - 1)) {\n                await sleep(timeout);\n                let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n                if (currCord === startCord) {\n                    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                else if (currCord === targetCord) {\n                    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                nodeStateFunc(prevState => state);\n            }\n        }\n    }\n\n    await divideScreen(startCord, targetCord, gridState, 1, rows - 1, 1, cols - 1, timeout, 1);\n};\n\nconst divideScreen = async (startCord, targetCord, gridState, startRow, endRow, startCol, endCol, timeout, direction) => {\n    if (startRow === endRow || startCol === endCol) {\n        return;\n    }\n\n    if (direction === 1) {\n        // divide horizontally\n        const skip = Math.floor((Math.random() * endCol) + startCol);\n        const halfRow = startRow + ((startRow + endRow) / 2);\n        for (let i = startCol; i < endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${halfRow}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n            await sleep(timeout);\n        }\n\n        await divideScreen(startCord, targetCord, gridState, startRow, halfRow - 1, startCol, endCol, timeout, 0);\n        await divideScreen(startCord, targetCord, gridState, halfRow + 1, endRow, startCol, endCol, timeout, 0);\n    }\n    else {\n        // divide vertically \n        const skip = Math.floor((Math.random() * endRow) + startRow);\n        const halfCol = startCol + ((startCol + endCol) / 2);\n        for (let i = startRow; i < endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${halfCol}`;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n            await sleep(timeout);\n        }\n\n        await divideScreen(startCord, targetCord, gridState, startRow, endRow, startCol, halfCol - 1, timeout, 1);\n        await divideScreen(startCord, targetCord, gridState, startRow, endRow, halfCol + 1, endCol, timeout, 1);\n    }\n};"]},"metadata":{},"sourceType":"module"}