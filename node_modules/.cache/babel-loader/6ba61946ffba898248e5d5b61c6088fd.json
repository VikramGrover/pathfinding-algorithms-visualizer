{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getNeighbourNodes,createPath,sleep}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var bfs=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,rows,cols,timeout){var queue,visited,prevNodes,currCord,nodeStateFunc,neighbours,_iterator,_step,neighbour,_nodeStateFunc;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:queue=[startCord];visited=_defineProperty({},startCord,1);prevNodes={};case 3:if(!(queue.length>0)){_context.next=35;break;}currCord=queue.pop();if(currCord!==startCord&&currCord!==targetCord){nodeStateFunc=gridState[currCord][1];nodeStateFunc(function(prevState){return[nodeTypeEnum.visited,nodeTypeEnum.none];});}neighbours=getNeighbourNodes(currCord,rows,cols,gridState);_iterator=_createForOfIteratorHelper(neighbours);_context.prev=8;_iterator.s();case 10:if((_step=_iterator.n()).done){_context.next=23;break;}neighbour=_step.value;if(!(neighbour in visited)){_context.next=14;break;}return _context.abrupt(\"continue\",21);case 14:prevNodes[neighbour]=currCord;queue.unshift(neighbour);visited[neighbour]=1;if(!(neighbour===targetCord)){_context.next=19;break;}return _context.abrupt(\"return\",createPath(startCord,targetCord,prevNodes));case 19:_nodeStateFunc=gridState[neighbour][1];_nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting,nodeTypeEnum.none];});case 21:_context.next=10;break;case 23:_context.next=28;break;case 25:_context.prev=25;_context.t0=_context[\"catch\"](8);_iterator.e(_context.t0);case 28:_context.prev=28;_iterator.f();return _context.finish(28);case 31:_context.next=33;return sleep(timeout);case 33:_context.next=3;break;case 35:return _context.abrupt(\"return\",[]);case 36:case\"end\":return _context.stop();}}},_callee,null,[[8,25,28,31]]);}));return function bfs(_x,_x2,_x3,_x4,_x5,_x6){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bfs.js"],"names":["getNeighbourNodes","createPath","sleep","nodeTypeEnum","bfs","startCord","targetCord","gridState","rows","cols","timeout","queue","visited","prevNodes","length","currCord","pop","nodeStateFunc","prevState","none","neighbours","neighbour","unshift","visiting"],"mappings":"2wBAAA,OAASA,iBAAT,CAA4BC,UAA5B,CAAwCC,KAAxC,KAAqD,uBAArD,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,GAAG,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,IAAzC,CAA+CC,IAA/C,CAAqDC,OAArD,yNACXC,KADW,CACH,CAACN,SAAD,CADG,CAEXO,OAFW,oBAEEP,SAFF,CAEc,CAFd,EAGXQ,SAHW,CAGC,EAHD,aAKRF,KAAK,CAACG,MAAN,CAAe,CALP,2BAMLC,QANK,CAMMJ,KAAK,CAACK,GAAN,EANN,CAOX,GAAID,QAAQ,GAAKV,SAAb,EAA0BU,QAAQ,GAAKT,UAA3C,CAAuD,CAC7CW,aAD6C,CAC7BV,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAD6B,CAEnDE,aAAa,CAAC,SAAAC,SAAS,QAAK,CAACf,YAAY,CAACS,OAAd,CAAuBT,YAAY,CAACgB,IAApC,CAAL,EAAV,CAAb,CACH,CACKC,UAXK,CAWQpB,iBAAiB,CAACe,QAAD,CAAWP,IAAX,CAAiBC,IAAjB,CAAuBF,SAAvB,CAXzB,sCAaaa,UAbb,+FAaAC,SAbA,kBAcHA,SAAS,GAAIT,CAAAA,OAdV,yEAkBPC,SAAS,CAACQ,SAAD,CAAT,CAAuBN,QAAvB,CACAJ,KAAK,CAACW,OAAN,CAAcD,SAAd,EACAT,OAAO,CAACS,SAAD,CAAP,CAAqB,CAArB,CApBO,KAsBHA,SAAS,GAAKf,UAtBX,2DAuBIL,UAAU,CAACI,SAAD,CAAYC,UAAZ,CAAwBO,SAAxB,CAvBd,UA0BDI,cA1BC,CA0BeV,SAAS,CAACc,SAAD,CAAT,CAAqB,CAArB,CA1Bf,CA2BPJ,cAAa,CAAC,SAAAC,SAAS,QAAK,CAACf,YAAY,CAACoB,QAAd,CAAwBpB,YAAY,CAACgB,IAArC,CAAL,EAAV,CAAb,CA3BO,kPA8BLjB,CAAAA,KAAK,CAACQ,OAAD,CA9BA,uEAiCR,EAjCQ,6EAAH,kBAAHN,CAAAA,GAAG,gEAAT","sourcesContent":["import { getNeighbourNodes, createPath, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            const nodeStateFunc = gridState[neighbour][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n"]},"metadata":{},"sourceType":"module"}