{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nexport const random = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  let gridMap = {};\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n      const randomNum = getRandomNum(1, 10);\n\n      if (randomNum >= 4) {\n        // don't place obstacle\n        let newState = [nodeTypeEnum.none];\n\n        if (currCord === startCord) {\n          newState.unshift(nodeTypeEnum.start);\n        } else if (currCord === targetCord) {\n          newState.unshift(nodeTypeEnum.target);\n        }\n\n        gridMap[currCord] = [newState, nodeStateFunc];\n        continue;\n      } // place wall\n\n\n      const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20);\n      let newState = [randomObstacle, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        newState.unshift(nodeTypeEnum.start);\n      } else if (currCord === targetCord) {\n        newState.unshift(nodeTypeEnum.target);\n      }\n\n      nodeStateFunc(prevState => newState);\n      gridMap[currCord] = [newState, nodeStateFunc];\n    }\n  }\n\n  setGridState(prevState => gridMap);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/random.js"],"names":["nodeTypeEnum","sleep","getRandomNum","random","startCord","targetCord","gridState","setGridState","rows","cols","timeout","gridMap","x","y","currCord","nodeStateFunc","randomNum","newState","none","unshift","start","target","randomObstacle","wall","weighted20","prevState"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,QAAoC,uBAApC;AAEA,OAAO,MAAMC,MAAM,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,YAAzC,EAAuDC,IAAvD,EAA6DC,IAA7D,EAAmEC,OAAnE,KAA+E;AACjG,MAAIC,OAAO,GAAG,EAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,YAAMC,QAAQ,GAAI,GAAEF,CAAE,IAAGC,CAAE,EAA3B;AACA,YAAME,aAAa,GAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACA,YAAME,SAAS,GAAGd,YAAY,CAAC,CAAD,EAAI,EAAJ,CAA9B;;AAEA,UAAIc,SAAS,IAAI,CAAjB,EAAoB;AAChB;AACA,YAAIC,QAAQ,GAAG,CAACjB,YAAY,CAACkB,IAAd,CAAf;;AAEA,YAAIJ,QAAQ,KAAKV,SAAjB,EAA4B;AACxBa,UAAAA,QAAQ,CAACE,OAAT,CAAiBnB,YAAY,CAACoB,KAA9B;AACH,SAFD,MAGK,IAAIN,QAAQ,KAAKT,UAAjB,EAA6B;AAC9BY,UAAAA,QAAQ,CAACE,OAAT,CAAiBnB,YAAY,CAACqB,MAA9B;AACH;;AAEDV,QAAAA,OAAO,CAACG,QAAD,CAAP,GAAoB,CAACG,QAAD,EAAWF,aAAX,CAApB;AACA;AACH,OAlB0B,CAoB3B;;;AACA,YAAMO,cAAc,GAAGpB,YAAY,CAACF,YAAY,CAACuB,IAAd,EAAoBvB,YAAY,CAACwB,UAAjC,CAAnC;AACA,UAAIP,QAAQ,GAAG,CAACK,cAAD,EAAiBtB,YAAY,CAACkB,IAA9B,CAAf;;AAEA,UAAIJ,QAAQ,KAAKV,SAAjB,EAA4B;AACxBa,QAAAA,QAAQ,CAACE,OAAT,CAAiBnB,YAAY,CAACoB,KAA9B;AACH,OAFD,MAGK,IAAIN,QAAQ,KAAKT,UAAjB,EAA6B;AAC9BY,QAAAA,QAAQ,CAACE,OAAT,CAAiBnB,YAAY,CAACqB,MAA9B;AACH;;AAEDN,MAAAA,aAAa,CAACU,SAAS,IAAIR,QAAd,CAAb;AACAN,MAAAA,OAAO,CAACG,QAAD,CAAP,GAAoB,CAACG,QAAD,EAAWF,aAAX,CAApB;AACH;AACJ;;AAEDR,EAAAA,YAAY,CAACkB,SAAS,IAAId,OAAd,CAAZ;AACH,CAxCM","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nexport const random = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(1, 10);\n\n            if (randomNum >= 4) {\n                // don't place obstacle\n                let newState = [nodeTypeEnum.none];\n\n                if (currCord === startCord) {\n                    newState.unshift(nodeTypeEnum.start);\n                }\n                else if (currCord === targetCord) {\n                    newState.unshift(nodeTypeEnum.target);\n                }\n\n                gridMap[currCord] = [newState, nodeStateFunc];\n                continue;\n            }\n\n            // place wall\n            const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20);\n            let newState = [randomObstacle, nodeTypeEnum.none];\n\n            if (currCord === startCord) {\n                newState.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                newState.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => newState);\n            gridMap[currCord] = [newState, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};"]},"metadata":{},"sourceType":"module"}