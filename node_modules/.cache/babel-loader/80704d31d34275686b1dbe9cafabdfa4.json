{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{getNeighbourNodes,createPath,findMinPriorityNode}from'../../utils/helper.js';import{nodeWeight,nodeTypeEnum}from'../../utils/constants.js';export var dijkstras=function dijkstras(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var totalCosts={};var prevNodes={};var minPQ={};var visited={};totalCosts[startCord]=0;minPQ[startCord]=0;for(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){totalCosts[cord]=Infinity;}}}var _loop=function _loop(){var minKey=findMinPriorityNode(minPQ);delete minPQ[minKey];visited[minKey]=1;if(minKey!==startCord&&minKey!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},minKey,[nodeTypeEnum.visited].concat(_toConsumableArray(prevState[minKey].slice(1)))));});},timeout);}else if(minKey===targetCord){return{v:createPath(startCord,targetCord,prevNodes)};}var neighbours=getNeighbourNodes(minKey,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{var _loop2=function _loop2(){var neighbour=_step.value;var currPath=totalCosts[minKey]+nodeWeight[gridState[neighbour][0]];if(neighbour in visited){return\"continue\";}if(neighbour in minPQ&&currPath<totalCosts[neighbour]||!(neighbour in minPQ)){totalCosts[neighbour]=currPath;prevNodes[neighbour]=minKey;minPQ[neighbour]=currPath;if(neighbour!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},neighbour,[nodeTypeEnum.visiting].concat(_toConsumableArray(prevState[neighbour]))));});},timeout);}}};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(Object.keys(minPQ).length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","nodeWeight","nodeTypeEnum","dijkstras","startCord","targetCord","gridState","setGridState","rows","cols","timeout","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","minKey","setTimeout","prevState","slice","neighbours","neighbour","currPath","visiting","Object","keys","length"],"mappings":"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","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [minKey]: [nodeTypeEnum.visited, ...prevState[minKey].slice(1)] }));\n            }, timeout);\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + nodeWeight[gridState[neighbour][0]];\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    setTimeout(() => {\n                        setGridState(prevState => ({ ...prevState, [neighbour]: [nodeTypeEnum.visiting, ...prevState[neighbour]] }));\n                    }, timeout);\n                }\n            }\n        }\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}