{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNodeTypeEnum,getNeighbourNodes,createPath}from'../../utils/util.js';export var bfs=function bfs(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var queue=[startCord];var visited=_defineProperty({},startCord,1);var prevNodes={};var _loop=function _loop(){var currCord=queue.pop();if(currCord!==startCord&&currCord!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[getNodeTypeEnum('visited'),getNodeTypeEnum('none')]));});},timeout);}var neighbours=getNeighbourNodes(currCord,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{var _loop2=function _loop2(){var neighbour=_step.value;if(neighbour in visited){return\"continue\";}prevNodes[neighbour]=currCord;queue.unshift(neighbour);visited[neighbour]=1;if(neighbour===targetCord){return{v:{v:createPath(startCord,targetCord,prevNodes)}};}setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},neighbour,[getNodeTypeEnum('visiting'),getNodeTypeEnum('none')]));});},timeout);};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;if(typeof _ret2===\"object\")return _ret2.v;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(queue.length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bfs.js"],"names":["getNodeTypeEnum","getNeighbourNodes","createPath","bfs","startCord","targetCord","gridState","setGridState","rows","cols","timeout","queue","visited","prevNodes","currCord","pop","setTimeout","prevState","neighbours","neighbour","unshift","length"],"mappings":"glBAAA,OAASA,eAAT,CAA0BC,iBAA1B,CAA6CC,UAA7C,KAA+D,qBAA/D,CAEA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,SAAxB,CAAmCC,YAAnC,CAAiDC,IAAjD,CAAuDC,IAAvD,CAA6DC,OAA7D,CAAyE,CACxF,GAAIC,CAAAA,KAAK,CAAG,CAACP,SAAD,CAAZ,CACA,GAAIQ,CAAAA,OAAO,oBAAMR,SAAN,CAAkB,CAAlB,CAAX,CACA,GAAIS,CAAAA,SAAS,CAAG,EAAhB,CAHwF,2BAMpF,GAAMC,CAAAA,QAAQ,CAAGH,KAAK,CAACI,GAAN,EAAjB,CACA,GAAID,QAAQ,GAAKV,SAAb,EAA0BU,QAAQ,GAAKT,UAA3C,CAAuD,CACnDW,UAAU,CAAC,UAAM,CACbT,YAAY,CAAC,SAAAU,SAAS,wCAAUA,SAAV,wBAAsBH,QAAtB,CAAiC,CAACd,eAAe,CAAC,SAAD,CAAhB,CAA6BA,eAAe,CAAC,MAAD,CAA5C,CAAjC,IAAV,CAAZ,CACH,CAFS,CAEPU,OAFO,CAAV,CAGH,CACD,GAAMQ,CAAAA,UAAU,CAAGjB,iBAAiB,CAACa,QAAD,CAAWN,IAAX,CAAiBC,IAAjB,CAAuBH,SAAvB,CAApC,CAZoF,yCAc5DY,UAd4D,4CAczEC,CAAAA,SAdyE,aAehF,GAAIA,SAAS,GAAIP,CAAAA,OAAjB,CAA0B,CACtB,iBACH,CAEDC,SAAS,CAACM,SAAD,CAAT,CAAuBL,QAAvB,CACAH,KAAK,CAACS,OAAN,CAAcD,SAAd,EACAP,OAAO,CAACO,SAAD,CAAP,CAAqB,CAArB,CAEA,GAAIA,SAAS,GAAKd,UAAlB,CAA8B,CAC1B,YAAOH,UAAU,CAACE,SAAD,CAAYC,UAAZ,CAAwBQ,SAAxB,CAAjB,GACH,CAEDG,UAAU,CAAC,UAAM,CACbT,YAAY,CAAC,SAAAU,SAAS,wCAAUA,SAAV,wBAAsBE,SAAtB,CAAkC,CAACnB,eAAe,CAAC,UAAD,CAAhB,CAA8BA,eAAe,CAAC,MAAD,CAA7C,CAAlC,IAAV,CAAZ,CACH,CAFS,CAEPU,OAFO,CAAV,CA3BgF,EAcpF,+CAAoC,0CAE5B,SAF4B,0CAgBnC,CA9BmF,uDAKxF,MAAOC,KAAK,CAACU,MAAN,CAAe,CAAtB,CAAyB,0DA0BxB,CAED,MAAO,EAAP,CACH,CAlCM","sourcesContent":["import { getNodeTypeEnum, getNeighbourNodes, createPath } from '../../utils/util.js'\n\nexport const bfs = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [getNodeTypeEnum('visited'), getNodeTypeEnum('none')] }));\n            }, timeout);\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [neighbour]: [getNodeTypeEnum('visiting'), getNodeTypeEnum('none')] }));\n            }, timeout);\n        }\n    }\n\n    return [];\n};\n"]},"metadata":{},"sourceType":"module"}