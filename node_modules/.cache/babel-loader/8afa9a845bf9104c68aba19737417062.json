{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (var x = 0; x < rows; x++) {\n    for (var y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n\n      if (x === 0 || x === rows - 1 || y === 0 || y === cols - 1) {\n        await sleep(timeout);\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n        if (currCord === startCord) {\n          state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        } else if (currCord === targetCord) {\n          state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n        setGridState(prevState => ({ ...prevState,\n          [currCord]: [state, prevState[currCord][1]]\n        }));\n      }\n    }\n  }\n\n  await divide(startCord, targetCord, gridState, setGridState, 1, rows - 1, 1, cols - 1, timeout, rows, cols, -100);\n}; // const divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols, previousBisection) => {\n//     const width = endCol - startCol;\n//     const height = endRow - startRow;\n//     if (width < 2 || height < 2) {\n//         return;\n//     }\n//     if (width < height) {\n//         // cutting horizontally\n//         const skip = getRandomNum(startCol, endCol);\n//         let randRow = getRandomNum(startRow + 1, endRow - 1);\n//         while (randRow === previousBisection) {\n//             randRow = getRandomNum(startRow + 1, endRow - 1);\n//         }\n//         for (let i = startCol; i <= endCol; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${randRow}:${i}`;\n//             console.log(startRow, endRow, currCord);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n//         if (randRow - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//         if ((randRow + 1) < rows) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n//     else {\n//         // divide vertically \n//         const skip = getRandomNum(startRow, endRow);\n//         let randCol = getRandomNum(startCol + 1, endCol - 1);\n//         while (randCol === previousBisection) {\n//             randCol = getRandomNum(startCol + 1, endCol - 1);\n//         }\n//         console.log(startCol, endCol, randCol)\n//         for (let i = startRow; i <= endRow; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${i}:${randCol}`;\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n//         if (randCol - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols, skip);\n//         }\n//         if (randCol + 1 < cols) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n// };\n\nconst divide = async (gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols, previousBisection) => {};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","x","y","currCord","nodeStateFunc","state","wall","none","start","target","prevState","divide","startRow","endRow","startCol","endCol","previousBisection"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,QAAoC,uBAApC;AAEA,OAAO,MAAMC,iBAAiB,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,YAAzC,EAAuDC,IAAvD,EAA6DC,IAA7D,EAAmEC,OAAnE,KAA+E;AAC5G;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAApB,EAA0BG,CAAC,EAA3B,EAA+B;AAC3B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAApB,EAA0BG,CAAC,EAA3B,EAA+B;AAC3B,YAAMC,QAAQ,GAAI,GAAEF,CAAE,IAAGC,CAAE,EAA3B;AACA,YAAME,aAAa,GAAGR,SAAS,CAACO,QAAD,CAAT,CAAoB,CAApB,CAAtB;;AACA,UAAIF,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAMH,IAAI,GAAG,CAAzB,IAA+BI,CAAC,KAAK,CAArC,IAA0CA,CAAC,KAAMH,IAAI,GAAG,CAA5D,EAAgE;AAC5D,cAAMR,KAAK,CAACS,OAAD,CAAX;AACA,YAAIK,KAAK,GAAG,CAACf,YAAY,CAACgB,IAAd,EAAoBhB,YAAY,CAACiB,IAAjC,CAAZ;;AACA,YAAIJ,QAAQ,KAAKT,SAAjB,EAA4B;AACxBW,UAAAA,KAAK,GAAG,CAACf,YAAY,CAACkB,KAAd,EAAqBlB,YAAY,CAACgB,IAAlC,EAAwChB,YAAY,CAACiB,IAArD,CAAR;AACH,SAFD,MAGK,IAAIJ,QAAQ,KAAKR,UAAjB,EAA6B;AAC9BU,UAAAA,KAAK,GAAG,CAACf,YAAY,CAACmB,MAAd,EAAsBnB,YAAY,CAACgB,IAAnC,EAAyChB,YAAY,CAACiB,IAAtD,CAAR;AACH;;AACDH,QAAAA,aAAa,CAACM,SAAS,IAAIL,KAAd,CAAb;AACAR,QAAAA,YAAY,CAACa,SAAS,KAAK,EAAE,GAAGA,SAAL;AAAgB,WAACP,QAAD,GAAY,CAACE,KAAD,EAAQK,SAAS,CAACP,QAAD,CAAT,CAAoB,CAApB,CAAR;AAA5B,SAAL,CAAV,CAAZ;AACH;AACJ;AACJ;;AAED,QAAMQ,MAAM,CAACjB,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiD,CAAjD,EAAoDC,IAAI,GAAG,CAA3D,EAA8D,CAA9D,EAAiEC,IAAI,GAAG,CAAxE,EAA2EC,OAA3E,EAAoFF,IAApF,EAA0FC,IAA1F,EAAgG,CAAC,GAAjG,CAAZ;AACH,CAtBM,C,CAwBP;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMY,MAAM,GAAG,OAAOf,SAAP,EAAkBC,YAAlB,EAAgCe,QAAhC,EAA0CC,MAA1C,EAAkDC,QAAlD,EAA4DC,MAA5D,EAAoEf,OAApE,EAA6EF,IAA7E,EAAmFC,IAAnF,EAAyFiB,iBAAzF,KAA+G,CAC7H,CADD","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (var x = 0; x < rows; x++) {\n        for (var y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            if (x === 0 || x === (rows - 1) || y === 0 || y === (cols - 1)) {\n                await sleep(timeout);\n                let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n                if (currCord === startCord) {\n                    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                else if (currCord === targetCord) {\n                    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                nodeStateFunc(prevState => state);\n                setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            }\n        }\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 1, 1, cols - 1, timeout, rows, cols, -100);\n};\n\n// const divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols, previousBisection) => {\n//     const width = endCol - startCol;\n//     const height = endRow - startRow;\n\n//     if (width < 2 || height < 2) {\n//         return;\n//     }\n\n//     if (width < height) {\n//         // cutting horizontally\n//         const skip = getRandomNum(startCol, endCol);\n//         let randRow = getRandomNum(startRow + 1, endRow - 1);\n//         while (randRow === previousBisection) {\n//             randRow = getRandomNum(startRow + 1, endRow - 1);\n//         }\n\n//         for (let i = startCol; i <= endCol; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${randRow}:${i}`;\n//             console.log(startRow, endRow, currCord);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n\n//         if (randRow - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//         if ((randRow + 1) < rows) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n//     else {\n//         // divide vertically \n//         const skip = getRandomNum(startRow, endRow);\n//         let randCol = getRandomNum(startCol + 1, endCol - 1);\n//         while (randCol === previousBisection) {\n//             randCol = getRandomNum(startCol + 1, endCol - 1);\n//         }\n//         console.log(startCol, endCol, randCol)\n//         for (let i = startRow; i <= endRow; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${i}:${randCol}`;\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n\n//         if (randCol - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols, skip);\n//         }\n//         if (randCol + 1 < cols) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n// };\n\nconst divide = async (gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols, previousBisection) => {\n};"]},"metadata":{},"sourceType":"module"}