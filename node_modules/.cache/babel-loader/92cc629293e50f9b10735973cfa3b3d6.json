{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (let y = 0; y < cols; y++) {\n    const currCord = `${0}:${y}`;\n    setWall(currCord, startCord, targetCord, gridState, setGridState);\n    await sleep(timeout);\n  }\n\n  for (let y = 1; y < rows; y++) {\n    const currCord = `${y}:${cols - 1}`;\n    setWall(currCord, startCord, targetCord, gridState, setGridState);\n    await sleep(timeout);\n  }\n\n  for (let y = cols - 2; y >= 0; y--) {\n    const currCord = `${rows - 1}:${y}`;\n    setWall(currCord, startCord, targetCord, gridState, setGridState);\n    await sleep(timeout);\n  }\n\n  for (let y = rows - 2; y > 0; y--) {\n    const currCord = `${y}:${0}`;\n    setWall(currCord, startCord, targetCord, gridState, setGridState);\n    await sleep(timeout);\n  } // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n\n\n  await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n  const width = endCol - startCol + 1;\n  const height = endRow - startRow + 1;\n  let orientation = HORIZONTAL;\n\n  if (width < height) {\n    orientation = HORIZONTAL;\n  } else if (height < width) {\n    orientation = VERTICAL;\n  } else {\n    orientation = getRandomNum(HORIZONTAL, VERTICAL);\n  }\n\n  if (orientation === HORIZONTAL) {\n    // cutting horizontally\n    if (height < 3 || startRow % 2 === 1 && height === 3) {\n      return;\n    }\n\n    let sCol = startCol;\n\n    if (startCol % 2 === 1) {\n      sCol += 1;\n    }\n\n    let sRow = startRow + 2;\n\n    if (startRow % 2 === 0) {\n      sRow = startRow + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n    let randRow = getRandomNum(sRow, endRow - 2);\n    randRow = Math.floor(randRow / 2) * 2 + 1;\n\n    for (let i = startCol; i <= endCol; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${randRow}:${i}`;\n      setWall(currCord, startCord, targetCord, gridState, setGridState); // const nodeStateFunc = gridState[currCord][1];\n      // let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n      // if (currCord === startCord) {\n      //     state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n      // }\n      // else if (currCord === targetCord) {\n      //     state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n      // }\n      // nodeStateFunc(prevState => state);\n      // setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n  } else if (orientation === VERTICAL) {\n    // divide vertically \n    if (width < 3 || startCol % 2 === 1 && width === 3) {\n      return;\n    }\n\n    let sRow = startRow;\n\n    if (startRow % 2 === 1) {\n      sRow += 1;\n    }\n\n    let sCol = startCol + 2;\n\n    if (startCol % 2 === 0) {\n      sCol = startCol + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n    let randCol = getRandomNum(sCol, endCol - 2);\n    randCol = Math.floor(randCol / 2) * 2 + 1;\n\n    for (let i = startRow; i <= endRow; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${i}:${randCol}`;\n      setWall(currCord, startCord, targetCord, gridState, setGridState);\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n  }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState, setGridState) => {\n  const nodeStateFunc = gridState[currCord][1];\n  let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n  if (currCord === startCord) {\n    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n  } else if (currCord === targetCord) {\n    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n  }\n\n  nodeStateFunc(prevState => state);\n  setGridState(prevState => ({ ...prevState,\n    [currCord]: [state, prevState[currCord][1]]\n  }));\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","y","currCord","setWall","divide","startRow","endRow","startCol","endCol","width","height","orientation","sCol","sRow","skip","Math","floor","randRow","i","randCol","nodeStateFunc","state","wall","none","start","target","prevState"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (let y = 0; y < cols; y++) {\n        const currCord = `${0}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = 1; y < rows; y++) {\n        const currCord = `${y}:${cols - 1}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = cols - 2; y >= 0; y--) {\n        const currCord = `${rows - 1}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = rows - 2; y > 0; y--) {\n        const currCord = `${y}:${0}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n\n            setWall(currCord, startCord, targetCord, gridState, setGridState);\n\n            // const nodeStateFunc = gridState[currCord][1];\n            // let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            // if (currCord === startCord) {\n            //     state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            // }\n            // else if (currCord === targetCord) {\n            //     state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            // }\n            // nodeStateFunc(prevState => state);\n            // setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            setWall(currCord, startCord, targetCord, gridState, setGridState);\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState, setGridState) => {\n    const nodeStateFunc = gridState[currCord][1];\n\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n    if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n    else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n};"]},"metadata":{},"sourceType":"module"}