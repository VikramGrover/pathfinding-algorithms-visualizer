{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{nodeTypeEnum}from'../../utils/constants.js';import{getRandomNum}from'../../utils/helper.js';export var random=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var gridMap,x,_loop,y,_ret;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:gridMap={};x=0;case 2:if(!(x<rows)){_context.next=15;break;}_loop=function _loop(y){var currCord=\"\".concat(x,\":\").concat(y);var nodeStateFunc=gridState[currCord][1];var randomNum=getRandomNum(1,10);if(randomNum>=4){// don't place wall\nvar _newState=[nodeTypeEnum.none];if(currCord===startCord){_newState.unshift(nodeTypeEnum.start);}else if(currCord===targetCord){_newState.unshift(nodeTypeEnum.target);}gridMap[currCord]=[_newState,nodeStateFunc];return\"continue\";}// place wall\nvar newState=[nodeTypeEnum.wall,nodeTypeEnum.none];if(currCord===startCord){newState.unshift(nodeTypeEnum.start);}else if(currCord===targetCord){newState.unshift(nodeTypeEnum.target);}nodeStateFunc(function(prevState){return newState;});gridMap[currCord]=[newState,nodeStateFunc];};y=0;case 5:if(!(y<cols)){_context.next=12;break;}_ret=_loop(y);if(!(_ret===\"continue\")){_context.next=9;break;}return _context.abrupt(\"continue\",9);case 9:y++;_context.next=5;break;case 12:x++;_context.next=2;break;case 15:setGridState(function(prevState){return gridMap;});case 16:case\"end\":return _context.stop();}}},_callee);}));return function random(_x,_x2,_x3,_x4,_x5,_x6,_x7){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/random.js"],"names":["nodeTypeEnum","getRandomNum","random","startCord","targetCord","gridState","setGridState","rows","cols","timeout","gridMap","x","y","currCord","nodeStateFunc","randomNum","newState","none","unshift","start","target","wall","prevState"],"mappings":"uXAAA,OAASA,YAAT,KAA6B,0BAA7B,CACA,OAASC,YAAT,KAA6B,uBAA7B,CAEA,MAAO,IAAMC,CAAAA,MAAM,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,YAAzC,CAAuDC,IAAvD,CAA6DC,IAA7D,CAAmEC,OAAnE,6IACdC,OADc,CACJ,EADI,CAETC,CAFS,CAEL,CAFK,aAEFA,CAAC,CAAGJ,IAFF,gDAGLK,CAHK,EAIV,GAAMC,CAAAA,QAAQ,WAAMF,CAAN,aAAWC,CAAX,CAAd,CACA,GAAME,CAAAA,aAAa,CAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB,CACA,GAAME,CAAAA,SAAS,CAAGd,YAAY,CAAC,CAAD,CAAI,EAAJ,CAA9B,CAEA,GAAIc,SAAS,EAAI,CAAjB,CAAoB,CAChB;AACA,GAAIC,CAAAA,SAAQ,CAAG,CAAChB,YAAY,CAACiB,IAAd,CAAf,CAEA,GAAIJ,QAAQ,GAAKV,SAAjB,CAA4B,CACxBa,SAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACmB,KAA9B,EACH,CAFD,IAGK,IAAIN,QAAQ,GAAKT,UAAjB,CAA6B,CAC9BY,SAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACoB,MAA9B,EACH,CAEDV,OAAO,CAACG,QAAD,CAAP,CAAoB,CAACG,SAAD,CAAWF,aAAX,CAApB,CACA,iBACH,CAED;AACA,GAAIE,CAAAA,QAAQ,CAAG,CAAChB,YAAY,CAACqB,IAAd,CAAoBrB,YAAY,CAACiB,IAAjC,CAAf,CAEA,GAAIJ,QAAQ,GAAKV,SAAjB,CAA4B,CACxBa,QAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACmB,KAA9B,EACH,CAFD,IAGK,IAAIN,QAAQ,GAAKT,UAAjB,CAA6B,CAC9BY,QAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACoB,MAA9B,EACH,CAEDN,aAAa,CAAC,SAAAQ,SAAS,QAAIN,CAAAA,QAAJ,EAAV,CAAb,CACAN,OAAO,CAACG,QAAD,CAAP,CAAoB,CAACG,QAAD,CAAWF,aAAX,CAApB,CAlCU,EAGLF,CAHK,CAGD,CAHC,aAGEA,CAAC,CAAGJ,IAHN,sCAGLI,CAHK,8FAGYA,CAAC,EAHb,+BAEQD,CAAC,EAFT,+BAsClBL,YAAY,CAAC,SAAAgB,SAAS,QAAIZ,CAAAA,OAAJ,EAAV,CAAZ,CAtCkB,uDAAH,kBAANR,CAAAA,MAAM,oEAAZ","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js';\nimport { getRandomNum } from '../../utils/helper.js'\n\nexport const random = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(1, 10);\n\n            if (randomNum >= 4) {\n                // don't place wall\n                let newState = [nodeTypeEnum.none];\n\n                if (currCord === startCord) {\n                    newState.unshift(nodeTypeEnum.start);\n                }\n                else if (currCord === targetCord) {\n                    newState.unshift(nodeTypeEnum.target);\n                }\n\n                gridMap[currCord] = [newState, nodeStateFunc];\n                continue;\n            }\n\n            // place wall\n            let newState = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n            if (currCord === startCord) {\n                newState.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                newState.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => newState);\n            gridMap[currCord] = [newState, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};"]},"metadata":{},"sourceType":"module"}