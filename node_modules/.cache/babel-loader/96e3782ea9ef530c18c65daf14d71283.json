{"ast":null,"code":"import { getNeighbourNodes, createPath, findMinPriorityNode, sleep, manhattanDistanceHeuristic } from '../../utils/helper.js';\nimport { nodeTypeEnum } from '../../utils/constants.js';\nexport const greedyBestFirstSearch = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n  let openSet = {\n    [startCord]: 0\n  };\n  let H = {\n    [startCord]: 0\n  }; // H(n) => tells us the estimated distance from node n to target node\n\n  let F = {\n    [startCord]: 0\n  }; // F(n) = H(n)\n\n  let prevNodes = {};\n  let visited = {}; // intialize all the scores to infinity for all node !== start node\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      let cord = `${x}:${y}`;\n\n      if (cord !== startCord) {\n        F[cord] = H[cord] = Infinity;\n      }\n    }\n  }\n\n  while (Object.keys(openSet).length > 0) {\n    const currNode = findMinPriorityNode(openSet);\n    delete openSet[currNode];\n\n    if (currNode !== startCord && currNode !== targetCord) {\n      const nodeStateFunc = gridState[currNode][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.visited, ...prevState.slice(1)]);\n    } else if (currNode === targetCord) {\n      console.log(\"DONNEE\"); // we have reached target, return path\n\n      return createPath(startCord, targetCord, prevNodes);\n    }\n\n    const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n\n    for (const neighbour of neighbours) {\n      if (!(neighbour in visited)) {\n        visited[neighbour] = 1;\n\n        if (neighbour !== startCord && neighbour !== targetCord) {\n          const nodeStateFunc = gridState[neighbour][1];\n          nodeStateFunc(prevState => [nodeTypeEnum.visiting, ...prevState]);\n        }\n\n        H[neighbour] = manhattanDistanceHeuristic(neighbour, targetCord);\n        F[neighbour] = H[neighbour];\n        prevNodes[neighbour] = currNode;\n        openSet[neighbour] = F[neighbour];\n      }\n    }\n\n    await sleep(timeout);\n  }\n\n  return [];\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bestFirstSearch.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","sleep","manhattanDistanceHeuristic","nodeTypeEnum","greedyBestFirstSearch","startCord","targetCord","gridState","rows","cols","timeout","openSet","H","F","prevNodes","visited","x","y","cord","Infinity","Object","keys","length","currNode","nodeStateFunc","prevState","slice","console","log","neighbours","neighbour","visiting"],"mappings":"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","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode, sleep, manhattanDistanceHeuristic } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const greedyBestFirstSearch = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = H(n)\n    let prevNodes = {};\n    let visited = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (currNode === targetCord) {\n            console.log(\"DONNEE\");\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            if (!(neighbour in visited)) {\n                visited[neighbour] = 1;\n\n                if (neighbour !== startCord && neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n\n                H[neighbour] = manhattanDistanceHeuristic(neighbour, targetCord);\n                F[neighbour] = H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n"]},"metadata":{},"sourceType":"module"}