{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{getNodeTypeEnum,getNodeWeight,getNeighbourNodes,createPath}from'../../utils/util.js';export var dijkstras=function dijkstras(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var totalCosts={};var prevNodes={};var minPQ={};var visited={};totalCosts[startCord]=0;minPQ[startCord]=0;for(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){totalCosts[cord]=Infinity;}}}var _loop=function _loop(){var minKey=findMinPriorityNode(minPQ);delete minPQ[minKey];visited[minKey]=1;if(minKey!==startCord&&minKey!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},minKey,[getNodeTypeEnum('visited')].concat(_toConsumableArray(prevState[minKey].slice(1)))));});},timeout);}else if(minKey===targetCord){return{v:createPath(startCord,targetCord,prevNodes)};}var neighbours=getNeighbourNodes(minKey,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{var _loop2=function _loop2(){var neighbour=_step.value;var currPath=totalCosts[minKey]+getNodeWeight(gridState[neighbour][0]);if(neighbour in visited){return\"continue\";}if(neighbour in minPQ&&currPath<totalCosts[neighbour]||!(neighbour in minPQ)){totalCosts[neighbour]=currPath;prevNodes[neighbour]=minKey;minPQ[neighbour]=currPath;if(neighbour!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},neighbour,[getNodeTypeEnum('visiting')].concat(_toConsumableArray(prevState[neighbour]))));});},timeout);}}};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(Object.keys(minPQ).length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};var findMinPriorityNode=function findMinPriorityNode(minPQ){var minPriority=Math.min.apply(Math,_toConsumableArray(Object.values(minPQ)));for(var key in minPQ){if(minPQ[key]===minPriority){return key;}}};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNodeTypeEnum","getNodeWeight","getNeighbourNodes","createPath","dijkstras","startCord","targetCord","gridState","setGridState","rows","cols","timeout","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","minKey","findMinPriorityNode","setTimeout","prevState","slice","neighbours","neighbour","currPath","Object","keys","length","minPriority","Math","min","values","key"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight, getNeighbourNodes, createPath } from '../../utils/util.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [minKey]: [getNodeTypeEnum('visited'), ...prevState[minKey].slice(1)] }));\n            }, timeout);\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + getNodeWeight(gridState[neighbour][0]);\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    setTimeout(() => {\n                        setGridState(prevState => ({ ...prevState, [neighbour]: [getNodeTypeEnum('visiting'), ...prevState[neighbour]] }));\n                    }, timeout);\n                }\n            }\n        }\n    }\n\n    return [];\n};\n\nconst findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};"]},"metadata":{},"sourceType":"module"}