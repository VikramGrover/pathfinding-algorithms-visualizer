{"ast":null,"code":"import { getNodeTypeEnum, getNeighbourNodes } from '../../utils/util.js';\nexport const bfs = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  let queue = [startCord];\n  let visited = {\n    [startCord]: 1\n  };\n  let prevNodes = {};\n\n  while (queue.length > 0) {\n    const currCord = queue.pop();\n\n    if (currCord !== startCord && currCord !== targetCord) {\n      const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n      for (const neighbour of neighbours) {\n        if (neighbour in visited) {\n          continue;\n        }\n\n        if (neighbour === targetCord) {\n          return createPath(startCord, targetCord, prevNodes);\n        }\n\n        stack.unshift(neighbour);\n        visited[neighbour] = 1;\n        prevNodes[neighbour] = currCord;\n        setTimeout(() => {\n          setGridState(prevState => ({ ...prevState,\n            [currCord]: [getNodeTypeEnum('visited'), getNodeTypeEnum('none')]\n          }));\n        }, timeout);\n      }\n    }\n  }\n\n  return [];\n};\n\nconst createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/bfs.js"],"names":["getNodeTypeEnum","getNeighbourNodes","bfs","startCord","targetCord","gridState","setGridState","rows","cols","timeout","queue","visited","prevNodes","length","currCord","pop","neighbours","neighbour","createPath","stack","unshift","setTimeout","prevState","cord","path","push"],"mappings":"AAAA,SAASA,eAAT,EAA0BC,iBAA1B,QAAmD,qBAAnD;AAEA,OAAO,MAAMC,GAAG,GAAG,CAACC,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiDC,IAAjD,EAAuDC,IAAvD,EAA6DC,OAA7D,KAAyE;AACxF,MAAIC,KAAK,GAAG,CAACP,SAAD,CAAZ;AACA,MAAIQ,OAAO,GAAG;AAAE,KAACR,SAAD,GAAa;AAAf,GAAd;AACA,MAAIS,SAAS,GAAG,EAAhB;;AAEA,SAAOF,KAAK,CAACG,MAAN,GAAe,CAAtB,EAAyB;AACrB,UAAMC,QAAQ,GAAGJ,KAAK,CAACK,GAAN,EAAjB;;AAEA,QAAID,QAAQ,KAAKX,SAAb,IAA0BW,QAAQ,KAAKV,UAA3C,EAAuD;AACnD,YAAMY,UAAU,GAAGf,iBAAiB,CAACa,QAAD,EAAWP,IAAX,EAAiBC,IAAjB,EAAuBH,SAAvB,CAApC;;AACA,WAAK,MAAMY,SAAX,IAAwBD,UAAxB,EAAoC;AAChC,YAAIC,SAAS,IAAIN,OAAjB,EAA0B;AACtB;AACH;;AAED,YAAIM,SAAS,KAAKb,UAAlB,EAA8B;AAC1B,iBAAOc,UAAU,CAACf,SAAD,EAAYC,UAAZ,EAAwBQ,SAAxB,CAAjB;AACH;;AAEDO,QAAAA,KAAK,CAACC,OAAN,CAAcH,SAAd;AACAN,QAAAA,OAAO,CAACM,SAAD,CAAP,GAAqB,CAArB;AACAL,QAAAA,SAAS,CAACK,SAAD,CAAT,GAAuBH,QAAvB;AACAO,QAAAA,UAAU,CAAC,MAAM;AACbf,UAAAA,YAAY,CAACgB,SAAS,KAAK,EAAE,GAAGA,SAAL;AAAgB,aAACR,QAAD,GAAY,CAACd,eAAe,CAAC,SAAD,CAAhB,EAA6BA,eAAe,CAAC,MAAD,CAA5C;AAA5B,WAAL,CAAV,CAAZ;AACH,SAFS,EAEPS,OAFO,CAAV;AAGH;AACJ;AACJ;;AAED,SAAO,EAAP;AACH,CA9BM;;AAgCP,MAAMS,UAAU,GAAG,CAACf,SAAD,EAAYC,UAAZ,EAAwBQ,SAAxB,KAAsC;AACrD,MAAIW,IAAI,GAAGnB,UAAX;AACA,MAAIoB,IAAI,GAAG,EAAX;;AAEA,SAAO,IAAP,EAAa;AACTD,IAAAA,IAAI,GAAGX,SAAS,CAACW,IAAD,CAAhB;;AAEA,QAAIA,IAAI,KAAKpB,SAAb,EAAwB;AACpB;AACH;;AAEDqB,IAAAA,IAAI,CAACC,IAAL,CAAUF,IAAV;AACH;;AAED,SAAOC,IAAP;AACH,CAfD","sourcesContent":["import { getNodeTypeEnum, getNeighbourNodes } from '../../utils/util.js'\n\nexport const bfs = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n\n        if (currCord !== startCord && currCord !== targetCord) {\n            const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n            for (const neighbour of neighbours) {\n                if (neighbour in visited) {\n                    continue;\n                }\n\n                if (neighbour === targetCord) {\n                    return createPath(startCord, targetCord, prevNodes);\n                }\n\n                stack.unshift(neighbour);\n                visited[neighbour] = 1;\n                prevNodes[neighbour] = currCord;\n                setTimeout(() => {\n                    setGridState(prevState => ({ ...prevState, [currCord]: [getNodeTypeEnum('visited'), getNodeTypeEnum('none')] }));\n                }, timeout);\n            }\n        }\n    }\n\n    return [];\n};\n\nconst createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};"]},"metadata":{},"sourceType":"module"}