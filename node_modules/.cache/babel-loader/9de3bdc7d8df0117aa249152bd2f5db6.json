{"ast":null,"code":"import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors } from './constants.js';\nexport const getNodeColor = nodeState => {\n  // if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting || nodeState[0] === nodeTypeEnum.path) && nodeState[1] > nodeTypeEnum.wall) {\n  //     let colorA = nodeColors[nodeState[0]];\n  //     const colorB = nodeColors[nodeState[1]];\n  //     let amount = 0.73;\n  //     if (nodeState[0] === nodeTypeEnum.visiting) {\n  //         colorA = nodeColors[nodeTypeEnum.visited];\n  //     }\n  //     // we need to mix colors\n  //     const [rA, gA, bA] = colorA.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n  //     const [rB, gB, bB] = colorB.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n  //     const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n  //     const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n  //     const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n  //     return '#' + r + g + b;\n  // }\n  return nodeColors[nodeState[0]];\n};\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};\nexport const createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\nexport const findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\nexport const isAlgoUnweighted = algo => {\n  return unweightedPathAlgos.includes(algo);\n};\nexport const isAlgoOptimal = algo => {\n  return optimalPathAlgos.includes(algo);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/helper.js"],"names":["nodeTypeEnum","unweightedPathAlgos","optimalPathAlgos","nodeColors","getNodeColor","nodeState","getNeighbourNodes","node","rows","cols","gridState","row","parseInt","split","col","res","wall","push","createPath","startCord","targetCord","prevNodes","cord","path","findMinPriorityNode","minPQ","minPriority","Math","min","Object","values","key","isAlgoUnweighted","algo","includes","isAlgoOptimal"],"mappings":"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","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors } from './constants.js'\n\nexport const getNodeColor = (nodeState) => {\n    // if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting || nodeState[0] === nodeTypeEnum.path) && nodeState[1] > nodeTypeEnum.wall) {\n    //     let colorA = nodeColors[nodeState[0]];\n    //     const colorB = nodeColors[nodeState[1]];\n    //     let amount = 0.73;\n\n    //     if (nodeState[0] === nodeTypeEnum.visiting) {\n    //         colorA = nodeColors[nodeTypeEnum.visited];\n    //     }\n    //     // we need to mix colors\n    //     const [rA, gA, bA] = colorA.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n    //     const [rB, gB, bB] = colorB.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n    //     const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n    //     const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n    //     const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n    //     return '#' + r + g + b;\n    // }\n\n    return nodeColors[nodeState[0]];\n};\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n"]},"metadata":{},"sourceType":"module"}