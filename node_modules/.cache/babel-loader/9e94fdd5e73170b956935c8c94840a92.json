{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nexport const randomWeighted = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  let gridMap = {};\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n      const randomNum = getRandomNum(0, 10);\n      let newState = [nodeTypeEnum.none];\n\n      if (randomNum <= 2) {\n        const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20); // place a wall\n\n        newState.unshift(randomObstacle);\n\n        if (currCord === startCord) {\n          newState.unshift(nodeTypeEnum.start);\n        } else if (currCord === targetCord) {\n          newState.unshift(nodeTypeEnum.target);\n        }\n\n        nodeStateFunc(prevState => newState);\n        await sleep(timeout);\n      }\n\n      gridMap[currCord] = [newState, nodeStateFunc];\n    }\n  }\n\n  setGridState(prevState => gridMap);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/randomWeighted.js"],"names":["nodeTypeEnum","sleep","getRandomNum","randomWeighted","startCord","targetCord","gridState","setGridState","rows","cols","timeout","gridMap","x","y","currCord","nodeStateFunc","randomNum","newState","none","randomObstacle","wall","weighted20","unshift","start","target","prevState"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,QAAoC,uBAApC;AAEA,OAAO,MAAMC,cAAc,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,YAAzC,EAAuDC,IAAvD,EAA6DC,IAA7D,EAAmEC,OAAnE,KAA+E;AACzG,MAAIC,OAAO,GAAG,EAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,YAAMC,QAAQ,GAAI,GAAEF,CAAE,IAAGC,CAAE,EAA3B;AACA,YAAME,aAAa,GAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACA,YAAME,SAAS,GAAGd,YAAY,CAAC,CAAD,EAAI,EAAJ,CAA9B;AACA,UAAIe,QAAQ,GAAG,CAACjB,YAAY,CAACkB,IAAd,CAAf;;AAEA,UAAIF,SAAS,IAAI,CAAjB,EAAoB;AAChB,cAAMG,cAAc,GAAGjB,YAAY,CAACF,YAAY,CAACoB,IAAd,EAAoBpB,YAAY,CAACqB,UAAjC,CAAnC,CADgB,CAEhB;;AACAJ,QAAAA,QAAQ,CAACK,OAAT,CAAiBH,cAAjB;;AAEA,YAAIL,QAAQ,KAAKV,SAAjB,EAA4B;AACxBa,UAAAA,QAAQ,CAACK,OAAT,CAAiBtB,YAAY,CAACuB,KAA9B;AACH,SAFD,MAGK,IAAIT,QAAQ,KAAKT,UAAjB,EAA6B;AAC9BY,UAAAA,QAAQ,CAACK,OAAT,CAAiBtB,YAAY,CAACwB,MAA9B;AACH;;AAEDT,QAAAA,aAAa,CAACU,SAAS,IAAIR,QAAd,CAAb;AAEA,cAAMhB,KAAK,CAACS,OAAD,CAAX;AACH;;AAEDC,MAAAA,OAAO,CAACG,QAAD,CAAP,GAAoB,CAACG,QAAD,EAAWF,aAAX,CAApB;AACH;AACJ;;AAEDR,EAAAA,YAAY,CAACkB,SAAS,IAAId,OAAd,CAAZ;AACH,CA/BM","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nexport const randomWeighted = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(0, 10);\n            let newState = [nodeTypeEnum.none];\n\n            if (randomNum <= 2) {\n                const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20);\n                // place a wall\n                newState.unshift(randomObstacle);\n\n                if (currCord === startCord) {\n                    newState.unshift(nodeTypeEnum.start);\n                }\n                else if (currCord === targetCord) {\n                    newState.unshift(nodeTypeEnum.target);\n                }\n\n                nodeStateFunc(prevState => newState);\n\n                await sleep(timeout);\n            }\n\n            gridMap[currCord] = [newState, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};"]},"metadata":{},"sourceType":"module"}