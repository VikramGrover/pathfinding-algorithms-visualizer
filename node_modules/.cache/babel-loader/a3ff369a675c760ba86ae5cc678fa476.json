{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getNeighbourNodes,sleep}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var dfs=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,rows,cols,timeout){var stack,path,visited,currCord,nodeStateFunc,_nodeStateFunc,neighbours,unvisitedNeighbourFound,_iterator,_step,neighbour;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:stack=[startCord];path=[];visited=_defineProperty({},startCord,1);case 3:if(!(stack.length>0)){_context.next=38;break;}currCord=stack[0];if(currCord!==targetCord&&currCord!==startCord){nodeStateFunc=gridState[currCord][1];nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting,nodeTypeEnum.none];});}if(!(currCord===targetCord)){_context.next=10;break;}stack.pop();stack.shift();return _context.abrupt(\"return\",stack);case 10:if(currCord!==startCord){path.unshift(currCord);visited[currCord]=1;_nodeStateFunc=gridState[currCord][1];_nodeStateFunc(function(prevState){return[nodeTypeEnum.visited,nodeTypeEnum.none];});}neighbours=getNeighbourNodes(currCord,rows,cols,gridState);unvisitedNeighbourFound=false;_iterator=_createForOfIteratorHelper(neighbours);_context.prev=14;_iterator.s();case 16:if((_step=_iterator.n()).done){_context.next=25;break;}neighbour=_step.value;if(!(neighbour in visited)){_context.next=20;break;}return _context.abrupt(\"continue\",23);case 20:stack.unshift(neighbour);unvisitedNeighbourFound=true;return _context.abrupt(\"break\",25);case 23:_context.next=16;break;case 25:_context.next=30;break;case 27:_context.prev=27;_context.t0=_context[\"catch\"](14);_iterator.e(_context.t0);case 30:_context.prev=30;_iterator.f();return _context.finish(30);case 33:if(!unvisitedNeighbourFound){stack.splice(0,1);}_context.next=36;return sleep(timeout);case 36:_context.next=3;break;case 38:return _context.abrupt(\"return\",[]);case 39:case\"end\":return _context.stop();}}},_callee,null,[[14,27,30,33]]);}));return function dfs(_x,_x2,_x3,_x4,_x5,_x6){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNeighbourNodes","sleep","nodeTypeEnum","dfs","startCord","targetCord","gridState","rows","cols","timeout","stack","path","visited","length","currCord","nodeStateFunc","prevState","visiting","none","pop","shift","unshift","neighbours","unvisitedNeighbourFound","neighbour","splice"],"mappings":"2wBAAA,OAASA,iBAAT,CAA4BC,KAA5B,KAAyC,uBAAzC,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,GAAG,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,IAAzC,CAA+CC,IAA/C,CAAqDC,OAArD,4OACTC,KADS,CACD,CAACN,SAAD,CADC,CAETO,IAFS,CAEF,EAFE,CAGTC,OAHS,oBAGIR,SAHJ,CAGgB,CAHhB,cAKRM,KAAK,CAACG,MAAN,CAAe,CALP,2BAMLC,QANK,CAMMJ,KAAK,CAAC,CAAD,CANX,CAOX,GAAII,QAAQ,GAAKT,UAAb,EAA2BS,QAAQ,GAAKV,SAA5C,CAAuD,CAC7CW,aAD6C,CAC7BT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAD6B,CAEnDC,aAAa,CAAC,SAAAC,SAAS,QAAK,CAACd,YAAY,CAACe,QAAd,CAAwBf,YAAY,CAACgB,IAArC,CAAL,EAAV,CAAb,CACH,CAVU,KAYPJ,QAAQ,GAAKT,UAZN,2BAaPK,KAAK,CAACS,GAAN,GACAT,KAAK,CAACU,KAAN,GAdO,gCAeAV,KAfA,UAkBX,GAAII,QAAQ,GAAKV,SAAjB,CAA4B,CACxBO,IAAI,CAACU,OAAL,CAAaP,QAAb,EACAF,OAAO,CAACE,QAAD,CAAP,CAAoB,CAApB,CACMC,cAHkB,CAGFT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAHE,CAIxBC,cAAa,CAAC,SAAAC,SAAS,QAAK,CAACd,YAAY,CAACU,OAAd,CAAuBV,YAAY,CAACgB,IAApC,CAAL,EAAV,CAAb,CACH,CAEKI,UAzBK,CAyBQtB,iBAAiB,CAACc,QAAD,CAAWP,IAAX,CAAiBC,IAAjB,CAAuBF,SAAvB,CAzBzB,CA0BPiB,uBA1BO,CA0BmB,KA1BnB,sCA2BaD,UA3Bb,gGA2BAE,SA3BA,kBA4BHA,SAAS,GAAIZ,CAAAA,OA5BV,yEAgCPF,KAAK,CAACW,OAAN,CAAcG,SAAd,EACAD,uBAAuB,CAAG,IAA1B,CAjCO,+PAqCX,GAAI,CAACA,uBAAL,CAA8B,CAC1Bb,KAAK,CAACe,MAAN,CAAa,CAAb,CAAgB,CAAhB,EACH,CAvCU,uBAyCLxB,CAAAA,KAAK,CAACQ,OAAD,CAzCA,uEA4CR,EA5CQ,8EAAH,kBAAHN,CAAAA,GAAG,gEAAT","sourcesContent":["import { getNeighbourNodes, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const path = [];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            path.unshift(currCord);\n            visited[currCord] = 1;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}