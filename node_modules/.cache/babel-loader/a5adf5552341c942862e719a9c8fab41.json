{"ast":null,"code":"import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js';\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js';\nexport const aStar = (startCord, targetCord, gridState, rows, cols, timeout) => {\n  let openSet = {\n    [startCord]: 0\n  };\n  let G = {\n    [startCord]: 0\n  }; // G(n) => tell us the current shortest distance from start node to node n\n\n  let H = {\n    [startCord]: 0\n  }; // H(n) => tells us the estimated distance from node n to target node\n\n  let F = {\n    [startCord]: 0\n  }; // F(n) = G(n) + H(n)\n\n  let visited = {};\n  let prevNodes = {}; // intialize all the scores to infinity for all node !== start node\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      let cord = `${x}:${y}`;\n\n      if (cord !== startCord) {\n        F[cord] = G[cord] = H[cord] = Infinity;\n      }\n    }\n  }\n\n  while (Object.keys(openSet).length > 0) {\n    const currNode = findMinPriorityNode(openSet);\n    delete openSet[currNode];\n\n    if (currNode !== startCord && currNode !== targetCord) {\n      const nodeStateFunc = gridState[currNode][1];\n      setTimeout(() => {\n        nodeStateFunc(prevState => [nodeTypeEnum.visited, ...prevState.slice(1)]);\n      }, timeout);\n    } else if (currNode === targetCord) {\n      // we have reached target, return path\n      return createPath(startCord, targetCord, prevNodes);\n    }\n\n    const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n\n    for (const neighbour of neighbours) {\n      const currGScore = G[currNode] + nodeWeight[gridState[neighbour][0][0]];\n\n      if (currGScore < G[neighbour]) {\n        if (!(neighbour in visited)) {\n          visited[neighbour] = 1;\n\n          if (neighbour !== startCord && neighbour !== targetCord) {\n            const nodeStateFunc = gridState[neighbour][1];\n            setTimeout(() => {\n              nodeStateFunc(prevState => [nodeTypeEnum.visiting, ...prevState]);\n            }, timeout);\n          } // newly calculated G score of neighbour is lower than the one in the table\n          // update all the scores\n\n\n          G[neighbour] = currGScore;\n          H[neighbour] = h(neighbour, targetCord);\n          F[neighbour] = G[neighbour] + H[neighbour];\n          prevNodes[neighbour] = currNode;\n          openSet[neighbour] = F[neighbour];\n        }\n      }\n    }\n  }\n\n  return [];\n}; // this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\n\nconst h = (currNodeCord, targetCord) => {\n  if (currNodeCord === targetCord) {\n    return 0;\n  }\n\n  const currRow = parseInt(currNodeCord.split(':')[0]);\n  const currCol = parseInt(currNodeCord.split(':')[1]);\n  const targetRow = parseInt(targetCord.split(':')[0]);\n  const targetCol = parseInt(targetCord.split(':')[1]);\n  return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/aStar.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","nodeWeight","nodeTypeEnum","aStar","startCord","targetCord","gridState","rows","cols","timeout","openSet","G","H","F","visited","prevNodes","x","y","cord","Infinity","Object","keys","length","currNode","nodeStateFunc","setTimeout","prevState","slice","neighbours","neighbour","currGScore","visiting","h","currNodeCord","currRow","parseInt","split","currCol","targetRow","targetCol","Math","abs"],"mappings":"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","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const aStar = (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let G = { [startCord]: 0 }; // G(n) => tell us the current shortest distance from start node to node n\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = G(n) + H(n)\n    let visited = {};\n    let prevNodes = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = G[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            setTimeout(() => {\n                nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n            }, timeout);\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currGScore = G[currNode] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (currGScore < G[neighbour]) {\n                if (!(neighbour in visited)) {\n                    visited[neighbour] = 1;\n                    if (neighbour !== startCord && neighbour !== targetCord) {\n                        const nodeStateFunc = gridState[neighbour][1];\n                        setTimeout(() => {\n                            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                        }, timeout);\n                    }\n                    // newly calculated G score of neighbour is lower than the one in the table\n                    // update all the scores\n                    G[neighbour] = currGScore;\n                    H[neighbour] = h(neighbour, targetCord);\n                    F[neighbour] = G[neighbour] + H[neighbour];\n                    prevNodes[neighbour] = currNode;\n                    openSet[neighbour] = F[neighbour];\n                }\n            }\n        }\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst h = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};"]},"metadata":{},"sourceType":"module"}