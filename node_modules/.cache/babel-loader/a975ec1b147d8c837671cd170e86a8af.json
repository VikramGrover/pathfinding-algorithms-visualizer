{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getNeighbourNodes,createPath,findMinPriorityNode,sleep}from'../../utils/helper.js';import{nodeWeight,nodeTypeEnum}from'../../utils/constants.js';export var dijkstras=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,rows,cols,timeout){var totalCosts,prevNodes,minPQ,visited,x,y,cord,minKey,nodeStateFunc,neighbours,_iterator,_step,neighbour,currPath,_nodeStateFunc;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:totalCosts={};prevNodes={};minPQ={};visited={};totalCosts[startCord]=0;minPQ[startCord]=0;for(x=0;x<rows;x++){for(y=0;y<cols;y++){cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){totalCosts[cord]=Infinity;}}}case 7:if(!(Object.keys(minPQ).length>0)){_context.next=42;break;}minKey=findMinPriorityNode(minPQ);delete minPQ[minKey];visited[minKey]=1;if(!(minKey!==startCord&&minKey!==targetCord)){_context.next=16;break;}nodeStateFunc=gridState[minKey][1];nodeStateFunc(function(prevState){return[nodeTypeEnum.visited].concat(_toConsumableArray(prevState.slice(1)));});_context.next=18;break;case 16:if(!(minKey===targetCord)){_context.next=18;break;}return _context.abrupt(\"return\",createPath(startCord,targetCord,prevNodes));case 18:neighbours=getNeighbourNodes(minKey,rows,cols,gridState);_iterator=_createForOfIteratorHelper(neighbours);_context.prev=20;_iterator.s();case 22:if((_step=_iterator.n()).done){_context.next=30;break;}neighbour=_step.value;currPath=totalCosts[minKey]+nodeWeight[gridState[neighbour][0][0]];if(!(neighbour in visited)){_context.next=27;break;}return _context.abrupt(\"continue\",28);case 27:if(neighbour in minPQ&&currPath<totalCosts[neighbour]||!(neighbour in minPQ)){totalCosts[neighbour]=currPath;prevNodes[neighbour]=minKey;minPQ[neighbour]=currPath;if(neighbour!==targetCord){_nodeStateFunc=gridState[neighbour][1];_nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting].concat(_toConsumableArray(prevState));});}}case 28:_context.next=22;break;case 30:_context.next=35;break;case 32:_context.prev=32;_context.t0=_context[\"catch\"](20);_iterator.e(_context.t0);case 35:_context.prev=35;_iterator.f();return _context.finish(35);case 38:_context.next=40;return sleep(timeout);case 40:_context.next=7;break;case 42:return _context.abrupt(\"return\",[]);case 43:case\"end\":return _context.stop();}}},_callee,null,[[20,32,35,38]]);}));return function dijkstras(_x,_x2,_x3,_x4,_x5,_x6){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","sleep","nodeWeight","nodeTypeEnum","dijkstras","startCord","targetCord","gridState","rows","cols","timeout","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","Object","keys","length","minKey","nodeStateFunc","prevState","slice","neighbours","neighbour","currPath","visiting"],"mappings":"ixBAAA,OAASA,iBAAT,CAA4BC,UAA5B,CAAwCC,mBAAxC,CAA6DC,KAA7D,KAA0E,uBAA1E,CACA,OAASC,UAAT,CAAqBC,YAArB,KAAyC,0BAAzC,CAEA,MAAO,IAAMC,CAAAA,SAAS,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,IAAzC,CAA+CC,IAA/C,CAAqDC,OAArD,oPACjBC,UADiB,CACJ,EADI,CAEjBC,SAFiB,CAEL,EAFK,CAGjBC,KAHiB,CAGT,EAHS,CAIjBC,OAJiB,CAIP,EAJO,CAMrBH,UAAU,CAACN,SAAD,CAAV,CAAwB,CAAxB,CACAQ,KAAK,CAACR,SAAD,CAAL,CAAmB,CAAnB,CAEA,IAASU,CAAT,CAAa,CAAb,CAAgBA,CAAC,CAAGP,IAApB,CAA0BO,CAAC,EAA3B,CAA+B,CAC3B,IAASC,CAAT,CAAa,CAAb,CAAgBA,CAAC,CAAGP,IAApB,CAA0BO,CAAC,EAA3B,CAA+B,CACvBC,IADuB,WACbF,CADa,aACRC,CADQ,EAG3B,GAAIC,IAAI,GAAKZ,SAAb,CAAwB,CACpBM,UAAU,CAACM,IAAD,CAAV,CAAmBC,QAAnB,CACH,CACJ,CACJ,CAjBoB,YAmBdC,MAAM,CAACC,IAAP,CAAYP,KAAZ,EAAmBQ,MAAnB,CAA4B,CAnBd,2BAoBXC,MApBW,CAoBFtB,mBAAmB,CAACa,KAAD,CApBjB,CAqBjB,MAAOA,CAAAA,KAAK,CAACS,MAAD,CAAZ,CACAR,OAAO,CAACQ,MAAD,CAAP,CAAkB,CAAlB,CAtBiB,KAwBbA,MAAM,GAAKjB,SAAX,EAAwBiB,MAAM,GAAKhB,UAxBtB,2BAyBPiB,aAzBO,CAyBShB,SAAS,CAACe,MAAD,CAAT,CAAkB,CAAlB,CAzBT,CA0BbC,aAAa,CAAC,SAAAC,SAAS,SAAMrB,YAAY,CAACW,OAAnB,4BAA+BU,SAAS,CAACC,KAAV,CAAgB,CAAhB,CAA/B,IAAV,CAAb,CA1Ba,oCA4BRH,MAAM,GAAKhB,UA5BH,2DA6BNP,UAAU,CAACM,SAAD,CAAYC,UAAZ,CAAwBM,SAAxB,CA7BJ,UAgCXc,UAhCW,CAgCE5B,iBAAiB,CAACwB,MAAD,CAASd,IAAT,CAAeC,IAAf,CAAqBF,SAArB,CAhCnB,sCAiCOmB,UAjCP,gGAiCNC,SAjCM,aAkCPC,QAlCO,CAkCIjB,UAAU,CAACW,MAAD,CAAV,CAAqBpB,UAAU,CAACK,SAAS,CAACoB,SAAD,CAAT,CAAqB,CAArB,EAAwB,CAAxB,CAAD,CAlCnC,MAoCTA,SAAS,GAAIb,CAAAA,OApCJ,yEAwCb,GAAMa,SAAS,GAAId,CAAAA,KAAd,EAAwBe,QAAQ,CAAGjB,UAAU,CAACgB,SAAD,CAA9C,EAA8D,EAAEA,SAAS,GAAId,CAAAA,KAAf,CAAlE,CAAyF,CACrFF,UAAU,CAACgB,SAAD,CAAV,CAAwBC,QAAxB,CACAhB,SAAS,CAACe,SAAD,CAAT,CAAuBL,MAAvB,CACAT,KAAK,CAACc,SAAD,CAAL,CAAmBC,QAAnB,CACA,GAAID,SAAS,GAAKrB,UAAlB,CAA8B,CACpBiB,cADoB,CACJhB,SAAS,CAACoB,SAAD,CAAT,CAAqB,CAArB,CADI,CAE1BJ,cAAa,CAAC,SAAAC,SAAS,SAAMrB,YAAY,CAAC0B,QAAnB,4BAAgCL,SAAhC,IAAV,CAAb,CACH,CACJ,CAhDY,mPAmDXvB,CAAAA,KAAK,CAACS,OAAD,CAnDM,uEAsDd,EAtDc,8EAAH,kBAATN,CAAAA,SAAS,gEAAf","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode, sleep } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dijkstras = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            const nodeStateFunc = gridState[minKey][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}