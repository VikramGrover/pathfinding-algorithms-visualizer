{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (var y = 0; y < cols; y++) {\n    const cord1 = `${0}:${y}`;\n    const cord2 = `${rows - 1}:${y}`;\n  }\n\n  for (var x = 0; x < rows; x++) {\n    for (var y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n\n      if (x === 0 || x === rows - 1 || y === 0 || y === cols - 1) {\n        await sleep(timeout);\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n        if (currCord === startCord) {\n          state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        } else if (currCord === targetCord) {\n          state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n        setGridState(prevState => ({ ...prevState,\n          [currCord]: [state, prevState[currCord][1]]\n        }));\n      }\n    }\n  } // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n\n\n  await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n  const width = endCol - startCol + 1;\n  const height = endRow - startRow + 1;\n  let orientation = HORIZONTAL;\n\n  if (width < height) {\n    orientation = HORIZONTAL;\n  } else if (height < width) {\n    orientation = VERTICAL;\n  } else {\n    orientation = getRandomNum(HORIZONTAL, VERTICAL);\n  }\n\n  if (orientation === HORIZONTAL) {\n    // cutting horizontally\n    if (height < 3 || startRow % 2 === 1 && height === 3) {\n      return;\n    }\n\n    let sCol = startCol;\n\n    if (startCol % 2 === 1) {\n      sCol += 1;\n    }\n\n    let sRow = startRow + 2;\n\n    if (startRow % 2 === 0) {\n      sRow = startRow + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n    let randRow = getRandomNum(sRow, endRow - 2);\n    randRow = Math.floor(randRow / 2) * 2 + 1;\n\n    for (let i = startCol; i <= endCol; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${randRow}:${i}`;\n      const nodeStateFunc = gridState[currCord][1];\n      let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n      } else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n      }\n\n      nodeStateFunc(prevState => state);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [state, prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n  } else if (orientation === VERTICAL) {\n    // divide vertically \n    if (width < 3 || startCol % 2 === 1 && width === 3) {\n      return;\n    }\n\n    let sRow = startRow;\n\n    if (startRow % 2 === 1) {\n      sRow += 1;\n    }\n\n    let sCol = startCol + 2;\n\n    if (startCol % 2 === 0) {\n      sCol = startCol + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n    let randCol = getRandomNum(sCol, endCol - 2);\n    randCol = Math.floor(randCol / 2) * 2 + 1;\n\n    for (let i = startRow; i <= endRow; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${i}:${randCol}`;\n      const nodeStateFunc = gridState[currCord][1];\n      let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n      } else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n      }\n\n      nodeStateFunc(prevState => state);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [state, prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n  }\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","y","cord1","cord2","x","currCord","nodeStateFunc","state","wall","none","start","target","prevState","divide","startRow","endRow","startCol","endCol","width","height","orientation","sCol","sRow","skip","Math","floor","randRow","i","randCol"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,QAAoC,uBAApC;AAEA,MAAMC,UAAU,GAAG,CAAnB;AACA,MAAMC,QAAQ,GAAG,CAAjB;AAEA,OAAO,MAAMC,iBAAiB,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,YAAzC,EAAuDC,IAAvD,EAA6DC,IAA7D,EAAmEC,OAAnE,KAA+E;AAC5G;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAApB,EAA0BE,CAAC,EAA3B,EAA+B;AAC3B,UAAMC,KAAK,GAAI,GAAE,CAAE,IAAGD,CAAE,EAAxB;AACA,UAAME,KAAK,GAAI,GAAEL,IAAI,GAAG,CAAE,IAAGG,CAAE,EAA/B;AACH;;AAGD,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAApB,EAA0BM,CAAC,EAA3B,EAA+B;AAC3B,SAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAApB,EAA0BE,CAAC,EAA3B,EAA+B;AAC3B,YAAMI,QAAQ,GAAI,GAAED,CAAE,IAAGH,CAAE,EAA3B;AACA,YAAMK,aAAa,GAAGV,SAAS,CAACS,QAAD,CAAT,CAAoB,CAApB,CAAtB;;AACA,UAAID,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAMN,IAAI,GAAG,CAAzB,IAA+BG,CAAC,KAAK,CAArC,IAA0CA,CAAC,KAAMF,IAAI,GAAG,CAA5D,EAAgE;AAC5D,cAAMV,KAAK,CAACW,OAAD,CAAX;AACA,YAAIO,KAAK,GAAG,CAACnB,YAAY,CAACoB,IAAd,EAAoBpB,YAAY,CAACqB,IAAjC,CAAZ;;AACA,YAAIJ,QAAQ,KAAKX,SAAjB,EAA4B;AACxBa,UAAAA,KAAK,GAAG,CAACnB,YAAY,CAACsB,KAAd,EAAqBtB,YAAY,CAACoB,IAAlC,EAAwCpB,YAAY,CAACqB,IAArD,CAAR;AACH,SAFD,MAGK,IAAIJ,QAAQ,KAAKV,UAAjB,EAA6B;AAC9BY,UAAAA,KAAK,GAAG,CAACnB,YAAY,CAACuB,MAAd,EAAsBvB,YAAY,CAACoB,IAAnC,EAAyCpB,YAAY,CAACqB,IAAtD,CAAR;AACH;;AACDH,QAAAA,aAAa,CAACM,SAAS,IAAIL,KAAd,CAAb;AACAV,QAAAA,YAAY,CAACe,SAAS,KAAK,EAAE,GAAGA,SAAL;AAAgB,WAACP,QAAD,GAAY,CAACE,KAAD,EAAQK,SAAS,CAACP,QAAD,CAAT,CAAoB,CAApB,CAAR;AAA5B,SAAL,CAAV,CAAZ;AACH;AACJ;AACJ,GAzB2G,CA2B5G;;;AACA,QAAMQ,MAAM,CAACnB,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiD,CAAjD,EAAoDC,IAAI,GAAG,CAA3D,EAA8D,CAA9D,EAAiEC,IAAI,GAAG,CAAxE,EAA2EC,OAA3E,EAAoFF,IAApF,EAA0FC,IAA1F,CAAZ;AACH,CA7BM;;AA+BP,MAAMc,MAAM,GAAG,OAAOnB,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,YAAzC,EAAuDiB,QAAvD,EAAiEC,MAAjE,EAAyEC,QAAzE,EAAmFC,MAAnF,EAA2FjB,OAA3F,EAAoGF,IAApG,EAA0GC,IAA1G,KAAmH;AAC9H,QAAMmB,KAAK,GAAGD,MAAM,GAAGD,QAAT,GAAoB,CAAlC;AACA,QAAMG,MAAM,GAAGJ,MAAM,GAAGD,QAAT,GAAoB,CAAnC;AAEA,MAAIM,WAAW,GAAG7B,UAAlB;;AACA,MAAI2B,KAAK,GAAGC,MAAZ,EAAoB;AAChBC,IAAAA,WAAW,GAAG7B,UAAd;AACH,GAFD,MAGK,IAAI4B,MAAM,GAAGD,KAAb,EAAoB;AACrBE,IAAAA,WAAW,GAAG5B,QAAd;AACH,GAFI,MAGA;AACD4B,IAAAA,WAAW,GAAG9B,YAAY,CAACC,UAAD,EAAaC,QAAb,CAA1B;AACH;;AAED,MAAI4B,WAAW,KAAK7B,UAApB,EAAgC;AAC5B;AACA,QAAI4B,MAAM,GAAG,CAAT,IAAeL,QAAQ,GAAG,CAAX,KAAiB,CAAjB,IAAsBK,MAAM,KAAK,CAApD,EAAwD;AACpD;AACH;;AACD,QAAIE,IAAI,GAAGL,QAAX;;AACA,QAAIA,QAAQ,GAAG,CAAX,KAAiB,CAArB,EAAwB;AACpBK,MAAAA,IAAI,IAAI,CAAR;AACH;;AAED,QAAIC,IAAI,GAAGR,QAAQ,GAAG,CAAtB;;AACA,QAAIA,QAAQ,GAAG,CAAX,KAAiB,CAArB,EAAwB;AACpBQ,MAAAA,IAAI,GAAGR,QAAQ,GAAG,CAAlB;AACH;;AAED,UAAMS,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWnC,YAAY,CAAC+B,IAAD,EAAOJ,MAAP,CAAZ,GAA6B,CAAxC,IAA6C,CAA1D;AACA,QAAIS,OAAO,GAAGpC,YAAY,CAACgC,IAAD,EAAOP,MAAM,GAAG,CAAhB,CAA1B;AACAW,IAAAA,OAAO,GAAIF,IAAI,CAACC,KAAL,CAAWC,OAAO,GAAG,CAArB,IAA0B,CAA3B,GAAgC,CAA1C;;AAEA,SAAK,IAAIC,CAAC,GAAGX,QAAb,EAAuBW,CAAC,IAAIV,MAA5B,EAAoCU,CAAC,EAArC,EAAyC;AACrC,UAAIA,CAAC,KAAKJ,IAAV,EAAgB;AACZ;AACH;;AACD,YAAMlB,QAAQ,GAAI,GAAEqB,OAAQ,IAAGC,CAAE,EAAjC;AACA,YAAMrB,aAAa,GAAGV,SAAS,CAACS,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACA,UAAIE,KAAK,GAAG,CAACnB,YAAY,CAACoB,IAAd,EAAoBpB,YAAY,CAACqB,IAAjC,CAAZ;;AACA,UAAIJ,QAAQ,KAAKX,SAAjB,EAA4B;AACxBa,QAAAA,KAAK,GAAG,CAACnB,YAAY,CAACsB,KAAd,EAAqBtB,YAAY,CAACoB,IAAlC,EAAwCpB,YAAY,CAACqB,IAArD,CAAR;AACH,OAFD,MAGK,IAAIJ,QAAQ,KAAKV,UAAjB,EAA6B;AAC9BY,QAAAA,KAAK,GAAG,CAACnB,YAAY,CAACuB,MAAd,EAAsBvB,YAAY,CAACoB,IAAnC,EAAyCpB,YAAY,CAACqB,IAAtD,CAAR;AACH;;AACDH,MAAAA,aAAa,CAACM,SAAS,IAAIL,KAAd,CAAb;AACAV,MAAAA,YAAY,CAACe,SAAS,KAAK,EAAE,GAAGA,SAAL;AAAgB,SAACP,QAAD,GAAY,CAACE,KAAD,EAAQK,SAAS,CAACP,QAAD,CAAT,CAAoB,CAApB,CAAR;AAA5B,OAAL,CAAV,CAAZ;AACA,YAAMhB,KAAK,CAACW,OAAD,CAAX;AACH;;AAED,UAAMa,MAAM,CAACnB,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiDiB,QAAjD,EAA2DY,OAAO,GAAG,CAArE,EAAwEV,QAAxE,EAAkFC,MAAlF,EAA0FjB,OAA1F,EAAmGF,IAAnG,EAAyGC,IAAzG,CAAZ;AACA,UAAMc,MAAM,CAACnB,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiD6B,OAAO,GAAG,CAA3D,EAA8DX,MAA9D,EAAsEC,QAAtE,EAAgFC,MAAhF,EAAwFjB,OAAxF,EAAiGF,IAAjG,EAAuGC,IAAvG,CAAZ;AACH,GAvCD,MAwCK,IAAIqB,WAAW,KAAK5B,QAApB,EAA8B;AAC/B;AACA,QAAI0B,KAAK,GAAG,CAAR,IAAcF,QAAQ,GAAG,CAAX,KAAiB,CAAjB,IAAsBE,KAAK,KAAK,CAAlD,EAAsD;AAClD;AACH;;AACD,QAAII,IAAI,GAAGR,QAAX;;AACA,QAAIA,QAAQ,GAAG,CAAX,KAAiB,CAArB,EAAwB;AACpBQ,MAAAA,IAAI,IAAI,CAAR;AACH;;AAED,QAAID,IAAI,GAAGL,QAAQ,GAAG,CAAtB;;AACA,QAAIA,QAAQ,GAAG,CAAX,KAAiB,CAArB,EAAwB;AACpBK,MAAAA,IAAI,GAAGL,QAAQ,GAAG,CAAlB;AACH;;AACD,UAAMO,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWnC,YAAY,CAACgC,IAAD,EAAOP,MAAP,CAAZ,GAA6B,CAAxC,IAA6C,CAA1D;AACA,QAAIa,OAAO,GAAGtC,YAAY,CAAC+B,IAAD,EAAOJ,MAAM,GAAG,CAAhB,CAA1B;AACAW,IAAAA,OAAO,GAAIJ,IAAI,CAACC,KAAL,CAAWG,OAAO,GAAG,CAArB,IAA0B,CAA3B,GAAgC,CAA1C;;AAEA,SAAK,IAAID,CAAC,GAAGb,QAAb,EAAuBa,CAAC,IAAIZ,MAA5B,EAAoCY,CAAC,EAArC,EAAyC;AACrC,UAAIA,CAAC,KAAKJ,IAAV,EAAgB;AACZ;AACH;;AACD,YAAMlB,QAAQ,GAAI,GAAEsB,CAAE,IAAGC,OAAQ,EAAjC;AACA,YAAMtB,aAAa,GAAGV,SAAS,CAACS,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACA,UAAIE,KAAK,GAAG,CAACnB,YAAY,CAACoB,IAAd,EAAoBpB,YAAY,CAACqB,IAAjC,CAAZ;;AACA,UAAIJ,QAAQ,KAAKX,SAAjB,EAA4B;AACxBa,QAAAA,KAAK,GAAG,CAACnB,YAAY,CAACsB,KAAd,EAAqBtB,YAAY,CAACoB,IAAlC,EAAwCpB,YAAY,CAACqB,IAArD,CAAR;AACH,OAFD,MAGK,IAAIJ,QAAQ,KAAKV,UAAjB,EAA6B;AAC9BY,QAAAA,KAAK,GAAG,CAACnB,YAAY,CAACuB,MAAd,EAAsBvB,YAAY,CAACoB,IAAnC,EAAyCpB,YAAY,CAACqB,IAAtD,CAAR;AACH;;AACDH,MAAAA,aAAa,CAACM,SAAS,IAAIL,KAAd,CAAb;AACAV,MAAAA,YAAY,CAACe,SAAS,KAAK,EAAE,GAAGA,SAAL;AAAgB,SAACP,QAAD,GAAY,CAACE,KAAD,EAAQK,SAAS,CAACP,QAAD,CAAT,CAAoB,CAApB,CAAR;AAA5B,OAAL,CAAV,CAAZ;AACA,YAAMhB,KAAK,CAACW,OAAD,CAAX;AACH;;AAED,UAAMa,MAAM,CAACnB,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiDiB,QAAjD,EAA2DC,MAA3D,EAAmEC,QAAnE,EAA6EY,OAAO,GAAG,CAAvF,EAA0F5B,OAA1F,EAAmGF,IAAnG,EAAyGC,IAAzG,CAAZ;AAEA,UAAMc,MAAM,CAACnB,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiDiB,QAAjD,EAA2DC,MAA3D,EAAmEa,OAAO,GAAG,CAA7E,EAAgFX,MAAhF,EAAwFjB,OAAxF,EAAiGF,IAAjG,EAAuGC,IAAvG,CAAZ;AACH;AACJ,CA/FD","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (var y = 0; y < cols; y++) {\n        const cord1 = `${0}:${y}`;\n        const cord2 = `${rows - 1}:${y}`;\n    }\n\n\n    for (var x = 0; x < rows; x++) {\n        for (var y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            if (x === 0 || x === (rows - 1) || y === 0 || y === (cols - 1)) {\n                await sleep(timeout);\n                let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n                if (currCord === startCord) {\n                    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                else if (currCord === targetCord) {\n                    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                nodeStateFunc(prevState => state);\n                setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            }\n        }\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};"]},"metadata":{},"sourceType":"module"}