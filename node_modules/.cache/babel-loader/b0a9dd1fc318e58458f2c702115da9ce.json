{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (var y = 0; y < cols; y++) {\n    const currCord = `${0}:${y}`;\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n    if (currCord === startCord) {\n      state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    } else if (currCord === targetCord) {\n      state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState,\n      [currCord]: [state, prevState[currCord][1]]\n    }));\n    await sleep(timeout);\n  }\n\n  for (var y = 0; y < rows; y++) {\n    const currCord = `${y}:${cols - 1}`;\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n    if (currCord === startCord) {\n      state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    } else if (currCord === targetCord) {\n      state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState,\n      [currCord]: [state, prevState[currCord][1]]\n    }));\n    await sleep(timeout);\n  }\n\n  for (var y = 0; y < cols; y++) {\n    const currCord = `${rows - 1}:${y}`;\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n    if (currCord === startCord) {\n      state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    } else if (currCord === targetCord) {\n      state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState,\n      [currCord]: [state, prevState[currCord][1]]\n    }));\n    await sleep(timeout);\n  }\n\n  for (var y = rows - 2; y > 0; y--) {\n    const currCord = `${y}:${0}`;\n    setWall(currCord, startCord, targetCord, gridState);\n    await sleep(timeout);\n  } // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n\n\n  await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n  const width = endCol - startCol + 1;\n  const height = endRow - startRow + 1;\n  let orientation = HORIZONTAL;\n\n  if (width < height) {\n    orientation = HORIZONTAL;\n  } else if (height < width) {\n    orientation = VERTICAL;\n  } else {\n    orientation = getRandomNum(HORIZONTAL, VERTICAL);\n  }\n\n  if (orientation === HORIZONTAL) {\n    // cutting horizontally\n    if (height < 3 || startRow % 2 === 1 && height === 3) {\n      return;\n    }\n\n    let sCol = startCol;\n\n    if (startCol % 2 === 1) {\n      sCol += 1;\n    }\n\n    let sRow = startRow + 2;\n\n    if (startRow % 2 === 0) {\n      sRow = startRow + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n    let randRow = getRandomNum(sRow, endRow - 2);\n    randRow = Math.floor(randRow / 2) * 2 + 1;\n\n    for (let i = startCol; i <= endCol; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${randRow}:${i}`;\n      const nodeStateFunc = gridState[currCord][1];\n      let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n      } else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n      }\n\n      nodeStateFunc(prevState => state);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [state, prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n  } else if (orientation === VERTICAL) {\n    // divide vertically \n    if (width < 3 || startCol % 2 === 1 && width === 3) {\n      return;\n    }\n\n    let sRow = startRow;\n\n    if (startRow % 2 === 1) {\n      sRow += 1;\n    }\n\n    let sCol = startCol + 2;\n\n    if (startCol % 2 === 0) {\n      sCol = startCol + 1;\n    }\n\n    const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n    let randCol = getRandomNum(sCol, endCol - 2);\n    randCol = Math.floor(randCol / 2) * 2 + 1;\n\n    for (let i = startRow; i <= endRow; i++) {\n      if (i === skip) {\n        continue;\n      }\n\n      const currCord = `${i}:${randCol}`;\n      const nodeStateFunc = gridState[currCord][1];\n      let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n      if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n      } else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n      }\n\n      nodeStateFunc(prevState => state);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [state, prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n    await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n  }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState) => {\n  const nodeStateFunc = gridState[currCord][1];\n  let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n  if (currCord === startCord) {\n    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n  } else if (currCord === targetCord) {\n    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n  }\n\n  nodeStateFunc(prevState => state);\n  setGridState(prevState => ({ ...prevState,\n    [currCord]: [state, prevState[currCord][1]]\n  }));\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","y","currCord","state","wall","none","start","target","nodeStateFunc","prevState","setWall","divide","startRow","endRow","startCol","endCol","width","height","orientation","sCol","sRow","skip","Math","floor","randRow","i","randCol"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n\n    // make border around the screen\n    for (var y = 0; y < cols; y++) {\n        const currCord = `${0}:${y}`;\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n        if (currCord === startCord) {\n            state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n        else if (currCord === targetCord) {\n            state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n        setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n        await sleep(timeout);\n    }\n\n    for (var y = 0; y < rows; y++) {\n        const currCord = `${y}:${cols - 1}`;\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n        if (currCord === startCord) {\n            state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n        else if (currCord === targetCord) {\n            state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n        setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n        await sleep(timeout);\n    }\n\n    for (var y = 0; y < cols; y++) {\n        const currCord = `${rows - 1}:${y}`;\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n        if (currCord === startCord) {\n            state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n        else if (currCord === targetCord) {\n            state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n        setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n        await sleep(timeout);\n    }\n\n    for (var y = rows - 2; y > 0; y--) {\n        const currCord = `${y}:${0}`;\n        setWall(currCord, startCord, targetCord, gridState);\n        await sleep(timeout);\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState) => {\n    const nodeStateFunc = gridState[currCord][1];\n\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n    if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n    else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n};"]},"metadata":{},"sourceType":"module"}