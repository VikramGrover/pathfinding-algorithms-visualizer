{"ast":null,"code":"import _slicedToArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import Node from'./Node.js';import React from'react';import{useState}from'react';import{nodeTypeEnum}from'../utils/constants.js';import{jsx as _jsx}from\"react/jsx-runtime\";var Grid=/*#__PURE__*/React.memo(function(_ref){var rows=_ref.rows,cols=_ref.cols,padding=_ref.padding,nodeSize=_ref.nodeSize,setGridState=_ref.setGridState,selectedObstacle=_ref.selectedObstacle,setStartCord=_ref.setStartCord,setTargetCord=_ref.setTargetCord,runningAlgo=_ref.runningAlgo;var _useState=useState(nodeTypeEnum.none),_useState2=_slicedToArray(_useState,2),draggingSelection=_useState2[0],setDraggingSelection=_useState2[1];// fill nodes in the grid\nconsole.log(\"RERENDERING GRID\");var nodes=[];for(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var nodeId=\"\".concat(x,\":\").concat(y);var startingState=[nodeTypeEnum.none];if(x===1&&y===1){startingState.unshift(nodeTypeEnum.start);}else if(x===rows-2&&y===cols-2){startingState.unshift(nodeTypeEnum.target);}nodes.push(/*#__PURE__*/_jsx(Node,{nodeId:nodeId,size:nodeSize,setGridState:setGridState,draggingSelection:draggingSelection,setDraggingSelection:setDraggingSelection,setStartCord:setStartCord,setTargetCord:setTargetCord,runningAlgo:runningAlgo,selectedObstacle:selectedObstacle,startingState:startingState},nodeId));}}var gridDimensions={width:cols*nodeSize+cols,height:rows*nodeSize+rows};var containerStyle={paddingLeft:padding,paddingRight:padding};return/*#__PURE__*/_jsx(\"div\",{style:containerStyle,children:/*#__PURE__*/_jsx(\"div\",{className:\"grid\",style:gridDimensions,children:nodes})});});export default Grid;","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/components/Grid.js"],"names":["Node","React","useState","nodeTypeEnum","Grid","memo","rows","cols","padding","nodeSize","setGridState","selectedObstacle","setStartCord","setTargetCord","runningAlgo","none","draggingSelection","setDraggingSelection","console","log","nodes","x","y","nodeId","startingState","unshift","start","target","push","gridDimensions","width","height","containerStyle","paddingLeft","paddingRight"],"mappings":"6LAAA,MAAOA,CAAAA,IAAP,KAAiB,WAAjB,CACA,MAAOC,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,QAAT,KAAyB,OAAzB,CACA,OAASC,YAAT,KAA6B,uBAA7B,C,2CAEA,GAAMC,CAAAA,IAAI,cAAGH,KAAK,CAACI,IAAN,CAAW,cAAiH,IAA9GC,CAAAA,IAA8G,MAA9GA,IAA8G,CAAxGC,IAAwG,MAAxGA,IAAwG,CAAlGC,OAAkG,MAAlGA,OAAkG,CAAzFC,QAAyF,MAAzFA,QAAyF,CAA/EC,YAA+E,MAA/EA,YAA+E,CAAjEC,gBAAiE,MAAjEA,gBAAiE,CAA/CC,YAA+C,MAA/CA,YAA+C,CAAjCC,aAAiC,MAAjCA,aAAiC,CAAlBC,WAAkB,MAAlBA,WAAkB,eACnFZ,QAAQ,CAACC,YAAY,CAACY,IAAd,CAD2E,wCAC9HC,iBAD8H,eAC3GC,oBAD2G,eAGrI;AACAC,OAAO,CAACC,GAAR,CAAY,kBAAZ,EACA,GAAMC,CAAAA,KAAK,CAAG,EAAd,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGf,IAApB,CAA0Be,CAAC,EAA3B,CAA+B,CAC3B,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGf,IAApB,CAA0Be,CAAC,EAA3B,CAA+B,CAC3B,GAAIC,CAAAA,MAAM,WAAMF,CAAN,aAAWC,CAAX,CAAV,CAEA,GAAIE,CAAAA,aAAa,CAAG,CAACrB,YAAY,CAACY,IAAd,CAApB,CACA,GAAIM,CAAC,GAAK,CAAN,EAAWC,CAAC,GAAK,CAArB,CAAwB,CACpBE,aAAa,CAACC,OAAd,CAAsBtB,YAAY,CAACuB,KAAnC,EACH,CAFD,IAGK,IAAIL,CAAC,GAAMf,IAAI,CAAG,CAAd,EAAoBgB,CAAC,GAAMf,IAAI,CAAG,CAAtC,CAA0C,CAC3CiB,aAAa,CAACC,OAAd,CAAsBtB,YAAY,CAACwB,MAAnC,EACH,CAEDP,KAAK,CAACQ,IAAN,cAAW,KAAC,IAAD,EAAM,MAAM,CAAEL,MAAd,CACP,IAAI,CAAEd,QADC,CACS,YAAY,CAAEC,YADvB,CAEP,iBAAiB,CAAEM,iBAFZ,CAGP,oBAAoB,CAAEC,oBAHf,CAIP,YAAY,CAAEL,YAJP,CAIqB,aAAa,CAAEC,aAJpC,CAImD,WAAW,CAAEC,WAJhE,CAI6E,gBAAgB,CAAEH,gBAJ/F,CAIiH,aAAa,CAAEa,aAJhI,EAIoJD,MAJpJ,CAAX,EAKH,CACJ,CAED,GAAMM,CAAAA,cAAc,CAAG,CACnBC,KAAK,CAAGvB,IAAI,CAAGE,QAAR,CAAoBF,IADR,CAEnBwB,MAAM,CAAGzB,IAAI,CAAGG,QAAR,CAAoBH,IAFT,CAAvB,CAKA,GAAM0B,CAAAA,cAAc,CAAG,CACnBC,WAAW,CAAEzB,OADM,CAEnB0B,YAAY,CAAE1B,OAFK,CAAvB,CAKA,mBACI,YAAK,KAAK,CAAEwB,cAAZ,uBACI,YAAK,SAAS,CAAC,MAAf,CAAsB,KAAK,CAAEH,cAA7B,UACKT,KADL,EADJ,EADJ,CAOH,CA3CY,CAAb,CA6CA,cAAehB,CAAAA,IAAf","sourcesContent":["import Node from './Node.js'\nimport React from 'react'\nimport { useState } from 'react'\nimport { nodeTypeEnum } from '../utils/constants.js'\n\nconst Grid = React.memo(({ rows, cols, padding, nodeSize, setGridState, selectedObstacle, setStartCord, setTargetCord, runningAlgo }) => {\n    const [draggingSelection, setDraggingSelection] = useState(nodeTypeEnum.none);\n\n    // fill nodes in the grid\n    console.log(\"RERENDERING GRID\");\n    const nodes = [];\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let nodeId = `${x}:${y}`\n\n            let startingState = [nodeTypeEnum.none];\n            if (x === 1 && y === 1) {\n                startingState.unshift(nodeTypeEnum.start);\n            }\n            else if (x === (rows - 2) && y === (cols - 2)) {\n                startingState.unshift(nodeTypeEnum.target);\n            }\n\n            nodes.push(<Node nodeId={nodeId}\n                size={nodeSize} setGridState={setGridState}\n                draggingSelection={draggingSelection}\n                setDraggingSelection={setDraggingSelection}\n                setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} selectedObstacle={selectedObstacle} startingState={startingState} key={nodeId} />);\n        }\n    }\n\n    const gridDimensions = {\n        width: (cols * nodeSize) + cols,\n        height: (rows * nodeSize) + rows\n    };\n\n    const containerStyle = {\n        paddingLeft: padding,\n        paddingRight: padding\n    }\n\n    return (\n        <div style={containerStyle}>\n            <div className='grid' style={gridDimensions}>\n                {nodes}\n            </div >\n        </div>\n    )\n});\n\nexport default Grid\n"]},"metadata":{},"sourceType":"module"}