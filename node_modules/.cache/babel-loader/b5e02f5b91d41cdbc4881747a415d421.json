{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNodeTypeEnum,getNodeWeight,getNeighbourNodes,createPath,findMinPriorityNode}from'../../utils/util.js';export var aStar=function aStar(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var openSet=_defineProperty({},startCord,0);var G=_defineProperty({},startCord,0);// G(n) => tell us the current shortest distance from start node to node n\nvar H=_defineProperty({},startCord,0);// H(n) => tells us the estimated distance from node n to target node\nvar F=_defineProperty({},startCord,0);// F(n) = G(n) + H(n)\nvar prevNodes={};// intialize all the scores to infinity for all node !== start node\nfor(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){F[cord]=G[cord]=H[cord]=Infinity;}}}var _loop=function _loop(){var currNode=findMinPriorityNode(openSet);delete openSet[currNode];if(currNode!==startCord&&currNode!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currNode,[getNodeTypeEnum('visited')].concat(_toConsumableArray(prevState[currNode].slice(1)))));});},timeout);}else if(currNode===targetCord){// we have reached target, return path\nreturn{v:createPath(startCord,targetCord,prevNodes)};}var neighbours=getNeighbourNodes(currNode,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{var _loop2=function _loop2(){var neighbour=_step.value;var currGScore=G[currNode]+getNodeWeight(gridState[neighbour][0]);if(currGScore<G[neighbour]){if(neighbour!==startCord&&neighbour!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},neighbour,[getNodeTypeEnum('visiting')].concat(_toConsumableArray(prevState[neighbour]))));});},timeout);}// newly calculated G score of neighbour is lower than the one in the table\n// update all the scores\nG[neighbour]=currGScore;H[neighbour]=getHScoreEstimate(neighbour,targetCord);F[neighbour]=G[neighbour]+H[neighbour];prevNodes[neighbour]=currNode;openSet[neighbour]=F[neighbour];}};for(_iterator.s();!(_step=_iterator.n()).done;){_loop2();}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(Object.keys(openSet).length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nvar getHScoreEstimate=function getHScoreEstimate(currNodeCord,targetCord){if(currNodeCord===targetCord){return 0;}var currRow=parseInt(currNodeCord.split(':')[0]);var currCol=parseInt(currNodeCord.split(':')[1]);var targetRow=parseInt(targetCord.split(':')[0]);var targetCol=parseInt(targetCord.split(':')[1]);return Math.abs(currRow-targetRow)+Math.abs(currCol-targetCol);};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/aStar.js"],"names":["getNodeTypeEnum","getNodeWeight","getNeighbourNodes","createPath","findMinPriorityNode","aStar","startCord","targetCord","gridState","setGridState","rows","cols","timeout","openSet","G","H","F","prevNodes","x","y","cord","Infinity","currNode","setTimeout","prevState","slice","neighbours","neighbour","currGScore","getHScoreEstimate","Object","keys","length","currNodeCord","currRow","parseInt","split","currCol","targetRow","targetCol","Math","abs"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight, getNeighbourNodes, createPath, findMinPriorityNode } from '../../utils/util.js'\n\nexport const aStar = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let G = { [startCord]: 0 }; // G(n) => tell us the current shortest distance from start node to node n\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = G(n) + H(n)\n    let prevNodes = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = G[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currNode]: [getNodeTypeEnum('visited'), ...prevState[currNode].slice(1)] }));\n            }, timeout);\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currGScore = G[currNode] + getNodeWeight(gridState[neighbour][0]);\n\n            if (currGScore < G[neighbour]) {\n                if (neighbour !== startCord && neighbour !== targetCord) {\n                    setTimeout(() => {\n                        setGridState(prevState => ({ ...prevState, [neighbour]: [getNodeTypeEnum('visiting'), ...prevState[neighbour]] }));\n                    }, timeout);\n                }\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                G[neighbour] = currGScore;\n                H[neighbour] = getHScoreEstimate(neighbour, targetCord);\n                F[neighbour] = G[neighbour] + H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst getHScoreEstimate = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};"]},"metadata":{},"sourceType":"module"}