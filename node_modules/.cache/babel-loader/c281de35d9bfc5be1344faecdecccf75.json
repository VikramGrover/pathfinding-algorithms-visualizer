{"ast":null,"code":"import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{nodeTypeEnum}from'../../utils/constants.js';import{sleep,getRandomNum}from'../../utils/helper.js';var HORIZONTAL=0;var VERTICAL=1;export var recursiveDivision=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var y,currCord,_y,_currCord,_y2,_currCord2,_y3,_currCord3;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:y=0;case 1:if(!(y<cols)){_context.next=9;break;}currCord=\"\".concat(0,\":\",y);setWall(currCord,startCord,targetCord,gridState,setGridState);_context.next=6;return sleep(timeout);case 6:y++;_context.next=1;break;case 9:_y=1;case 10:if(!(_y<rows)){_context.next=18;break;}_currCord=\"\".concat(_y,\":\").concat(cols-1);setWall(_currCord,startCord,targetCord,gridState,setGridState);_context.next=15;return sleep(timeout);case 15:_y++;_context.next=10;break;case 18:_y2=cols-2;case 19:if(!(_y2>=0)){_context.next=27;break;}_currCord2=\"\".concat(rows-1,\":\").concat(_y2);setWall(_currCord2,startCord,targetCord,gridState,setGridState);_context.next=24;return sleep(timeout);case 24:_y2--;_context.next=19;break;case 27:_y3=rows-2;case 28:if(!(_y3>0)){_context.next=36;break;}_currCord3=\"\".concat(_y3,\":\",0);setWall(_currCord3,startCord,targetCord,gridState,setGridState);_context.next=33;return sleep(timeout);case 33:_y3--;_context.next=28;break;case 36:_context.next=38;return divide(startCord,targetCord,gridState,setGridState,1,rows-2,1,cols-2,timeout,rows,cols);case 38:case\"end\":return _context.stop();}}},_callee);}));return function recursiveDivision(_x,_x2,_x3,_x4,_x5,_x6,_x7){return _ref.apply(this,arguments);};}();var divide=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(startCord,targetCord,gridState,setGridState,startRow,endRow,startCol,endCol,timeout,rows,cols){var width,height,orientation,sCol,sRow,skip,randRow,i,currCord,_sRow,_sCol,_skip,randCol,_i,_currCord4;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:width=endCol-startCol+1;height=endRow-startRow+1;orientation=HORIZONTAL;if(width<height){orientation=HORIZONTAL;}else if(height<width){orientation=VERTICAL;}else{orientation=getRandomNum(HORIZONTAL,VERTICAL);}if(!(orientation===HORIZONTAL)){_context2.next=31;break;}if(!(height<3||startRow%2===1&&height===3)){_context2.next=7;break;}return _context2.abrupt(\"return\");case 7:sCol=startCol;if(startCol%2===1){sCol+=1;}sRow=startRow+2;if(startRow%2===0){sRow=startRow+1;}skip=Math.floor(getRandomNum(sCol,endCol)/2)*2;randRow=getRandomNum(sRow,endRow-2);randRow=Math.floor(randRow/2)*2+1;i=startCol;case 15:if(!(i<=endCol)){_context2.next=25;break;}if(!(i===skip)){_context2.next=18;break;}return _context2.abrupt(\"continue\",22);case 18:currCord=\"\".concat(randRow,\":\").concat(i);setWall(currCord,startCord,targetCord,gridState,setGridState);_context2.next=22;return sleep(timeout);case 22:i++;_context2.next=15;break;case 25:_context2.next=27;return divide(startCord,targetCord,gridState,setGridState,startRow,randRow-1,startCol,endCol,timeout,rows,cols);case 27:_context2.next=29;return divide(startCord,targetCord,gridState,setGridState,randRow+1,endRow,startCol,endCol,timeout,rows,cols);case 29:_context2.next=56;break;case 31:if(!(orientation===VERTICAL)){_context2.next=56;break;}if(!(width<3||startCol%2===1&&width===3)){_context2.next=34;break;}return _context2.abrupt(\"return\");case 34:_sRow=startRow;if(startRow%2===1){_sRow+=1;}_sCol=startCol+2;if(startCol%2===0){_sCol=startCol+1;}_skip=Math.floor(getRandomNum(_sRow,endRow)/2)*2;randCol=getRandomNum(_sCol,endCol-2);randCol=Math.floor(randCol/2)*2+1;_i=startRow;case 42:if(!(_i<=endRow)){_context2.next=52;break;}if(!(_i===_skip)){_context2.next=45;break;}return _context2.abrupt(\"continue\",49);case 45:_currCord4=\"\".concat(_i,\":\").concat(randCol);setWall(_currCord4,startCord,targetCord,gridState,setGridState);_context2.next=49;return sleep(timeout);case 49:_i++;_context2.next=42;break;case 52:_context2.next=54;return divide(startCord,targetCord,gridState,setGridState,startRow,endRow,startCol,randCol-1,timeout,rows,cols);case 54:_context2.next=56;return divide(startCord,targetCord,gridState,setGridState,startRow,endRow,randCol+1,endCol,timeout,rows,cols);case 56:case\"end\":return _context2.stop();}}},_callee2);}));return function divide(_x8,_x9,_x10,_x11,_x12,_x13,_x14,_x15,_x16,_x17,_x18){return _ref2.apply(this,arguments);};}();var setWall=function setWall(currCord,startCord,targetCord,gridState,setGridState){var nodeStateFunc=gridState[currCord][1];var state=[nodeTypeEnum.wall,nodeTypeEnum.none];if(currCord===startCord){state=[nodeTypeEnum.start,nodeTypeEnum.wall,nodeTypeEnum.none];}else if(currCord===targetCord){state=[nodeTypeEnum.target,nodeTypeEnum.wall,nodeTypeEnum.none];}nodeStateFunc(function(prevState){return state;});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[state,prevState[currCord][1]]));});};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","y","currCord","setWall","divide","startRow","endRow","startCol","endCol","width","height","orientation","sCol","sRow","skip","Math","floor","randRow","i","randCol","nodeStateFunc","state","wall","none","start","target","prevState"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (let y = 0; y < cols; y++) {\n        const currCord = `${0}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = 1; y < rows; y++) {\n        const currCord = `${y}:${cols - 1}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = cols - 2; y >= 0; y--) {\n        const currCord = `${rows - 1}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = rows - 2; y > 0; y--) {\n        const currCord = `${y}:${0}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            setWall(currCord, startCord, targetCord, gridState, setGridState);\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            setWall(currCord, startCord, targetCord, gridState, setGridState);\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState, setGridState) => {\n    const nodeStateFunc = gridState[currCord][1];\n\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n    if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n    else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n};"]},"metadata":{},"sourceType":"module"}