{"ast":null,"code":"import { nodeTypeEnum, unweightedPathAlgos } from './constants.js';\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};\nexport const createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\nexport const findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\nexport const isAlgoUnweighted = algo => {\n  return unweightedPathAlgos.includes(algo);\n};\nexport const isAlgoOptimal = algo => {\n  return optimalPathAlgos.includes(algo);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/helper.js"],"names":["nodeTypeEnum","unweightedPathAlgos","getNeighbourNodes","node","rows","cols","gridState","row","parseInt","split","col","res","wall","push","createPath","startCord","targetCord","prevNodes","cord","path","findMinPriorityNode","minPQ","minPriority","Math","min","Object","values","key","isAlgoUnweighted","algo","includes","isAlgoOptimal","optimalPathAlgos"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,mBAAvB,QAAkD,gBAAlD;AAEA,OAAO,MAAMC,iBAAiB,GAAG,CAACC,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBC,SAAnB,KAAiC;AAC9D,QAAMC,GAAG,GAAGC,QAAQ,CAACL,IAAI,CAACM,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAD,CAApB;AACA,QAAMC,GAAG,GAAGF,QAAQ,CAACL,IAAI,CAACM,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAD,CAApB;AAEA,MAAIE,GAAG,GAAG,EAAV;;AACA,MAAKJ,GAAG,GAAG,CAAN,IAAW,CAAZ,IAAmBD,SAAS,CAAE,GAAEC,GAAG,GAAG,CAAE,IAAGG,GAAI,EAAnB,CAAT,CAA+B,CAA/B,MAAsCV,YAAY,CAACY,IAA1E,EAAiF;AAC7ED,IAAAA,GAAG,CAACE,IAAJ,CAAU,GAAEN,GAAG,GAAG,CAAE,IAAGG,GAAI,EAA3B;AACH;;AACD,MAAKA,GAAG,GAAG,CAAN,GAAUL,IAAX,IAAqBC,SAAS,CAAE,GAAEC,GAAI,IAAGG,GAAG,GAAG,CAAE,EAAnB,CAAT,CAA+B,CAA/B,MAAsCV,YAAY,CAACY,IAA5E,EAAmF;AAC/ED,IAAAA,GAAG,CAACE,IAAJ,CAAU,GAAEN,GAAI,IAAGG,GAAG,GAAG,CAAE,EAA3B;AACH;;AACD,MAAKH,GAAG,GAAG,CAAP,GAAYH,IAAZ,IAAqBE,SAAS,CAAE,GAAEC,GAAG,GAAG,CAAE,IAAGG,GAAI,EAAnB,CAAT,CAA+B,CAA/B,MAAsCV,YAAY,CAACY,IAA5E,EAAmF;AAC/ED,IAAAA,GAAG,CAACE,IAAJ,CAAU,GAAEN,GAAG,GAAG,CAAE,IAAGG,GAAI,EAA3B;AACH;;AACD,MAAKA,GAAG,GAAG,CAAN,IAAW,CAAZ,IAAmBJ,SAAS,CAAE,GAAEC,GAAI,IAAGG,GAAG,GAAG,CAAE,EAAnB,CAAT,CAA+B,CAA/B,MAAsCV,YAAY,CAACY,IAA1E,EAAiF;AAC7ED,IAAAA,GAAG,CAACE,IAAJ,CAAU,GAAEN,GAAI,IAAGG,GAAG,GAAG,CAAE,EAA3B;AACH;;AAED,SAAOC,GAAP;AACH,CAnBM;AAqBP,OAAO,MAAMG,UAAU,GAAG,CAACC,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,KAAsC;AAC5D,MAAIC,IAAI,GAAGF,UAAX;AACA,MAAIG,IAAI,GAAG,EAAX;;AAEA,SAAO,IAAP,EAAa;AACTD,IAAAA,IAAI,GAAGD,SAAS,CAACC,IAAD,CAAhB;;AAEA,QAAIA,IAAI,KAAKH,SAAb,EAAwB;AACpB;AACH;;AAEDI,IAAAA,IAAI,CAACN,IAAL,CAAUK,IAAV;AACH;;AAED,SAAOC,IAAP;AACH,CAfM;AAiBP,OAAO,MAAMC,mBAAmB,GAAIC,KAAD,IAAW;AAC1C,MAAIC,WAAW,GAAGC,IAAI,CAACC,GAAL,CAAS,GAAGC,MAAM,CAACC,MAAP,CAAcL,KAAd,CAAZ,CAAlB;;AAEA,OAAK,MAAMM,GAAX,IAAkBN,KAAlB,EAAyB;AACrB,QAAIA,KAAK,CAACM,GAAD,CAAL,KAAeL,WAAnB,EAAgC;AAC5B,aAAOK,GAAP;AACH;AACJ;AACJ,CARM;AAUP,OAAO,MAAMC,gBAAgB,GAAIC,IAAD,IAAU;AACtC,SAAO5B,mBAAmB,CAAC6B,QAApB,CAA6BD,IAA7B,CAAP;AACH,CAFM;AAIP,OAAO,MAAME,aAAa,GAAIF,IAAD,IAAU;AACnC,SAAOG,gBAAgB,CAACF,QAAjB,CAA0BD,IAA1B,CAAP;AACH,CAFM","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos } from './constants.js'\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n"]},"metadata":{},"sourceType":"module"}