{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getNeighbourNodes,createPath,findMinPriorityNode,sleep}from'../../utils/helper.js';import{nodeWeight,nodeTypeEnum}from'../../utils/constants.js';export var aStar=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,rows,cols,timeout){var openSet,G,H,F,visited,prevNodes,x,y,cord,currNode,nodeStateFunc,neighbours,_iterator,_step,neighbour,currGScore,_nodeStateFunc;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:openSet=_defineProperty({},startCord,0);G=_defineProperty({},startCord,0);// G(n) => tell us the current shortest distance from start node to node n\nH=_defineProperty({},startCord,0);// H(n) => tells us the estimated distance from node n to target node\nF=_defineProperty({},startCord,0);// F(n) = G(n) + H(n)\nvisited={};prevNodes={};// intialize all the scores to infinity for all node !== start node\nfor(x=0;x<rows;x++){for(y=0;y<cols;y++){cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){F[cord]=G[cord]=H[cord]=Infinity;}}}case 7:if(!(Object.keys(openSet).length>0)){_context.next=24;break;}currNode=findMinPriorityNode(openSet);delete openSet[currNode];if(!(currNode!==startCord&&currNode!==targetCord)){_context.next=15;break;}nodeStateFunc=gridState[currNode][1];nodeStateFunc(function(prevState){return[nodeTypeEnum.visited].concat(_toConsumableArray(prevState.slice(1)));});_context.next=17;break;case 15:if(!(currNode===targetCord)){_context.next=17;break;}return _context.abrupt(\"return\",createPath(startCord,targetCord,prevNodes));case 17:neighbours=getNeighbourNodes(currNode,rows,cols,gridState);_iterator=_createForOfIteratorHelper(neighbours);try{for(_iterator.s();!(_step=_iterator.n()).done;){neighbour=_step.value;currGScore=G[currNode]+nodeWeight[gridState[neighbour][0][0]];if(currGScore<G[neighbour]){if(neighbour!==startCord&&neighbour!==targetCord&&!(neighbour in visited)){_nodeStateFunc=gridState[neighbour][1];_nodeStateFunc(function(prevState){return[nodeTypeEnum.visiting].concat(_toConsumableArray(prevState));});}visited[neighbour]=1;// newly calculated G score of neighbour is lower than the one in the table\n// update all the scores\nG[neighbour]=currGScore;H[neighbour]=h(neighbour,targetCord);F[neighbour]=G[neighbour]+H[neighbour];prevNodes[neighbour]=currNode;openSet[neighbour]=F[neighbour];}}}catch(err){_iterator.e(err);}finally{_iterator.f();}_context.next=22;return sleep(timeout);case 22:_context.next=7;break;case 24:return _context.abrupt(\"return\",[]);case 25:case\"end\":return _context.stop();}}},_callee);}));return function aStar(_x,_x2,_x3,_x4,_x5,_x6){return _ref.apply(this,arguments);};}();// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nvar h=function h(currNodeCord,targetCord){if(currNodeCord===targetCord){return 0;}var currRow=parseInt(currNodeCord.split(':')[0]);var currCol=parseInt(currNodeCord.split(':')[1]);var targetRow=parseInt(targetCord.split(':')[0]);var targetCol=parseInt(targetCord.split(':')[1]);return Math.sqrt(Math.pow(currRow-targetRow,2)+Math.pow(currCol-targetCol,2));};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/aStar.js"],"names":["getNeighbourNodes","createPath","findMinPriorityNode","sleep","nodeWeight","nodeTypeEnum","aStar","startCord","targetCord","gridState","rows","cols","timeout","openSet","G","H","F","visited","prevNodes","x","y","cord","Infinity","Object","keys","length","currNode","nodeStateFunc","prevState","slice","neighbours","neighbour","currGScore","visiting","h","currNodeCord","currRow","parseInt","split","currCol","targetRow","targetCol","Math","sqrt","pow"],"mappings":"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","sourcesContent":["import { getNeighbourNodes, createPath, findMinPriorityNode, sleep } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const aStar = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let G = { [startCord]: 0 }; // G(n) => tell us the current shortest distance from start node to node n\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = G(n) + H(n)\n    let visited = {};\n    let prevNodes = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = G[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currGScore = G[currNode] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (currGScore < G[neighbour]) {\n                if (neighbour !== startCord && neighbour !== targetCord && !(neighbour in visited)) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n                visited[neighbour] = 1;\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                G[neighbour] = currGScore;\n                H[neighbour] = h(neighbour, targetCord);\n                F[neighbour] = G[neighbour] + H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst h = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.sqrt(Math.pow(currRow - targetRow, 2) + Math.pow(currCol - targetCol, 2));\n};"]},"metadata":{},"sourceType":"module"}