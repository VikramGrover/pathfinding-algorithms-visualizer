{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nexport const random = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  let gridMap = {};\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n      const randomNum = getRandomNum(0, 1);\n      let newState = [nodeTypeEnum.none];\n\n      if (randomNum === 0) {\n        // place a wall\n        newState.unshift(nodeTypeEnum.wall);\n\n        if (currCord === startCord) {\n          newState.unshift(nodeTypeEnum.start);\n        } else if (currCord === targetCord) {\n          newState.unshift(nodeTypeEnum.target);\n        }\n\n        nodeStateFunc(prevState => newState);\n        await sleep(timeout);\n      }\n\n      gridMap[currCord] = [newState, nodeStateFunc];\n    }\n  }\n\n  setGridState(prevState => gridMap);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/random.js"],"names":["nodeTypeEnum","sleep","getRandomNum","random","startCord","targetCord","gridState","setGridState","rows","cols","timeout","gridMap","x","y","currCord","nodeStateFunc","randomNum","newState","none","unshift","wall","start","target","prevState"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,QAAoC,uBAApC;AAEA,OAAO,MAAMC,MAAM,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BC,SAA9B,EAAyCC,YAAzC,EAAuDC,IAAvD,EAA6DC,IAA7D,EAAmEC,OAAnE,KAA+E;AACjG,MAAIC,OAAO,GAAG,EAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;AAC3B,YAAMC,QAAQ,GAAI,GAAEF,CAAE,IAAGC,CAAE,EAA3B;AACA,YAAME,aAAa,GAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB;AACA,YAAME,SAAS,GAAGd,YAAY,CAAC,CAAD,EAAI,CAAJ,CAA9B;AACA,UAAIe,QAAQ,GAAG,CAACjB,YAAY,CAACkB,IAAd,CAAf;;AAEA,UAAIF,SAAS,KAAK,CAAlB,EAAqB;AACjB;AACAC,QAAAA,QAAQ,CAACE,OAAT,CAAiBnB,YAAY,CAACoB,IAA9B;;AAEA,YAAIN,QAAQ,KAAKV,SAAjB,EAA4B;AACxBa,UAAAA,QAAQ,CAACE,OAAT,CAAiBnB,YAAY,CAACqB,KAA9B;AACH,SAFD,MAGK,IAAIP,QAAQ,KAAKT,UAAjB,EAA6B;AAC9BY,UAAAA,QAAQ,CAACE,OAAT,CAAiBnB,YAAY,CAACsB,MAA9B;AACH;;AAEDP,QAAAA,aAAa,CAACQ,SAAS,IAAIN,QAAd,CAAb;AAEA,cAAMhB,KAAK,CAACS,OAAD,CAAX;AACH;;AAEDC,MAAAA,OAAO,CAACG,QAAD,CAAP,GAAoB,CAACG,QAAD,EAAWF,aAAX,CAApB;AACH;AACJ;;AAEDR,EAAAA,YAAY,CAACgB,SAAS,IAAIZ,OAAd,CAAZ;AACH,CA9BM","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nexport const random = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(0, 1);\n            let newState = [nodeTypeEnum.none];\n\n            if (randomNum === 0) {\n                // place a wall\n                newState.unshift(nodeTypeEnum.wall);\n\n                if (currCord === startCord) {\n                    newState.unshift(nodeTypeEnum.start);\n                }\n                else if (currCord === targetCord) {\n                    newState.unshift(nodeTypeEnum.target);\n                }\n\n                nodeStateFunc(prevState => newState);\n\n                await sleep(timeout);\n            }\n\n            gridMap[currCord] = [newState, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};"]},"metadata":{},"sourceType":"module"}