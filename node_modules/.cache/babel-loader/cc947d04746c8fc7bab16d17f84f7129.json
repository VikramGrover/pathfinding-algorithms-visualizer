{"ast":null,"code":"import { nodeTypeEnum } from '../../utils/constants.js';\nimport { sleep, getRandomNum } from '../../utils/helper.js';\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  // make border around the screen\n  for (var x = 0; x < rows; x++) {\n    for (var y = 0; y < cols; y++) {\n      const currCord = `${x}:${y}`;\n      const nodeStateFunc = gridState[currCord][1];\n\n      if (x === 0 || x === rows - 1 || y === 0 || y === cols - 1) {\n        await sleep(timeout);\n        let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n\n        if (currCord === startCord) {\n          state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n        } else if (currCord === targetCord) {\n          state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n        }\n\n        nodeStateFunc(prevState => state);\n        setGridState(prevState => ({ ...prevState,\n          [currCord]: [state, prevState[currCord][1]]\n        }));\n      }\n    }\n  }\n\n  await divide(1, 1, rows, cols, gridState, setGridState, timeout);\n}; // const divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols, previousBisection) => {\n//     const width = endCol - startCol;\n//     const height = endRow - startRow;\n//     if (width < 2 || height < 2) {\n//         return;\n//     }\n//     if (width < height) {\n//         // cutting horizontally\n//         const skip = getRandomNum(startCol, endCol);\n//         let randRow = getRandomNum(startRow + 1, endRow - 1);\n//         while (randRow === previousBisection) {\n//             randRow = getRandomNum(startRow + 1, endRow - 1);\n//         }\n//         for (let i = startCol; i <= endCol; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${randRow}:${i}`;\n//             console.log(startRow, endRow, currCord);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n//         if (randRow - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//         if ((randRow + 1) < rows) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n//     else {\n//         // divide vertically \n//         const skip = getRandomNum(startRow, endRow);\n//         let randCol = getRandomNum(startCol + 1, endCol - 1);\n//         while (randCol === previousBisection) {\n//             randCol = getRandomNum(startCol + 1, endCol - 1);\n//         }\n//         console.log(startCol, endCol, randCol)\n//         for (let i = startRow; i <= endRow; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${i}:${randCol}`;\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n//         if (randCol - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols, skip);\n//         }\n//         if (randCol + 1 < cols) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n// };\n\nconst divide = async (x, y, height, width, gridState, setGridState, timeout) => {\n  let orientation = HORIZONTAL; // horizontal\n\n  let newWall = 0;\n  let newGap = 0;\n  let newHeight = 0;\n  let newWidth = 0;\n  let yPair = 0;\n  let xPair = 0;\n  let newHeightPair = 0;\n  let newWidthPair = 0;\n\n  if (width < height) {\n    orientation = HORIZONTAL;\n  } else if (height > width) {\n    orientation = VERTICAL;\n  } else {\n    orientation = getRandomNum(HORIZONTAL, VERTICAL);\n  }\n\n  if (orientation === HORIZONTAL) {\n    // cutting horizontally\n    if (height < 5) {\n      return;\n    }\n\n    let randomWall = getRandomNum(2, height - 3);\n    let randomGap = getRandomNum(1, width - 2);\n    newWall = y + Math.floor(randomWall / 2) * 2; // make sure the wall is on an odd co-ordinate\n\n    newGap = x + Math.floor(randomGap / 2) * 2 + 1; // make sure the gap is on an even co-ordinate\n\n    for (let i = x; i < x + width - 1; i++) {\n      if (i === newGap) {\n        continue;\n      }\n\n      const currCord = `${newWall}:${i}`;\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    newHeight = newWall - y + 1;\n    newWidth = width;\n    yPair = newWall;\n    xPair = x;\n    newHeightPair = y + height - newWall;\n    newWidthPair = width;\n  } else if (orientation === VERTICAL) {\n    // cutting vertically\n    if (width < 5) {\n      return;\n    }\n\n    let randomWall = getRandomNum(2, width - 3);\n    let randomGap = getRandomNum(1, height - 2);\n    newWall = x + Math.floor(randomWall / 2) * 2; // make sure the wall is on an even co-ordinate\n\n    newGap = y + Math.floor(randomGap / 2) * 2 + 1; // make sure the gap is on an odd co-ordinate\n\n    for (let i = y; i < y + height - 1; i++) {\n      if (i === newGap) {\n        continue;\n      }\n\n      const currCord = `${i}:${newWall}`;\n      const nodeStateFunc = gridState[currCord][1];\n      nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n      setGridState(prevState => ({ ...prevState,\n        [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]]\n      }));\n      await sleep(timeout);\n    }\n\n    newHeight = height;\n    newWidth = newWall - x + 1;\n    yPair = y;\n    xPair = newWall;\n    newHeightPair = height;\n    newWidthPair = x + width - newWall;\n  } else {\n    return;\n  }\n\n  await divide(y, x, newHeight, newWidth, gridState, setGridState, timeout);\n  await divide(yPair, xPair, newHeightPair, newWidthPair, gridState, setGridState, timeout);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/recursiveDivision.js"],"names":["nodeTypeEnum","sleep","getRandomNum","HORIZONTAL","VERTICAL","recursiveDivision","startCord","targetCord","gridState","setGridState","rows","cols","timeout","x","y","currCord","nodeStateFunc","state","wall","none","start","target","prevState","divide","height","width","orientation","newWall","newGap","newHeight","newWidth","yPair","xPair","newHeightPair","newWidthPair","randomWall","randomGap","Math","floor","i"],"mappings":"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","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (var x = 0; x < rows; x++) {\n        for (var y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            if (x === 0 || x === (rows - 1) || y === 0 || y === (cols - 1)) {\n                await sleep(timeout);\n                let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n                if (currCord === startCord) {\n                    state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                else if (currCord === targetCord) {\n                    state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n                }\n                nodeStateFunc(prevState => state);\n                setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            }\n        }\n    }\n\n    await divide(1, 1, rows, cols, gridState, setGridState, timeout);\n};\n\n// const divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols, previousBisection) => {\n//     const width = endCol - startCol;\n//     const height = endRow - startRow;\n\n//     if (width < 2 || height < 2) {\n//         return;\n//     }\n\n//     if (width < height) {\n//         // cutting horizontally\n//         const skip = getRandomNum(startCol, endCol);\n//         let randRow = getRandomNum(startRow + 1, endRow - 1);\n//         while (randRow === previousBisection) {\n//             randRow = getRandomNum(startRow + 1, endRow - 1);\n//         }\n\n//         for (let i = startCol; i <= endCol; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${randRow}:${i}`;\n//             console.log(startRow, endRow, currCord);\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n\n//         if (randRow - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//         if ((randRow + 1) < rows) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n//     else {\n//         // divide vertically \n//         const skip = getRandomNum(startRow, endRow);\n//         let randCol = getRandomNum(startCol + 1, endCol - 1);\n//         while (randCol === previousBisection) {\n//             randCol = getRandomNum(startCol + 1, endCol - 1);\n//         }\n//         console.log(startCol, endCol, randCol)\n//         for (let i = startRow; i <= endRow; i++) {\n//             if (i === skip) {\n//                 continue;\n//             }\n//             const currCord = `${i}:${randCol}`;\n//             const nodeStateFunc = gridState[currCord][1];\n//             nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n//             setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n//             await sleep(timeout);\n//         }\n\n//         if (randCol - 1 > 0) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols, skip);\n//         }\n//         if (randCol + 1 < cols) {\n//             await divideScreen(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols, skip);\n//         }\n//     }\n// };\n\nconst divide = async (x, y, height, width, gridState, setGridState, timeout) => {\n    let orientation = HORIZONTAL; // horizontal\n    let newWall = 0;\n    let newGap = 0;\n    let newHeight = 0;\n    let newWidth = 0;\n    let yPair = 0;\n    let xPair = 0;\n    let newHeightPair = 0;\n    let newWidthPair = 0;\n\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height > width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 5) {\n            return;\n        }\n\n        let randomWall = getRandomNum(2, height - 3);\n        let randomGap = getRandomNum(1, width - 2);\n\n        newWall = y + Math.floor(randomWall / 2) * 2; // make sure the wall is on an odd co-ordinate\n        newGap = x + (Math.floor(randomGap / 2) * 2) + 1; // make sure the gap is on an even co-ordinate\n\n        for (let i = x; i < (x + width - 1); i++) {\n            if (i === newGap) {\n                continue;\n            }\n            const currCord = `${newWall}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        newHeight = newWall - y + 1;\n        newWidth = width\n\n        yPair = newWall;\n        xPair = x;\n        newHeightPair = y + height - newWall;\n        newWidthPair = width;\n    }\n    else if (orientation === VERTICAL) {\n        // cutting vertically\n        if (width < 5) {\n            return;\n        }\n\n        let randomWall = getRandomNum(2, width - 3);\n        let randomGap = getRandomNum(1, height - 2);\n\n        newWall = x + Math.floor(randomWall / 2) * 2; // make sure the wall is on an even co-ordinate\n        newGap = y + (Math.floor(randomGap / 2) * 2) + 1; // make sure the gap is on an odd co-ordinate\n\n        for (let i = y; i < (y + height - 1); i++) {\n            if (i === newGap) {\n                continue;\n            }\n            const currCord = `${i}:${newWall}`;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => [nodeTypeEnum.wall, nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [currCord]: [[nodeTypeEnum.wall, nodeTypeEnum.none], prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        newHeight = height;\n        newWidth = newWall - x + 1;\n\n        yPair = y;\n        xPair = newWall;\n        newHeightPair = height;\n        newWidthPair = x + width - newWall;\n    }\n    else {\n        return;\n    }\n\n    await divide(y, x, newHeight, newWidth, gridState, setGridState, timeout);\n    await divide(yPair, xPair, newHeightPair, newWidthPair, gridState, setGridState, timeout);\n};"]},"metadata":{},"sourceType":"module"}