{"ast":null,"code":"import { getNodeTypeEnum, getNeighbourNodes } from '../../utils/util.js';\nexport const dfs = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  const stack = [startCord];\n  const path = [];\n  const visited = {\n    [startCord]: 1\n  };\n\n  while (stack.length > 0) {\n    const currCord = stack[0];\n\n    if (currCord !== targetCord && currCord !== startCord) {\n      setTimeout(() => {\n        setGridState(prevState => ({ ...prevState,\n          [currCord]: [getNodeTypeEnum('visiting'), getNodeTypeEnum('none')]\n        }));\n      }, timeout);\n    }\n\n    if (currCord === targetCord) {\n      stack.pop();\n      stack.shift();\n      return stack;\n    }\n\n    if (currCord !== startCord) {\n      path.unshift(currCord);\n      visited[currCord] = 1;\n      setTimeout(() => {\n        setGridState(prevState => ({ ...prevState,\n          [currCord]: [getNodeTypeEnum('visited'), getNodeTypeEnum('none')]\n        }));\n      }, timeout);\n    }\n\n    const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n    let unvisitedNeighbourFound = false;\n\n    for (const neighbour of neighbours) {\n      if (neighbour in visited) {\n        continue;\n      }\n\n      stack.unshift(neighbour);\n      unvisitedNeighbourFound = true;\n      break;\n    }\n\n    if (!unvisitedNeighbourFound) {\n      stack.splice(0, 1);\n    }\n  }\n\n  return [];\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNodeTypeEnum","getNeighbourNodes","dfs","startCord","targetCord","gridState","setGridState","rows","cols","timeout","stack","path","visited","length","currCord","setTimeout","prevState","pop","shift","unshift","neighbours","unvisitedNeighbourFound","neighbour","splice"],"mappings":"AAAA,SAASA,eAAT,EAA0BC,iBAA1B,QAAmD,qBAAnD;AAEA,OAAO,MAAMC,GAAG,GAAG,CAACC,SAAD,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiDC,IAAjD,EAAuDC,IAAvD,EAA6DC,OAA7D,KAAyE;AACxF,QAAMC,KAAK,GAAG,CAACP,SAAD,CAAd;AACA,QAAMQ,IAAI,GAAG,EAAb;AACA,QAAMC,OAAO,GAAG;AAAE,KAACT,SAAD,GAAa;AAAf,GAAhB;;AAEA,SAAOO,KAAK,CAACG,MAAN,GAAe,CAAtB,EAAyB;AACrB,UAAMC,QAAQ,GAAGJ,KAAK,CAAC,CAAD,CAAtB;;AACA,QAAII,QAAQ,KAAKV,UAAb,IAA2BU,QAAQ,KAAKX,SAA5C,EAAuD;AACnDY,MAAAA,UAAU,CAAC,MAAM;AACbT,QAAAA,YAAY,CAACU,SAAS,KAAK,EAAE,GAAGA,SAAL;AAAgB,WAACF,QAAD,GAAY,CAACd,eAAe,CAAC,UAAD,CAAhB,EAA8BA,eAAe,CAAC,MAAD,CAA7C;AAA5B,SAAL,CAAV,CAAZ;AACH,OAFS,EAEPS,OAFO,CAAV;AAGH;;AAED,QAAIK,QAAQ,KAAKV,UAAjB,EAA6B;AACzBM,MAAAA,KAAK,CAACO,GAAN;AACAP,MAAAA,KAAK,CAACQ,KAAN;AACA,aAAOR,KAAP;AACH;;AAED,QAAII,QAAQ,KAAKX,SAAjB,EAA4B;AACxBQ,MAAAA,IAAI,CAACQ,OAAL,CAAaL,QAAb;AACAF,MAAAA,OAAO,CAACE,QAAD,CAAP,GAAoB,CAApB;AACAC,MAAAA,UAAU,CAAC,MAAM;AACbT,QAAAA,YAAY,CAACU,SAAS,KAAK,EAAE,GAAGA,SAAL;AAAgB,WAACF,QAAD,GAAY,CAACd,eAAe,CAAC,SAAD,CAAhB,EAA6BA,eAAe,CAAC,MAAD,CAA5C;AAA5B,SAAL,CAAV,CAAZ;AACH,OAFS,EAEPS,OAFO,CAAV;AAGH;;AAED,UAAMW,UAAU,GAAGnB,iBAAiB,CAACa,QAAD,EAAWP,IAAX,EAAiBC,IAAjB,EAAuBH,SAAvB,CAApC;AACA,QAAIgB,uBAAuB,GAAG,KAA9B;;AACA,SAAK,MAAMC,SAAX,IAAwBF,UAAxB,EAAoC;AAChC,UAAIE,SAAS,IAAIV,OAAjB,EAA0B;AACtB;AACH;;AAEDF,MAAAA,KAAK,CAACS,OAAN,CAAcG,SAAd;AACAD,MAAAA,uBAAuB,GAAG,IAA1B;AACA;AACH;;AAED,QAAI,CAACA,uBAAL,EAA8B;AAC1BX,MAAAA,KAAK,CAACa,MAAN,CAAa,CAAb,EAAgB,CAAhB;AACH;AACJ;;AAED,SAAO,EAAP;AACH,CA7CM","sourcesContent":["import { getNodeTypeEnum, getNeighbourNodes } from '../../utils/util.js'\n\nexport const dfs = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const path = [];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [getNodeTypeEnum('visiting'), getNodeTypeEnum('none')] }));\n            }, timeout);\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            path.unshift(currCord);\n            visited[currCord] = 1;\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [getNodeTypeEnum('visited'), getNodeTypeEnum('none')] }));\n            }, timeout);\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}