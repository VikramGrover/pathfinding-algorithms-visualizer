{"ast":null,"code":"import { getNodeTypeEnum, getNodeWeight, shuffleArray } from '../../utils/util.js';\nexport const dfs = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n  const stack = [startCord];\n  const visitedArr = [];\n  const visited = {};\n\n  while (stack.length > 0) {\n    const [currCord] = stack.splice(0, 1);\n\n    if (currCord === targetCord) {\n      return visitedArr;\n    }\n\n    if (currCord !== startCord) {\n      visitedArr.unshift(currCord);\n      visited[currCord] = 1;\n      setTimeout(() => {\n        setGridState(prevState => ({ ...prevState,\n          [currCord]: [getNodeTypeEnum('visited'), ...prevState[currCord].slice(1)]\n        }));\n      }, 1);\n    }\n\n    const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n    for (const neighbour of neighbours) {\n      if (neighbour in visited) {\n        continue;\n      }\n\n      if (neighbour !== startCord && neighbour !== targetCord) {\n        setTimeout(() => {\n          setGridState(prevState => ({ ...prevState,\n            [neighbour]: [getNodeTypeEnum('visiting'), getNodeTypeEnum('none')]\n          }));\n        }, 1);\n      }\n\n      stack.unshift(neighbour);\n    }\n  }\n\n  return [];\n};\n\nconst getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0] !== getNodeTypeEnum('wall')) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0] !== getNodeTypeEnum('wall')) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0] !== getNodeTypeEnum('wall')) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0] !== getNodeTypeEnum('wall')) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNodeTypeEnum","getNodeWeight","shuffleArray","dfs","startCord","targetCord","gridState","setGridState","rows","cols","stack","visitedArr","visited","length","currCord","splice","unshift","setTimeout","prevState","slice","neighbours","getNeighbourNodes","neighbour","node","row","parseInt","split","col","res","push"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight, shuffleArray } from '../../utils/util.js'\n\nexport const dfs = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n    const stack = [startCord];\n    const visitedArr = [];\n    const visited = {};\n\n    while (stack.length > 0) {\n        const [currCord] = stack.splice(0, 1);\n\n        if (currCord === targetCord) {\n            return visitedArr;\n        }\n\n        if (currCord !== startCord) {\n            visitedArr.unshift(currCord);\n            visited[currCord] = 1;\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [getNodeTypeEnum('visited'), ...prevState[currCord].slice(1)] }));\n            }, 1);\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (neighbour !== startCord && neighbour !== targetCord) {\n                setTimeout(() => {\n                    setGridState(prevState => ({ ...prevState, [neighbour]: [getNodeTypeEnum('visiting'), getNodeTypeEnum('none')] }));\n                }, 1);\n            }\n            stack.unshift(neighbour);\n        }\n    }\n\n    return [];\n};\n\nconst getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0] !== getNodeTypeEnum('wall'))) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0] !== getNodeTypeEnum('wall'))) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0] !== getNodeTypeEnum('wall'))) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0] !== getNodeTypeEnum('wall'))) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};"]},"metadata":{},"sourceType":"module"}