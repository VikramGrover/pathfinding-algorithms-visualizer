{"ast":null,"code":"import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";var _algoFunctions,_algoSleepTimes,_terrainFunctions,_terrainAlgoSleepTime,_nodeColorClass,_nodeColors,_nodeWeight,_obsEnum,_pathfindingAlgoInfo;import{dijkstras}from'../algorithms/path_finding/dijkstras.js';import{dfs}from'../algorithms/path_finding/dfs.js';import{bfs}from'../algorithms/path_finding/bfs.js';import{aStar}from'../algorithms/path_finding/aStar.js';import{bestFirst}from'../algorithms/path_finding/bestFirst.js';import{recursiveDivision}from'../algorithms/terrain/recursiveDivision.js';import{simplexNoise}from'../algorithms/terrain/simplexNoise.js';import{random}from'../algorithms/terrain/random.js';import{randomWeighted}from'../algorithms/terrain/randomWeighted.js';import SyntaxHighlighter from'react-syntax-highlighter';import{atomOneDark}from'react-syntax-highlighter/dist/esm/styles/hljs';// PATHFINDING ALGORITHM CONSTANTS -------------------------------------------\nimport{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var DIJKSTRAS=\"Dijkstra's\";var ASTAR='A* (A-Star)';var BFS='Breadth-first Search';var DFS='Depth-first Search';var BEST_FIRST='Greedy Best-first Search';var algoFunctions=(_algoFunctions={},_defineProperty(_algoFunctions,DIJKSTRAS,dijkstras),_defineProperty(_algoFunctions,ASTAR,aStar),_defineProperty(_algoFunctions,BFS,bfs),_defineProperty(_algoFunctions,DFS,dfs),_defineProperty(_algoFunctions,BEST_FIRST,bestFirst),_algoFunctions);Object.freeze(algoFunctions);var PATH_CREATION_SLEEP=7;var algoSleepTimes=(_algoSleepTimes={},_defineProperty(_algoSleepTimes,DIJKSTRAS,1),_defineProperty(_algoSleepTimes,ASTAR,4),_defineProperty(_algoSleepTimes,BFS,5),_defineProperty(_algoSleepTimes,DFS,10),_defineProperty(_algoSleepTimes,BEST_FIRST,11),_algoSleepTimes);Object.freeze(algoSleepTimes);export{DIJKSTRAS,ASTAR,BFS,DFS,BEST_FIRST,algoFunctions,PATH_CREATION_SLEEP,algoSleepTimes};var allPathAlgos=[DIJKSTRAS,ASTAR,BFS,DFS,BEST_FIRST];Object.freeze(allPathAlgos);var unweightedPathAlgos=[DFS,BFS,BEST_FIRST];Object.freeze(unweightedPathAlgos);var optimalPathAlgos=[DIJKSTRAS,ASTAR,BFS];Object.freeze(optimalPathAlgos);export{allPathAlgos,unweightedPathAlgos,optimalPathAlgos};// TERRAIN ALGORTHIM CONSTANTS -------------------------------------------\nvar MAZE_GENERATION_SLEEP=5;var RECURSIVE_DIVISION=\"Recursive Division\";var SIMPLEX_NOISE=\"Simplex Noise\";var RANDOM_UNWEIGHTED=\"Random\";var RANDOM_WEIGHTED=\"Random (Weighted)\";var allTerrainAlgos=[RECURSIVE_DIVISION,SIMPLEX_NOISE,RANDOM_UNWEIGHTED,RANDOM_WEIGHTED];Object.freeze(allTerrainAlgos);var unweightedTerrainAlgos=[RECURSIVE_DIVISION,RANDOM_UNWEIGHTED];Object.freeze(unweightedTerrainAlgos);var terrainFunctions=(_terrainFunctions={},_defineProperty(_terrainFunctions,RECURSIVE_DIVISION,recursiveDivision),_defineProperty(_terrainFunctions,SIMPLEX_NOISE,simplexNoise),_defineProperty(_terrainFunctions,RANDOM_UNWEIGHTED,random),_defineProperty(_terrainFunctions,RANDOM_WEIGHTED,randomWeighted),_terrainFunctions);Object.freeze(terrainFunctions);var terrainAlgoSleepTimes=(_terrainAlgoSleepTime={},_defineProperty(_terrainAlgoSleepTime,RECURSIVE_DIVISION,5),_defineProperty(_terrainAlgoSleepTime,SIMPLEX_NOISE,1),_defineProperty(_terrainAlgoSleepTime,RANDOM_UNWEIGHTED,1),_defineProperty(_terrainAlgoSleepTime,RANDOM_WEIGHTED,1),_terrainAlgoSleepTime);Object.freeze(terrainAlgoSleepTimes);export{MAZE_GENERATION_SLEEP,RECURSIVE_DIVISION,SIMPLEX_NOISE,allTerrainAlgos,unweightedTerrainAlgos,terrainFunctions,terrainAlgoSleepTimes};// NODE CONSTANTS ------------------------------------------------------------\nvar nodeTypeEnum={'path':0,'visited':1,'visiting':2,'none':3,'target':4,'start':5,'remObstacle':6,'wall':7,'weighted100':8,'weighted80':9,'weighted60':10,'weighted40':11,'weighted20':12};Object.freeze(nodeTypeEnum);export{nodeTypeEnum};var nodeColorClass=(_nodeColorClass={},_defineProperty(_nodeColorClass,nodeTypeEnum.none,'none'),_defineProperty(_nodeColorClass,nodeTypeEnum.target,'target'),_defineProperty(_nodeColorClass,nodeTypeEnum.wall,'wall'),_defineProperty(_nodeColorClass,nodeTypeEnum.visiting,'visiting'),_defineProperty(_nodeColorClass,nodeTypeEnum.start,'start'),_defineProperty(_nodeColorClass,nodeTypeEnum.visited,'visited'),_defineProperty(_nodeColorClass,nodeTypeEnum.path,'path'),_defineProperty(_nodeColorClass,nodeTypeEnum.weighted100,'weighted100'),_defineProperty(_nodeColorClass,nodeTypeEnum.weighted80,'weighted80'),_defineProperty(_nodeColorClass,nodeTypeEnum.weighted60,'weighted60'),_defineProperty(_nodeColorClass,nodeTypeEnum.weighted40,'weighted40'),_defineProperty(_nodeColorClass,nodeTypeEnum.weighted20,'weighted20'),_nodeColorClass);Object.freeze(nodeColorClass);export{nodeColorClass};var EMPTY_NODE_BORDER_COLOR='#3C4046';var nodeColors=(_nodeColors={},_defineProperty(_nodeColors,nodeTypeEnum.none,'transparent'),_defineProperty(_nodeColors,nodeTypeEnum.target,'#f14846'),_defineProperty(_nodeColors,nodeTypeEnum.wall,'#18191c'),_defineProperty(_nodeColors,nodeTypeEnum.visiting,'#4988dc'),_defineProperty(_nodeColors,nodeTypeEnum.start,'#43b581'),_defineProperty(_nodeColors,nodeTypeEnum.visited,'#3f70dd'),_defineProperty(_nodeColors,nodeTypeEnum.path,'#f9a719'),_defineProperty(_nodeColors,nodeTypeEnum.weighted100,'#1b1c1e'),_defineProperty(_nodeColors,nodeTypeEnum.weighted80,'#1c1e21'),_defineProperty(_nodeColors,nodeTypeEnum.weighted60,'#222327'),_defineProperty(_nodeColors,nodeTypeEnum.weighted40,'#26272b'),_defineProperty(_nodeColors,nodeTypeEnum.weighted20,'#2b2c31'),_nodeColors);Object.freeze(nodeColors);export{EMPTY_NODE_BORDER_COLOR,nodeColors};var nodeWeight=(_nodeWeight={},_defineProperty(_nodeWeight,nodeTypeEnum.none,1),_defineProperty(_nodeWeight,nodeTypeEnum.target,1),_defineProperty(_nodeWeight,nodeTypeEnum.wall,Infinity),_defineProperty(_nodeWeight,nodeTypeEnum.start,1),_defineProperty(_nodeWeight,nodeTypeEnum.weighted100,100),_defineProperty(_nodeWeight,nodeTypeEnum.weighted80,80),_defineProperty(_nodeWeight,nodeTypeEnum.weighted60,60),_defineProperty(_nodeWeight,nodeTypeEnum.weighted40,40),_defineProperty(_nodeWeight,nodeTypeEnum.weighted20,20),_nodeWeight);Object.freeze(nodeWeight);export{nodeWeight};// OBSTACLE TYPES --------------------------------------------------------\nvar obstacleTypes=['Wall (∞)','Weighted (100)','Weighted (80)','Weighted (60)','Weighted (40)','Weighted (20)'];var obsEnum=(_obsEnum={},_defineProperty(_obsEnum,obstacleTypes[0],nodeColorClass[nodeTypeEnum.wall]),_defineProperty(_obsEnum,obstacleTypes[1],nodeColorClass[nodeTypeEnum.weighted100]),_defineProperty(_obsEnum,obstacleTypes[2],nodeColorClass[nodeTypeEnum.weighted80]),_defineProperty(_obsEnum,obstacleTypes[3],nodeColorClass[nodeTypeEnum.weighted60]),_defineProperty(_obsEnum,obstacleTypes[4],nodeColorClass[nodeTypeEnum.weighted40]),_defineProperty(_obsEnum,obstacleTypes[5],nodeColorClass[nodeTypeEnum.weighted20]),_obsEnum);Object.freeze(obsEnum);export{obstacleTypes,obsEnum};// ALGO INFO BOX --------------------------------------------------------\nvar codeBlockCustomStyle={fontSize:13,backgroundColor:'#18191c',borderRadius:4,padding:20,lineHeight:1.5,maxHeight:250,marginTop:7,marginBottom:0};var inLineCodeBlockCustomStyle={fontSize:12,backgroundColor:'#18191c',borderRadius:4,padding:4,display:'inline',color:'white',fontWeight:600};var pathfindingAlgoInfo=(_pathfindingAlgoInfo={},_defineProperty(_pathfindingAlgoInfo,DIJKSTRAS,{'summary':/*#__PURE__*/_jsxs(\"h4\",{children:[DIJKSTRAS,\" is a \",/*#__PURE__*/_jsx(\"strong\",{children:\"greedy\"}),\" pathfinding algorithm that is able find \",/*#__PURE__*/_jsx(\"strong\",{children:\"optimal (shortest)\"}),\" paths, even in \",/*#__PURE__*/_jsx(\"strong\",{children:\"weighted\"}),\" graphs\"]}),'description':null,'pseudocode':/*#__PURE__*/_jsx(SyntaxHighlighter,{language:\"python\",style:atomOneDark,showLineNumbers:true,wrapLines:true,customStyle:codeBlockCustomStyle,children:\"min_pq = min_heap(start_node: 0)\\ndist = { start_node: 0 }\\nprev = {}\\n\\nfor node in nodes:\\n    if node != start_node:\\n        dist[node] = Infinity\\n        min_pq[node] = Infinity\\n            \\nwhile min_pq.len:\\n    curr_node = min_pq.delete_min()\\n    \\n    if curr_node == target_node:\\n        return create_path(prev) # found path to target\\n        \\n    for neighbour in curr_node.neighbours:\\n        new_cost = distance[curr_node] + \\n                   edge(curr_node, neighbour).weight\\n\\n        if new_cost < dist[neighbour]:\\n            # found better path, update the distance\\n            dist[neighbour] = new_cost\\n            min_pq[neighbour] = new_cost\\n            prev[neighbour] = curr_node\\n\\n# no path found\\nreturn\"})}),_defineProperty(_pathfindingAlgoInfo,ASTAR,{'summary':/*#__PURE__*/_jsxs(\"h4\",{children:[ASTAR,\" is an \",/*#__PURE__*/_jsx(\"strong\",{children:\"informed\"}),\" pathfinding algorithm that combines ideas from \",DIJKSTRAS,\" and \",BEST_FIRST,\" to guarantee \",/*#__PURE__*/_jsx(\"strong\",{children:\"optimal (shortest)\"}),\" paths, even in \",/*#__PURE__*/_jsx(\"strong\",{children:\"weighted\"}),\" graphs\"]}),'description':/*#__PURE__*/_jsxs(\"p\",{children:[\"The algorithm explores paths that minimize the function \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"f(node) = g(node) + h(node)\"}),\" where \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"g(node)\"}),\" is the cost of the path from \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:_objectSpread(_objectSpread({},inLineCodeBlockCustomStyle),{},{color:nodeColors[nodeTypeEnum.start]}),children:\"start_node\"}),\" to \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"node\"}),\" and \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"h(node)\"}),\" is the \",/*#__PURE__*/_jsx(\"strong\",{children:\"heuristic function\"}),\" which estimates the cost of the path from \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"node\"}),\" to \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:_objectSpread(_objectSpread({},inLineCodeBlockCustomStyle),{},{color:nodeColors[nodeTypeEnum.target]}),children:\"target_node\"}),\".\"]}),'pseudocode':/*#__PURE__*/_jsx(SyntaxHighlighter,{language:\"python\",style:atomOneDark,showLineNumbers:true,wrapLines:true,customStyle:codeBlockCustomStyle,children:\"min_pq = min_heap(start_node: 0)\\ndist = { start_node: 0 }\\nprev = {}\\n\\nfor node in nodes:\\nif node != start_node:\\n    dist[node] = Infinity\\n    min_pq[node] = Infinity\\n        \\nwhile min_pq.len:\\ncurr_node = min_pq.delete_min()\\n\\nif curr_node == target_node:\\n    return create_path(prev) # found path to target\\n    \\nfor neighbour in curr_node.neighbours:\\n    new_cost = distance[curr_node] + \\n               edge(curr_node, neighbour).weight\\n\\n    if new_cost < dist[neighbour]:\\n        # found better path, update the distance\\n        dist[neighbour] = new_cost\\n        min_pq[neighbour] = new_cost\\n        prev[neighbour] = curr_node\\n\\n# no path found\\nreturn\"})}),_defineProperty(_pathfindingAlgoInfo,BFS,{'summary':/*#__PURE__*/_jsxs(\"h4\",{children:[BFS,\" is an \",/*#__PURE__*/_jsx(\"strong\",{children:\"uninformed/blind\"}),\" search algorithm that gurantees finding the \",/*#__PURE__*/_jsx(\"strong\",{children:\"optimal (shortest)\"}),\" paths only in \",/*#__PURE__*/_jsx(\"strong\",{children:\"unweighted\"}),\" graphs\"]}),'pseudocode':/*#__PURE__*/_jsx(SyntaxHighlighter,{language:\"python\",style:atomOneDark,showLineNumbers:true,wrapLines:true,customStyle:codeBlockCustomStyle,children:\"queue = [start_node]\\nvisited = { start_node: 1 }\\nprev = {}\\n\\nwhile queue.len:\\n    curr_node = queue.dequeue()\\n    \\n    for neighbour in curr_node.neighbours:\\n        if neighbour in visited:\\n            continue # skip nodes that are already visited\\n        \\n        prev[neighbour] = curr_node\\n        queue.enqueue(neighbour)\\n        visited[neighbour] = 1\\n\\n        if neighbour == target_node:\\n            # we path to target_node\\n            return create_path(prev)\\n\\n# no path found \\nreturn\"})}),_defineProperty(_pathfindingAlgoInfo,DFS,{'summary':/*#__PURE__*/_jsxs(\"h4\",{children:[DFS,\" is an \",/*#__PURE__*/_jsx(\"strong\",{children:\"uninformed/blind\"}),\" search algorithm that is \",/*#__PURE__*/_jsx(\"strong\",{children:\"unoptimal (may or may not find shortest path)\"}),\" and \",/*#__PURE__*/_jsx(\"strong\",{children:\"unweighted\"})]}),'pseudocode':/*#__PURE__*/_jsx(SyntaxHighlighter,{language:\"python\",style:atomOneDark,showLineNumbers:true,wrapLines:true,customStyle:codeBlockCustomStyle,children:\"stack = [start_node]\\nvisited = { start_node: 1 }\\n\\nwhile stack.len:\\n    curr_node = stack.pop()\\n    stack.push(curr_node)\\n\\n    if curr_node == target_node:\\n        return stack # our stack is the path to target_node\\n    \\n    flag = False\\n    for neighbour in curr_node.neighbours:\\n        if neighbour in visited:\\n            continue # skip nodes that are already visited\\n        \\n        stack.push(neighbour)\\n        visited[neighbour] = 1\\n        flag = True\\n\\n    if flag:\\n        # no neighbours that need to be visited, pop the node from stack\\n        stack.pop()\\n\\n# no path found \\nreturn\"})}),_defineProperty(_pathfindingAlgoInfo,BEST_FIRST,{'summary':/*#__PURE__*/_jsxs(\"h4\",{children:[BEST_FIRST,\" is an \",/*#__PURE__*/_jsx(\"strong\",{children:\"informed\"}),\" and \",/*#__PURE__*/_jsx(\"strong\",{children:\"greedy\"}),\" pathfinding algorithm that is \",/*#__PURE__*/_jsx(\"strong\",{children:\"unoptimal\"}),\" (may or may not find the shortest paths) and \",/*#__PURE__*/_jsx(\"strong\",{children:\"unweighted\"})]}),'description':/*#__PURE__*/_jsxs(\"p\",{children:[\"The algorithm explores paths that minimize the function \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"f(node) = h(node)\"}),\" where \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"h(node)\"}),\" is the \",/*#__PURE__*/_jsx(\"strong\",{children:\"heuristic function\"}),\" which estimates the cost of the path from \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:inLineCodeBlockCustomStyle,children:\"node\"}),\" to \",/*#__PURE__*/_jsx(SyntaxHighlighter,{language:'text',style:atomOneDark,customStyle:_objectSpread(_objectSpread({},inLineCodeBlockCustomStyle),{},{color:nodeColors[nodeTypeEnum.target]}),children:\"target_node\"}),\".\"]}),'pseudocode':/*#__PURE__*/_jsx(SyntaxHighlighter,{language:\"python\",style:atomOneDark,showLineNumbers:true,wrapLines:true,customStyle:codeBlockCustomStyle,children:\"min_pq = min_heap(start_node: 0)\\ndist = { start_node: 0 }\\nprev = {}\\n\\nfor node in nodes:\\nif node != start_node:\\n    dist[node] = Infinity\\n    min_pq[node] = Infinity\\n        \\nwhile min_pq.len:\\ncurr_node = min_pq.delete_min()\\n\\nif curr_node == target_node:\\n    return create_path(prev) # found path to target\\n    \\nfor neighbour in curr_node.neighbours:\\n    new_cost = distance[curr_node] + \\n               edge(curr_node, neighbour).weight\\n\\n    if new_cost < dist[neighbour]:\\n        # found better path, update the distance\\n        dist[neighbour] = new_cost\\n        min_pq[neighbour] = new_cost\\n        prev[neighbour] = curr_node\\n\\n# no path found\\nreturn\"})}),_pathfindingAlgoInfo);Object.freeze(pathfindingAlgoInfo);export{pathfindingAlgoInfo};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/constants.js"],"names":["dijkstras","dfs","bfs","aStar","bestFirst","recursiveDivision","simplexNoise","random","randomWeighted","SyntaxHighlighter","atomOneDark","DIJKSTRAS","ASTAR","BFS","DFS","BEST_FIRST","algoFunctions","Object","freeze","PATH_CREATION_SLEEP","algoSleepTimes","allPathAlgos","unweightedPathAlgos","optimalPathAlgos","MAZE_GENERATION_SLEEP","RECURSIVE_DIVISION","SIMPLEX_NOISE","RANDOM_UNWEIGHTED","RANDOM_WEIGHTED","allTerrainAlgos","unweightedTerrainAlgos","terrainFunctions","terrainAlgoSleepTimes","nodeTypeEnum","nodeColorClass","none","target","wall","visiting","start","visited","path","weighted100","weighted80","weighted60","weighted40","weighted20","EMPTY_NODE_BORDER_COLOR","nodeColors","nodeWeight","Infinity","obstacleTypes","obsEnum","codeBlockCustomStyle","fontSize","backgroundColor","borderRadius","padding","lineHeight","maxHeight","marginTop","marginBottom","inLineCodeBlockCustomStyle","display","color","fontWeight","pathfindingAlgoInfo"],"mappings":"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","sourcesContent":["import { dijkstras } from '../algorithms/path_finding/dijkstras.js'\nimport { dfs } from '../algorithms/path_finding/dfs.js'\nimport { bfs } from '../algorithms/path_finding/bfs.js'\nimport { aStar } from '../algorithms/path_finding/aStar.js'\nimport { bestFirst } from '../algorithms/path_finding/bestFirst.js';\nimport { recursiveDivision } from '../algorithms/terrain/recursiveDivision.js'\nimport { simplexNoise } from '../algorithms/terrain/simplexNoise.js'\nimport { random } from '../algorithms/terrain/random.js';\nimport { randomWeighted } from '../algorithms/terrain/randomWeighted.js';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { atomOneDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\n// PATHFINDING ALGORITHM CONSTANTS -------------------------------------------\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = 'A* (A-Star)';\nconst BFS = 'Breadth-first Search';\nconst DFS = 'Depth-first Search';\nconst BEST_FIRST = 'Greedy Best-first Search';\n\nconst algoFunctions = {\n    [DIJKSTRAS]: dijkstras,\n    [ASTAR]: aStar,\n    [BFS]: bfs,\n    [DFS]: dfs,\n    [BEST_FIRST]: bestFirst\n};\nObject.freeze(algoFunctions);\n\nconst PATH_CREATION_SLEEP = 7;\nconst algoSleepTimes = {\n    [DIJKSTRAS]: 1,\n    [ASTAR]: 4,\n    [BFS]: 5,\n    [DFS]: 10,\n    [BEST_FIRST]: 11\n};\nObject.freeze(algoSleepTimes);\n\nexport { DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST, algoFunctions, PATH_CREATION_SLEEP, algoSleepTimes };\n\nconst allPathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST];\nObject.freeze(allPathAlgos);\nconst unweightedPathAlgos = [DFS, BFS, BEST_FIRST];\nObject.freeze(unweightedPathAlgos);\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\nObject.freeze(optimalPathAlgos);\n\nexport { allPathAlgos, unweightedPathAlgos, optimalPathAlgos };\n\n// TERRAIN ALGORTHIM CONSTANTS -------------------------------------------\nconst MAZE_GENERATION_SLEEP = 5;\nconst RECURSIVE_DIVISION = \"Recursive Division\";\nconst SIMPLEX_NOISE = \"Simplex Noise\";\nconst RANDOM_UNWEIGHTED = \"Random\";\nconst RANDOM_WEIGHTED = \"Random (Weighted)\"\nconst allTerrainAlgos = [RECURSIVE_DIVISION, SIMPLEX_NOISE, RANDOM_UNWEIGHTED, RANDOM_WEIGHTED];\nObject.freeze(allTerrainAlgos);\n\nconst unweightedTerrainAlgos = [RECURSIVE_DIVISION, RANDOM_UNWEIGHTED];\nObject.freeze(unweightedTerrainAlgos);\n\nconst terrainFunctions = {\n    [RECURSIVE_DIVISION]: recursiveDivision,\n    [SIMPLEX_NOISE]: simplexNoise,\n    [RANDOM_UNWEIGHTED]: random,\n    [RANDOM_WEIGHTED]: randomWeighted,\n};\nObject.freeze(terrainFunctions);\n\nconst terrainAlgoSleepTimes = {\n    [RECURSIVE_DIVISION]: 5,\n    [SIMPLEX_NOISE]: 1,\n    [RANDOM_UNWEIGHTED]: 1,\n    [RANDOM_WEIGHTED]: 1\n};\nObject.freeze(terrainAlgoSleepTimes);\n\nexport { MAZE_GENERATION_SLEEP, RECURSIVE_DIVISION, SIMPLEX_NOISE, allTerrainAlgos, unweightedTerrainAlgos, terrainFunctions, terrainAlgoSleepTimes };\n\n// NODE CONSTANTS ------------------------------------------------------------\nconst nodeTypeEnum = {\n    'path': 0,\n    'visited': 1,\n    'visiting': 2,\n    'none': 3,\n    'target': 4,\n    'start': 5,\n    'remObstacle': 6,\n    'wall': 7,\n    'weighted100': 8,\n    'weighted80': 9,\n    'weighted60': 10,\n    'weighted40': 11,\n    'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\n\nexport { nodeTypeEnum };\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'none',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.wall]: 'wall',\n    [nodeTypeEnum.visiting]: 'visiting',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path',\n    [nodeTypeEnum.weighted100]: 'weighted100',\n    [nodeTypeEnum.weighted80]: 'weighted80',\n    [nodeTypeEnum.weighted60]: 'weighted60',\n    [nodeTypeEnum.weighted40]: 'weighted40',\n    [nodeTypeEnum.weighted20]: 'weighted20'\n};\nObject.freeze(nodeColorClass);\n\nexport { nodeColorClass };\n\nconst EMPTY_NODE_BORDER_COLOR = '#3C4046';\nconst nodeColors = {\n    [nodeTypeEnum.none]: 'transparent',\n    [nodeTypeEnum.target]: '#f14846',\n    [nodeTypeEnum.wall]: '#18191c',\n    [nodeTypeEnum.visiting]: '#4988dc',\n    [nodeTypeEnum.start]: '#43b581',\n    [nodeTypeEnum.visited]: '#3f70dd',\n    [nodeTypeEnum.path]: '#f9a719',\n    [nodeTypeEnum.weighted100]: '#1b1c1e',\n    [nodeTypeEnum.weighted80]: '#1c1e21',\n    [nodeTypeEnum.weighted60]: '#222327',\n    [nodeTypeEnum.weighted40]: '#26272b',\n    [nodeTypeEnum.weighted20]: '#2b2c31'\n};\nObject.freeze(nodeColors);\n\nexport { EMPTY_NODE_BORDER_COLOR, nodeColors };\n\nconst nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.wall]: Infinity,\n    [nodeTypeEnum.start]: 1,\n    [nodeTypeEnum.weighted100]: 100,\n    [nodeTypeEnum.weighted80]: 80,\n    [nodeTypeEnum.weighted60]: 60,\n    [nodeTypeEnum.weighted40]: 40,\n    [nodeTypeEnum.weighted20]: 20\n};\nObject.freeze(nodeWeight);\nexport { nodeWeight };\n\n// OBSTACLE TYPES --------------------------------------------------------\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n    [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n    [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n    [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n    [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n    [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n    [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n};\nObject.freeze(obsEnum);\n\nexport { obstacleTypes, obsEnum };\n\n// ALGO INFO BOX --------------------------------------------------------\n\nconst codeBlockCustomStyle = {\n    fontSize: 13,\n    backgroundColor: '#18191c',\n    borderRadius: 4,\n    padding: 20,\n    lineHeight: 1.5,\n    maxHeight: 250,\n    marginTop: 7,\n    marginBottom: 0\n};\n\nconst inLineCodeBlockCustomStyle = {\n    fontSize: 12,\n    backgroundColor: '#18191c',\n    borderRadius: 4,\n    padding: 4,\n    display: 'inline',\n    color: 'white',\n    fontWeight: 600\n};\n\nconst pathfindingAlgoInfo = {\n    [DIJKSTRAS]: {\n        'summary': <h4>{DIJKSTRAS} is a <strong>greedy</strong> pathfinding algorithm that is able find <strong>optimal (shortest)</strong> paths, even in <strong>weighted</strong> graphs</h4>,\n        'description': null,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\n    if node != start_node:\n        dist[node] = Infinity\n        min_pq[node] = Infinity\n            \nwhile min_pq.len:\n    curr_node = min_pq.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev) # found path to target\n        \n    for neighbour in curr_node.neighbours:\n        new_cost = distance[curr_node] + \n                   edge(curr_node, neighbour).weight\n\n        if new_cost < dist[neighbour]:\n            # found better path, update the distance\n            dist[neighbour] = new_cost\n            min_pq[neighbour] = new_cost\n            prev[neighbour] = curr_node\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    },\n    [ASTAR]: {\n        'summary': <h4>{ASTAR} is an <strong>informed</strong> pathfinding algorithm that combines ideas from {DIJKSTRAS} and {BEST_FIRST} to guarantee <strong>optimal (shortest)</strong> paths, even in <strong>weighted</strong> graphs</h4>,\n        'description': <p>The algorithm explores paths that minimize the function <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>f(node) = g(node) + h(node)</SyntaxHighlighter> where <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>g(node)</SyntaxHighlighter> is the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.start] }}>start_node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> and <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>h(node)</SyntaxHighlighter> is the <strong>heuristic function</strong> which estimates the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.target] }}>target_node</SyntaxHighlighter>.</p>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\nif node != start_node:\n    dist[node] = Infinity\n    min_pq[node] = Infinity\n        \nwhile min_pq.len:\ncurr_node = min_pq.delete_min()\n\nif curr_node == target_node:\n    return create_path(prev) # found path to target\n    \nfor neighbour in curr_node.neighbours:\n    new_cost = distance[curr_node] + \n               edge(curr_node, neighbour).weight\n\n    if new_cost < dist[neighbour]:\n        # found better path, update the distance\n        dist[neighbour] = new_cost\n        min_pq[neighbour] = new_cost\n        prev[neighbour] = curr_node\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    },\n    [BFS]: {\n        'summary': <h4>{BFS} is an <strong>uninformed/blind</strong> search algorithm that gurantees finding the <strong>optimal (shortest)</strong> paths only in <strong>unweighted</strong> graphs</h4>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`queue = [start_node]\nvisited = { start_node: 1 }\nprev = {}\n\nwhile queue.len:\n    curr_node = queue.dequeue()\n    \n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        prev[neighbour] = curr_node\n        queue.enqueue(neighbour)\n        visited[neighbour] = 1\n\n        if neighbour == target_node:\n            # we path to target_node\n            return create_path(prev)\n\n# no path found \nreturn`}\n        </SyntaxHighlighter>\n    },\n    [DFS]: {\n        'summary': <h4>{DFS} is an <strong>uninformed/blind</strong> search algorithm that is <strong>unoptimal (may or may not find shortest path)</strong> and <strong>unweighted</strong></h4>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`stack = [start_node]\nvisited = { start_node: 1 }\n\nwhile stack.len:\n    curr_node = stack.pop()\n    stack.push(curr_node)\n\n    if curr_node == target_node:\n        return stack # our stack is the path to target_node\n    \n    flag = False\n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        stack.push(neighbour)\n        visited[neighbour] = 1\n        flag = True\n\n    if flag:\n        # no neighbours that need to be visited, pop the node from stack\n        stack.pop()\n\n# no path found \nreturn`}\n        </SyntaxHighlighter>\n    },\n    [BEST_FIRST]: {\n        'summary': <h4>{BEST_FIRST} is an <strong>informed</strong> and <strong>greedy</strong> pathfinding algorithm that is <strong>unoptimal</strong> (may or may not find the shortest paths) and <strong>unweighted</strong></h4>,\n        'description': <p>The algorithm explores paths that minimize the function <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>f(node) = h(node)</SyntaxHighlighter> where <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>h(node)</SyntaxHighlighter> is the <strong>heuristic function</strong> which estimates the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.target] }}>target_node</SyntaxHighlighter>.</p>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\nif node != start_node:\n    dist[node] = Infinity\n    min_pq[node] = Infinity\n        \nwhile min_pq.len:\ncurr_node = min_pq.delete_min()\n\nif curr_node == target_node:\n    return create_path(prev) # found path to target\n    \nfor neighbour in curr_node.neighbours:\n    new_cost = distance[curr_node] + \n               edge(curr_node, neighbour).weight\n\n    if new_cost < dist[neighbour]:\n        # found better path, update the distance\n        dist[neighbour] = new_cost\n        min_pq[neighbour] = new_cost\n        prev[neighbour] = curr_node\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    }\n};\nObject.freeze(pathfindingAlgoInfo);\nexport { pathfindingAlgoInfo };\n\n"]},"metadata":{},"sourceType":"module"}