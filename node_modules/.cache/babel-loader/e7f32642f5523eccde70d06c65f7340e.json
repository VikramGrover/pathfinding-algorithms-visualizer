{"ast":null,"code":"import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React from'react';import{useEffect,useState}from'react';import{nodeColorClass,nodeTypeEnum}from'../utils/constants.js';import{jsx as _jsx}from\"react/jsx-runtime\";var Node=function Node(_ref){var nodeId=_ref.nodeId,size=_ref.size,setGridState=_ref.setGridState,draggingSelection=_ref.draggingSelection,setDraggingSelection=_ref.setDraggingSelection,setStartCord=_ref.setStartCord,setTargetCord=_ref.setTargetCord,runningAlgo=_ref.runningAlgo,selectedObstacle=_ref.selectedObstacle,startingState=_ref.startingState;var _useState=useState(startingState),_useState2=_slicedToArray(_useState,2),nodeState=_useState2[0],setNodeState=_useState2[1];useEffect(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[startingState,setNodeState]));});},[]);var nodeStyle={width:size,height:size};if(draggingSelection===nodeTypeEnum.start||draggingSelection===nodeTypeEnum.target){nodeStyle.cursor='grabbing';}var mouseDowned=function mouseDowned(){if(nodeState[0]<=nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum[selectedObstacle]);setNodeState(function(prevState){return[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none];});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none],setNodeState]));});return;}else if(nodeState[0]>=nodeTypeEnum.wall){setNodeState(function(prevState){return prevState.slice(1);});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState.slice(1),setNodeState]));});setDraggingSelection(nodeTypeEnum.remObstacle);return;}else if(nodeState[0]===nodeTypeEnum.start||nodeState[0]===nodeTypeEnum.target){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState.slice(1),setNodeState]));});}setDraggingSelection(nodeState[0]);};var mouseEntered=function mouseEntered(){if(draggingSelection===nodeTypeEnum.remObstacle&&nodeState[0]>=nodeTypeEnum.wall){setNodeState(function(prevState){return prevState.slice(1);});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState.slice(1),setNodeState]));});}else if(draggingSelection===nodeTypeEnum[selectedObstacle]&&nodeState[0]<=nodeTypeEnum.none){setNodeState(function(prevState){return[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none];});setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[[nodeTypeEnum[selectedObstacle],nodeTypeEnum.none],setNodeState]));});}else if(draggingSelection===nodeTypeEnum.start){setNodeState(function(prevState){return[draggingSelection].concat(_toConsumableArray(prevState));});}else if(draggingSelection===nodeTypeEnum.target){setNodeState(function(prevState){return[draggingSelection].concat(_toConsumableArray(prevState));});}};var mouseLeft=function mouseLeft(){if(draggingSelection===nodeTypeEnum.start||draggingSelection===nodeTypeEnum.target){setNodeState(function(prevState){return prevState.slice(1);});return;}};var mouseUped=function mouseUped(){if(draggingSelection===nodeTypeEnum.start){setStartCord(nodeId);setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState,setNodeState]));});}else if(draggingSelection===nodeTypeEnum.target){setTargetCord(nodeId);setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},nodeId,[nodeState,setNodeState]));});}if(draggingSelection!==nodeTypeEnum.none){setDraggingSelection(nodeTypeEnum.none);}};return/*#__PURE__*/_jsx(\"div\",{style:nodeStyle,className:\"node \".concat(nodeColorClass[nodeState[0]],\" \").concat(draggingSelection===nodeTypeEnum.remObstacle&&'erasing'),onMouseDown:runningAlgo?null:mouseDowned,onMouseUp:runningAlgo?null:mouseUped,onMouseEnter:runningAlgo?null:mouseEntered,onMouseLeave:runningAlgo?null:mouseLeft});};export default Node;","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/components/Node.js"],"names":["React","useEffect","useState","nodeColorClass","nodeTypeEnum","Node","nodeId","size","setGridState","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","selectedObstacle","startingState","nodeState","setNodeState","prevState","nodeStyle","width","height","start","target","cursor","mouseDowned","none","wall","slice","remObstacle","mouseEntered","mouseLeft","mouseUped"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { useEffect, useState } from 'react'\nimport { nodeColorClass, nodeTypeEnum } from '../utils/constants.js'\n\nconst Node = ({ nodeId, size, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo, selectedObstacle, startingState }) => {\n    const [nodeState, setNodeState] = useState(startingState);\n\n    useEffect(() => {\n        setGridState(prevState => ({ ...prevState, [nodeId]: [startingState, setNodeState] }));\n    }, []);\n\n    const nodeStyle = {\n        width: size,\n        height: size\n    };\n\n    if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n        nodeStyle.cursor = 'grabbing';\n    }\n\n    const mouseDowned = () => {\n        if (nodeState[0] <= nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum[selectedObstacle]);\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n            return;\n        }\n        else if (nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n            setDraggingSelection(nodeTypeEnum.remObstacle);\n            return;\n        }\n        else if (nodeState[0] === nodeTypeEnum.start || nodeState[0] === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === nodeTypeEnum.remObstacle && nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum[selectedObstacle] && nodeState[0] <= nodeTypeEnum.none) {\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.start) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => prevState.slice(1));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection === nodeTypeEnum.start) {\n            setStartCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setTargetCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        if (draggingSelection !== nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum.none);\n        }\n    };\n\n    return (\n        <div style={nodeStyle} className={`node ${nodeColorClass[nodeState[0]]} ${draggingSelection === nodeTypeEnum.remObstacle && 'erasing'}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n};\n\nexport default Node\n"]},"metadata":{},"sourceType":"module"}