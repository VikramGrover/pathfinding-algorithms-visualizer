{"ast":null,"code":"import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors, unweightedTerrainAlgos } from './constants.js';\nexport const getNodeColor = nodeState => {\n  if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting) && nodeState[1] > nodeTypeEnum.wall) {\n    let colorA = nodeColors[nodeState[0]];\n    const colorB = nodeColors[nodeState[1]];\n    let amount = 0.78;\n\n    if (nodeState[0] === nodeTypeEnum.visiting) {\n      colorA = nodeColors[nodeTypeEnum.visited];\n    } // we need to mix colors\n\n\n    const [rA, gA, bA] = colorA.match(/\\w\\w/g).map(c => parseInt(c, 16));\n    const [rB, gB, bB] = colorB.match(/\\w\\w/g).map(c => parseInt(c, 16));\n    const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n    const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n    const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n    return '#' + r + g + b;\n  }\n\n  return nodeColors[nodeState[0]];\n};\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0 && gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (col + 1 < cols && gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  if (row + 1 < rows && gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0 && gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  return res;\n};\nexport const createPath = (startCord, targetCord, prevNodes) => {\n  let cord = targetCord;\n  let path = [];\n\n  while (true) {\n    cord = prevNodes[cord];\n\n    if (cord === startCord) {\n      break;\n    }\n\n    path.push(cord);\n  }\n\n  return path;\n};\nexport const findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\nexport const isAlgoUnweighted = algo => {\n  return unweightedPathAlgos.includes(algo);\n};\nexport const isTerrainAlgoUnweighted = algo => {\n  return unweightedTerrainAlgos.includes(algo);\n};\nexport const isAlgoOptimal = algo => {\n  return optimalPathAlgos.includes(algo);\n};\nexport const sleep = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\nexport const getRandomNum = (num1, num2) => {\n  if (num1 === num2) {\n    return num1;\n  }\n\n  const min = Math.min(num1, num2);\n  const max = Math.max(num1, num2);\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}; // this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N. This is known as the \"Manhattan Distance\"\n\nexport const manhattanDistanceHeuristic = (currNodeCord, targetCord) => {\n  if (currNodeCord === targetCord) {\n    return 0;\n  }\n\n  const currRow = parseInt(currNodeCord.split(':')[0]);\n  const currCol = parseInt(currNodeCord.split(':')[1]);\n  const targetRow = parseInt(targetCord.split(':')[0]);\n  const targetCol = parseInt(targetCord.split(':')[1]);\n  return Math.abs(currRow - targetRow) + Math.abs(currCol, targetCol);\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/helper.js"],"names":["nodeTypeEnum","unweightedPathAlgos","optimalPathAlgos","nodeColors","unweightedTerrainAlgos","getNodeColor","nodeState","visited","visiting","wall","colorA","colorB","amount","rA","gA","bA","match","map","c","parseInt","rB","gB","bB","r","Math","round","toString","padStart","g","b","getNeighbourNodes","node","rows","cols","gridState","row","split","col","res","push","createPath","startCord","targetCord","prevNodes","cord","path","findMinPriorityNode","minPQ","minPriority","min","Object","values","key","isAlgoUnweighted","algo","includes","isTerrainAlgoUnweighted","isAlgoOptimal","sleep","ms","Promise","resolve","setTimeout","getRandomNum","num1","num2","max","floor","random","manhattanDistanceHeuristic","currNodeCord","currRow","currCol","targetRow","targetCol","abs"],"mappings":"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","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors, unweightedTerrainAlgos } from './constants.js'\n\nexport const getNodeColor = (nodeState) => {\n    if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting) && nodeState[1] > nodeTypeEnum.wall) {\n        let colorA = nodeColors[nodeState[0]];\n        const colorB = nodeColors[nodeState[1]];\n        let amount = 0.78;\n\n        if (nodeState[0] === nodeTypeEnum.visiting) {\n            colorA = nodeColors[nodeTypeEnum.visited];\n        }\n        // we need to mix colors\n        const [rA, gA, bA] = colorA.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const [rB, gB, bB] = colorB.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n        const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n        const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n        return '#' + r + g + b;\n    }\n\n    return nodeColors[nodeState[0]];\n};\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isTerrainAlgoUnweighted = (algo) => {\n    return unweightedTerrainAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n\nexport const sleep = (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n};\n\nexport const getRandomNum = (num1, num2) => {\n    if (num1 === num2) {\n        return num1;\n    }\n    const min = Math.min(num1, num2);\n    const max = Math.max(num1, num2);\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N. This is known as the \"Manhattan Distance\"\nexport const manhattanDistanceHeuristic = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol, targetCol);\n};"]},"metadata":{},"sourceType":"module"}