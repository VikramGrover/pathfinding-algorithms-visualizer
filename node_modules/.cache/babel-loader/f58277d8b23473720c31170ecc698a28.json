{"ast":null,"code":"var _jsxFileName = \"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/constants.js\";\nimport { dijkstras } from '../algorithms/path_finding/dijkstras.js';\nimport { dfs } from '../algorithms/path_finding/dfs.js';\nimport { bfs } from '../algorithms/path_finding/bfs.js';\nimport { aStar } from '../algorithms/path_finding/aStar.js';\nimport { bestFirstSearch } from '../algorithms/path_finding/bestFirstSearch.js';\nimport { recursiveDivision } from '../algorithms/terrain/recursiveDivision.js';\nimport { simplexNoise } from '../algorithms/terrain/simplexNoise.js';\nimport { random } from '../algorithms/terrain/random.js';\nimport { randomWeighted } from '../algorithms/terrain/randomWeighted.js';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { atomOneDark } from 'react-syntax-highlighter/dist/esm/styles/hljs'; // PATHFINDING ALGORITHM CONSTANTS -------------------------------------------\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = 'A* (A-Star)';\nconst BFS = 'Breadth-first Search';\nconst DFS = 'Depth-first Search';\nconst BEST_FIRST_SEARCH = 'Greedy Best-first Search';\nconst algoFunctions = {\n  [DIJKSTRAS]: dijkstras,\n  [ASTAR]: aStar,\n  [BFS]: bfs,\n  [DFS]: dfs,\n  [BEST_FIRST_SEARCH]: bestFirstSearch\n};\nObject.freeze(algoFunctions);\nconst PATH_CREATION_SLEEP = 7;\nconst algoSleepTimes = {\n  [DIJKSTRAS]: 1,\n  [ASTAR]: 4,\n  [BFS]: 5,\n  [DFS]: 10,\n  [BEST_FIRST]: 11\n};\nObject.freeze(algoSleepTimes);\nexport { DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST_SEARCH, algoFunctions, PATH_CREATION_SLEEP, algoSleepTimes };\nconst allPathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST];\nObject.freeze(allPathAlgos);\nconst unweightedPathAlgos = [DFS, BFS, BEST_FIRST];\nObject.freeze(unweightedPathAlgos);\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\nObject.freeze(optimalPathAlgos);\nexport { allPathAlgos, unweightedPathAlgos, optimalPathAlgos }; // TERRAIN ALGORTHIM CONSTANTS -------------------------------------------\n\nconst MAZE_GENERATION_SLEEP = 5;\nconst RECURSIVE_DIVISION = \"Recursive Division\";\nconst SIMPLEX_NOISE = \"Simplex Noise\";\nconst RANDOM_UNWEIGHTED = \"Random\";\nconst RANDOM_WEIGHTED = \"Random (Weighted)\";\nconst allTerrainAlgos = [RECURSIVE_DIVISION, SIMPLEX_NOISE, RANDOM_UNWEIGHTED, RANDOM_WEIGHTED];\nObject.freeze(allTerrainAlgos);\nconst unweightedTerrainAlgos = [RECURSIVE_DIVISION, RANDOM_UNWEIGHTED];\nObject.freeze(unweightedTerrainAlgos);\nconst terrainFunctions = {\n  [RECURSIVE_DIVISION]: recursiveDivision,\n  [SIMPLEX_NOISE]: simplexNoise,\n  [RANDOM_UNWEIGHTED]: random,\n  [RANDOM_WEIGHTED]: randomWeighted\n};\nObject.freeze(terrainFunctions);\nconst terrainAlgoSleepTimes = {\n  [RECURSIVE_DIVISION]: 5,\n  [SIMPLEX_NOISE]: 1,\n  [RANDOM_UNWEIGHTED]: 1,\n  [RANDOM_WEIGHTED]: 1\n};\nObject.freeze(terrainAlgoSleepTimes);\nexport { MAZE_GENERATION_SLEEP, RECURSIVE_DIVISION, SIMPLEX_NOISE, allTerrainAlgos, unweightedTerrainAlgos, terrainFunctions, terrainAlgoSleepTimes }; // NODE CONSTANTS ------------------------------------------------------------\n\nconst nodeTypeEnum = {\n  'path': 0,\n  'visited': 1,\n  'visiting': 2,\n  'none': 3,\n  'target': 4,\n  'start': 5,\n  'remObstacle': 6,\n  'wall': 7,\n  'weighted100': 8,\n  'weighted80': 9,\n  'weighted60': 10,\n  'weighted40': 11,\n  'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\nexport { nodeTypeEnum };\nconst nodeColorClass = {\n  [nodeTypeEnum.none]: 'none',\n  [nodeTypeEnum.target]: 'target',\n  [nodeTypeEnum.wall]: 'wall',\n  [nodeTypeEnum.visiting]: 'visiting',\n  [nodeTypeEnum.start]: 'start',\n  [nodeTypeEnum.visited]: 'visited',\n  [nodeTypeEnum.path]: 'path',\n  [nodeTypeEnum.weighted100]: 'weighted100',\n  [nodeTypeEnum.weighted80]: 'weighted80',\n  [nodeTypeEnum.weighted60]: 'weighted60',\n  [nodeTypeEnum.weighted40]: 'weighted40',\n  [nodeTypeEnum.weighted20]: 'weighted20'\n};\nObject.freeze(nodeColorClass);\nexport { nodeColorClass };\nconst EMPTY_NODE_BORDER_COLOR = '#3C4046';\nconst nodeColors = {\n  [nodeTypeEnum.none]: 'transparent',\n  [nodeTypeEnum.target]: '#f14846',\n  [nodeTypeEnum.wall]: '#18191c',\n  [nodeTypeEnum.visiting]: '#4988dc',\n  [nodeTypeEnum.start]: '#43b581',\n  [nodeTypeEnum.visited]: '#3f70dd',\n  [nodeTypeEnum.path]: '#f9a719',\n  [nodeTypeEnum.weighted100]: '#1b1c1e',\n  [nodeTypeEnum.weighted80]: '#1c1e21',\n  [nodeTypeEnum.weighted60]: '#222327',\n  [nodeTypeEnum.weighted40]: '#26272b',\n  [nodeTypeEnum.weighted20]: '#2b2c31'\n};\nObject.freeze(nodeColors);\nexport { EMPTY_NODE_BORDER_COLOR, nodeColors };\nconst nodeWeight = {\n  [nodeTypeEnum.none]: 1,\n  [nodeTypeEnum.target]: 1,\n  [nodeTypeEnum.wall]: Infinity,\n  [nodeTypeEnum.start]: 1,\n  [nodeTypeEnum.weighted100]: 100,\n  [nodeTypeEnum.weighted80]: 80,\n  [nodeTypeEnum.weighted60]: 60,\n  [nodeTypeEnum.weighted40]: 40,\n  [nodeTypeEnum.weighted20]: 20\n};\nObject.freeze(nodeWeight);\nexport { nodeWeight }; // OBSTACLE TYPES --------------------------------------------------------\n\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n  [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n  [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n  [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n  [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n  [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n  [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n};\nObject.freeze(obsEnum);\nexport { obstacleTypes, obsEnum }; // ALGO INFO BOX --------------------------------------------------------\n\nconst codeBlockCustomStyle = {\n  fontSize: 13,\n  backgroundColor: '#18191c',\n  borderRadius: 4,\n  padding: 20,\n  lineHeight: 1.5,\n  maxHeight: 250,\n  marginTop: 7,\n  marginBottom: 0\n};\nconst inLineCodeBlockCustomStyle = {\n  fontSize: 12,\n  backgroundColor: '#18191c',\n  borderRadius: 4,\n  padding: 4,\n  display: 'inline',\n  color: 'white',\n  fontWeight: 600\n};\nconst pathfindingAlgoInfo = {\n  [DIJKSTRAS]: {\n    'summary': /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [DIJKSTRAS, \" is a \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"greedy\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 41\n      }, this), \" pathfinding algorithm that is able find \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"optimal (shortest)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 105\n      }, this), \" paths, even in \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"weighted\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 156\n      }, this), \" graphs\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 190,\n      columnNumber: 20\n    }, this),\n    'description': null,\n    'pseudocode': /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n      language: \"python\",\n      style: atomOneDark,\n      showLineNumbers: true,\n      wrapLines: true,\n      customStyle: codeBlockCustomStyle,\n      children: `min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\n    if node != start_node:\n        dist[node] = Infinity\n        min_pq[node] = Infinity\n            \nwhile min_pq.len:\n    curr_node = min_pq.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev) # found path to target\n        \n    for neighbour in curr_node.neighbours:\n        new_cost = distance[curr_node] + \n                   edge(curr_node, neighbour).weight\n\n        if new_cost < dist[neighbour]:\n            # found better path, update the distance\n            dist[neighbour] = new_cost\n            min_pq[neighbour] = new_cost\n            prev[neighbour] = curr_node\n\n# no path found\nreturn`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 192,\n      columnNumber: 23\n    }, this)\n  },\n  [ASTAR]: {\n    'summary': /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [ASTAR, \" is an \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"informed\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 223,\n        columnNumber: 38\n      }, this), \" pathfinding algorithm that combines ideas from \", DIJKSTRAS, \" and \", BEST_FIRST, \" to guarantee \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"optimal (shortest)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 223,\n        columnNumber: 153\n      }, this), \" paths, even in \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"weighted\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 223,\n        columnNumber: 204\n      }, this), \" graphs\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 223,\n      columnNumber: 20\n    }, this),\n    'description': /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"The algorithm explores paths that minimize the function \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"f(node) = g(node) + h(node)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 83\n      }, this), \" where \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"g(node)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 235\n      }, this), \" is the cost of the path from \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: { ...inLineCodeBlockCustomStyle,\n          color: nodeColors[nodeTypeEnum.start]\n        },\n        children: \"start_node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 390\n      }, this), \" to \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 568\n      }, this), \" and \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"h(node)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 695\n      }, this), \" is the \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"heuristic function\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 828\n      }, this), \" which estimates the cost of the path from \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 906\n      }, this), \" to \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: { ...inLineCodeBlockCustomStyle,\n          color: nodeColors[nodeTypeEnum.target]\n        },\n        children: \"target_node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 1032\n      }, this), \".\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 24\n    }, this),\n    'pseudocode': /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n      language: \"python\",\n      style: atomOneDark,\n      showLineNumbers: true,\n      wrapLines: true,\n      customStyle: codeBlockCustomStyle,\n      children: `open_set = min_heap(start_node: 0);\nG = { start_node: 0 } # G(n) => tell us the current shortest distance from start node to node n\nH = { start_node: 0 } # H(n) => tells us the estimated distance from node n to target node\nF = { start_node: 0 } # F(n) = G(n) + H(n)\nprev = {}\n\nfor node in nodes:\n    if node == start_node:\n        continue\n    \n    F[node] = G[node] = H[node] = Infinity\n    \nwhile open_set not empty:\n    curr_node = open_set.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev)\n        \n    for neighbour in curr_node.neighbours:\n        new_G_score = G[curr_node] + weight(edge(curr_node, neighbour))\n        \n        if new_G_score < G[curr_node]:\n            # update all scores\n            G[neighbour] = new_G_score\n            H[neighbour] = heuristic_function(neighbour, targetCord); # get estimated cost from neighbour -> target\n            F[neighbour] = G[neighbour] + H[neighbour];\n            prev[neighbour] = curr_node;\n            openSet[neighbour] = F[neighbour]; # update priority of neighbour in open_set\n\n# no path found\nreturn`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 23\n    }, this)\n  },\n  [BFS]: {\n    'summary': /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [BFS, \" is an \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"uninformed/blind\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 260,\n        columnNumber: 36\n      }, this), \" search algorithm that gurantees finding the \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"optimal (shortest)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 260,\n        columnNumber: 114\n      }, this), \" paths only in \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"unweighted\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 260,\n        columnNumber: 164\n      }, this), \" graphs\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 260,\n      columnNumber: 20\n    }, this),\n    'pseudocode': /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n      language: \"python\",\n      style: atomOneDark,\n      showLineNumbers: true,\n      wrapLines: true,\n      customStyle: codeBlockCustomStyle,\n      children: `queue = [start_node]\nvisited = { start_node: 1 }\nprev = {}\n\nwhile queue.len:\n    curr_node = queue.dequeue()\n    \n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        prev[neighbour] = curr_node\n        queue.enqueue(neighbour)\n        visited[neighbour] = 1\n\n        if neighbour == target_node:\n            # we path to target_node\n            return create_path(prev)\n\n# no path found \nreturn`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 23\n    }, this)\n  },\n  [DFS]: {\n    'summary': /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [DFS, \" is an \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"uninformed/blind\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 286,\n        columnNumber: 36\n      }, this), \" search algorithm that is \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"unoptimal (may or may not find shortest path)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 286,\n        columnNumber: 95\n      }, this), \" and \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"unweighted\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 286,\n        columnNumber: 162\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 286,\n      columnNumber: 20\n    }, this),\n    'pseudocode': /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n      language: \"python\",\n      style: atomOneDark,\n      showLineNumbers: true,\n      wrapLines: true,\n      customStyle: codeBlockCustomStyle,\n      children: `stack = [start_node]\nvisited = { start_node: 1 }\n\nwhile stack.len:\n    curr_node = stack.pop()\n    stack.push(curr_node)\n\n    if curr_node == target_node:\n        return stack # our stack is the path to target_node\n    \n    flag = False\n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        stack.push(neighbour)\n        visited[neighbour] = 1\n        flag = True\n\n    if flag:\n        # no neighbours that need to be visited, pop the node from stack\n        stack.pop()\n\n# no path found \nreturn`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 287,\n      columnNumber: 23\n    }, this)\n  },\n  [BEST_FIRST]: {\n    'summary': /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [BEST_FIRST, \" is an \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"informed\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 43\n      }, this), \" and \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"greedy\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 73\n      }, this), \" pathfinding algorithm that is \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"unoptimal\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 127\n      }, this), \" (may or may not find the shortest paths) and \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"unweighted\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 199\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 316,\n      columnNumber: 20\n    }, this),\n    'description': /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"The algorithm explores paths that minimize the function \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"f(node) = h(node)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 83\n      }, this), \" where \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"h(node)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 225\n      }, this), \" is the \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"heuristic function\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 358\n      }, this), \" which estimates the cost of the path from \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: inLineCodeBlockCustomStyle,\n        children: \"node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 436\n      }, this), \" to \", /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n        language: 'text',\n        style: atomOneDark,\n        customStyle: { ...inLineCodeBlockCustomStyle,\n          color: nodeColors[nodeTypeEnum.target]\n        },\n        children: \"target_node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 562\n      }, this), \".\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 317,\n      columnNumber: 24\n    }, this),\n    'pseudocode': /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n      language: \"python\",\n      style: atomOneDark,\n      showLineNumbers: true,\n      wrapLines: true,\n      customStyle: codeBlockCustomStyle,\n      children: `min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\nif node != start_node:\n    dist[node] = Infinity\n    min_pq[node] = Infinity\n        \nwhile min_pq.len:\ncurr_node = min_pq.delete_min()\n\nif curr_node == target_node:\n    return create_path(prev) # found path to target\n    \nfor neighbour in curr_node.neighbours:\n    new_cost = distance[curr_node] + \n               edge(curr_node, neighbour).weight\n\n    if new_cost < dist[neighbour]:\n        # found better path, update the distance\n        dist[neighbour] = new_cost\n        min_pq[neighbour] = new_cost\n        prev[neighbour] = curr_node\n\n# no path found\nreturn`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 318,\n      columnNumber: 23\n    }, this)\n  }\n};\nObject.freeze(pathfindingAlgoInfo);\nexport { pathfindingAlgoInfo };","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/utils/constants.js"],"names":["dijkstras","dfs","bfs","aStar","bestFirstSearch","recursiveDivision","simplexNoise","random","randomWeighted","SyntaxHighlighter","atomOneDark","DIJKSTRAS","ASTAR","BFS","DFS","BEST_FIRST_SEARCH","algoFunctions","Object","freeze","PATH_CREATION_SLEEP","algoSleepTimes","BEST_FIRST","allPathAlgos","unweightedPathAlgos","optimalPathAlgos","MAZE_GENERATION_SLEEP","RECURSIVE_DIVISION","SIMPLEX_NOISE","RANDOM_UNWEIGHTED","RANDOM_WEIGHTED","allTerrainAlgos","unweightedTerrainAlgos","terrainFunctions","terrainAlgoSleepTimes","nodeTypeEnum","nodeColorClass","none","target","wall","visiting","start","visited","path","weighted100","weighted80","weighted60","weighted40","weighted20","EMPTY_NODE_BORDER_COLOR","nodeColors","nodeWeight","Infinity","obstacleTypes","obsEnum","codeBlockCustomStyle","fontSize","backgroundColor","borderRadius","padding","lineHeight","maxHeight","marginTop","marginBottom","inLineCodeBlockCustomStyle","display","color","fontWeight","pathfindingAlgoInfo"],"mappings":"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","sourcesContent":["import { dijkstras } from '../algorithms/path_finding/dijkstras.js'\nimport { dfs } from '../algorithms/path_finding/dfs.js'\nimport { bfs } from '../algorithms/path_finding/bfs.js'\nimport { aStar } from '../algorithms/path_finding/aStar.js'\nimport { bestFirstSearch } from '../algorithms/path_finding/bestFirstSearch.js';\nimport { recursiveDivision } from '../algorithms/terrain/recursiveDivision.js'\nimport { simplexNoise } from '../algorithms/terrain/simplexNoise.js'\nimport { random } from '../algorithms/terrain/random.js';\nimport { randomWeighted } from '../algorithms/terrain/randomWeighted.js';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { atomOneDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\n// PATHFINDING ALGORITHM CONSTANTS -------------------------------------------\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = 'A* (A-Star)';\nconst BFS = 'Breadth-first Search';\nconst DFS = 'Depth-first Search';\nconst BEST_FIRST_SEARCH = 'Greedy Best-first Search';\n\nconst algoFunctions = {\n    [DIJKSTRAS]: dijkstras,\n    [ASTAR]: aStar,\n    [BFS]: bfs,\n    [DFS]: dfs,\n    [BEST_FIRST_SEARCH]: bestFirstSearch\n};\nObject.freeze(algoFunctions);\n\nconst PATH_CREATION_SLEEP = 7;\nconst algoSleepTimes = {\n    [DIJKSTRAS]: 1,\n    [ASTAR]: 4,\n    [BFS]: 5,\n    [DFS]: 10,\n    [BEST_FIRST]: 11\n};\nObject.freeze(algoSleepTimes);\n\nexport { DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST_SEARCH, algoFunctions, PATH_CREATION_SLEEP, algoSleepTimes };\n\nconst allPathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST];\nObject.freeze(allPathAlgos);\nconst unweightedPathAlgos = [DFS, BFS, BEST_FIRST];\nObject.freeze(unweightedPathAlgos);\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\nObject.freeze(optimalPathAlgos);\n\nexport { allPathAlgos, unweightedPathAlgos, optimalPathAlgos };\n\n// TERRAIN ALGORTHIM CONSTANTS -------------------------------------------\nconst MAZE_GENERATION_SLEEP = 5;\nconst RECURSIVE_DIVISION = \"Recursive Division\";\nconst SIMPLEX_NOISE = \"Simplex Noise\";\nconst RANDOM_UNWEIGHTED = \"Random\";\nconst RANDOM_WEIGHTED = \"Random (Weighted)\"\nconst allTerrainAlgos = [RECURSIVE_DIVISION, SIMPLEX_NOISE, RANDOM_UNWEIGHTED, RANDOM_WEIGHTED];\nObject.freeze(allTerrainAlgos);\n\nconst unweightedTerrainAlgos = [RECURSIVE_DIVISION, RANDOM_UNWEIGHTED];\nObject.freeze(unweightedTerrainAlgos);\n\nconst terrainFunctions = {\n    [RECURSIVE_DIVISION]: recursiveDivision,\n    [SIMPLEX_NOISE]: simplexNoise,\n    [RANDOM_UNWEIGHTED]: random,\n    [RANDOM_WEIGHTED]: randomWeighted,\n};\nObject.freeze(terrainFunctions);\n\nconst terrainAlgoSleepTimes = {\n    [RECURSIVE_DIVISION]: 5,\n    [SIMPLEX_NOISE]: 1,\n    [RANDOM_UNWEIGHTED]: 1,\n    [RANDOM_WEIGHTED]: 1\n};\nObject.freeze(terrainAlgoSleepTimes);\n\nexport { MAZE_GENERATION_SLEEP, RECURSIVE_DIVISION, SIMPLEX_NOISE, allTerrainAlgos, unweightedTerrainAlgos, terrainFunctions, terrainAlgoSleepTimes };\n\n// NODE CONSTANTS ------------------------------------------------------------\nconst nodeTypeEnum = {\n    'path': 0,\n    'visited': 1,\n    'visiting': 2,\n    'none': 3,\n    'target': 4,\n    'start': 5,\n    'remObstacle': 6,\n    'wall': 7,\n    'weighted100': 8,\n    'weighted80': 9,\n    'weighted60': 10,\n    'weighted40': 11,\n    'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\n\nexport { nodeTypeEnum };\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'none',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.wall]: 'wall',\n    [nodeTypeEnum.visiting]: 'visiting',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path',\n    [nodeTypeEnum.weighted100]: 'weighted100',\n    [nodeTypeEnum.weighted80]: 'weighted80',\n    [nodeTypeEnum.weighted60]: 'weighted60',\n    [nodeTypeEnum.weighted40]: 'weighted40',\n    [nodeTypeEnum.weighted20]: 'weighted20'\n};\nObject.freeze(nodeColorClass);\n\nexport { nodeColorClass };\n\nconst EMPTY_NODE_BORDER_COLOR = '#3C4046';\nconst nodeColors = {\n    [nodeTypeEnum.none]: 'transparent',\n    [nodeTypeEnum.target]: '#f14846',\n    [nodeTypeEnum.wall]: '#18191c',\n    [nodeTypeEnum.visiting]: '#4988dc',\n    [nodeTypeEnum.start]: '#43b581',\n    [nodeTypeEnum.visited]: '#3f70dd',\n    [nodeTypeEnum.path]: '#f9a719',\n    [nodeTypeEnum.weighted100]: '#1b1c1e',\n    [nodeTypeEnum.weighted80]: '#1c1e21',\n    [nodeTypeEnum.weighted60]: '#222327',\n    [nodeTypeEnum.weighted40]: '#26272b',\n    [nodeTypeEnum.weighted20]: '#2b2c31'\n};\nObject.freeze(nodeColors);\n\nexport { EMPTY_NODE_BORDER_COLOR, nodeColors };\n\nconst nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.wall]: Infinity,\n    [nodeTypeEnum.start]: 1,\n    [nodeTypeEnum.weighted100]: 100,\n    [nodeTypeEnum.weighted80]: 80,\n    [nodeTypeEnum.weighted60]: 60,\n    [nodeTypeEnum.weighted40]: 40,\n    [nodeTypeEnum.weighted20]: 20\n};\nObject.freeze(nodeWeight);\nexport { nodeWeight };\n\n// OBSTACLE TYPES --------------------------------------------------------\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n    [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n    [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n    [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n    [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n    [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n    [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n};\nObject.freeze(obsEnum);\n\nexport { obstacleTypes, obsEnum };\n\n// ALGO INFO BOX --------------------------------------------------------\n\nconst codeBlockCustomStyle = {\n    fontSize: 13,\n    backgroundColor: '#18191c',\n    borderRadius: 4,\n    padding: 20,\n    lineHeight: 1.5,\n    maxHeight: 250,\n    marginTop: 7,\n    marginBottom: 0\n};\n\nconst inLineCodeBlockCustomStyle = {\n    fontSize: 12,\n    backgroundColor: '#18191c',\n    borderRadius: 4,\n    padding: 4,\n    display: 'inline',\n    color: 'white',\n    fontWeight: 600\n};\n\nconst pathfindingAlgoInfo = {\n    [DIJKSTRAS]: {\n        'summary': <h4>{DIJKSTRAS} is a <strong>greedy</strong> pathfinding algorithm that is able find <strong>optimal (shortest)</strong> paths, even in <strong>weighted</strong> graphs</h4>,\n        'description': null,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\n    if node != start_node:\n        dist[node] = Infinity\n        min_pq[node] = Infinity\n            \nwhile min_pq.len:\n    curr_node = min_pq.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev) # found path to target\n        \n    for neighbour in curr_node.neighbours:\n        new_cost = distance[curr_node] + \n                   edge(curr_node, neighbour).weight\n\n        if new_cost < dist[neighbour]:\n            # found better path, update the distance\n            dist[neighbour] = new_cost\n            min_pq[neighbour] = new_cost\n            prev[neighbour] = curr_node\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    },\n    [ASTAR]: {\n        'summary': <h4>{ASTAR} is an <strong>informed</strong> pathfinding algorithm that combines ideas from {DIJKSTRAS} and {BEST_FIRST} to guarantee <strong>optimal (shortest)</strong> paths, even in <strong>weighted</strong> graphs</h4>,\n        'description': <p>The algorithm explores paths that minimize the function <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>f(node) = g(node) + h(node)</SyntaxHighlighter> where <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>g(node)</SyntaxHighlighter> is the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.start] }}>start_node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> and <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>h(node)</SyntaxHighlighter> is the <strong>heuristic function</strong> which estimates the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.target] }}>target_node</SyntaxHighlighter>.</p>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`open_set = min_heap(start_node: 0);\nG = { start_node: 0 } # G(n) => tell us the current shortest distance from start node to node n\nH = { start_node: 0 } # H(n) => tells us the estimated distance from node n to target node\nF = { start_node: 0 } # F(n) = G(n) + H(n)\nprev = {}\n\nfor node in nodes:\n    if node == start_node:\n        continue\n    \n    F[node] = G[node] = H[node] = Infinity\n    \nwhile open_set not empty:\n    curr_node = open_set.delete_min()\n    \n    if curr_node == target_node:\n        return create_path(prev)\n        \n    for neighbour in curr_node.neighbours:\n        new_G_score = G[curr_node] + weight(edge(curr_node, neighbour))\n        \n        if new_G_score < G[curr_node]:\n            # update all scores\n            G[neighbour] = new_G_score\n            H[neighbour] = heuristic_function(neighbour, targetCord); # get estimated cost from neighbour -> target\n            F[neighbour] = G[neighbour] + H[neighbour];\n            prev[neighbour] = curr_node;\n            openSet[neighbour] = F[neighbour]; # update priority of neighbour in open_set\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    },\n    [BFS]: {\n        'summary': <h4>{BFS} is an <strong>uninformed/blind</strong> search algorithm that gurantees finding the <strong>optimal (shortest)</strong> paths only in <strong>unweighted</strong> graphs</h4>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`queue = [start_node]\nvisited = { start_node: 1 }\nprev = {}\n\nwhile queue.len:\n    curr_node = queue.dequeue()\n    \n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        prev[neighbour] = curr_node\n        queue.enqueue(neighbour)\n        visited[neighbour] = 1\n\n        if neighbour == target_node:\n            # we path to target_node\n            return create_path(prev)\n\n# no path found \nreturn`}\n        </SyntaxHighlighter>\n    },\n    [DFS]: {\n        'summary': <h4>{DFS} is an <strong>uninformed/blind</strong> search algorithm that is <strong>unoptimal (may or may not find shortest path)</strong> and <strong>unweighted</strong></h4>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`stack = [start_node]\nvisited = { start_node: 1 }\n\nwhile stack.len:\n    curr_node = stack.pop()\n    stack.push(curr_node)\n\n    if curr_node == target_node:\n        return stack # our stack is the path to target_node\n    \n    flag = False\n    for neighbour in curr_node.neighbours:\n        if neighbour in visited:\n            continue # skip nodes that are already visited\n        \n        stack.push(neighbour)\n        visited[neighbour] = 1\n        flag = True\n\n    if flag:\n        # no neighbours that need to be visited, pop the node from stack\n        stack.pop()\n\n# no path found \nreturn`}\n        </SyntaxHighlighter>\n    },\n    [BEST_FIRST]: {\n        'summary': <h4>{BEST_FIRST} is an <strong>informed</strong> and <strong>greedy</strong> pathfinding algorithm that is <strong>unoptimal</strong> (may or may not find the shortest paths) and <strong>unweighted</strong></h4>,\n        'description': <p>The algorithm explores paths that minimize the function <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>f(node) = h(node)</SyntaxHighlighter> where <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>h(node)</SyntaxHighlighter> is the <strong>heuristic function</strong> which estimates the cost of the path from <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={inLineCodeBlockCustomStyle}>node</SyntaxHighlighter> to <SyntaxHighlighter language={'text'} style={atomOneDark} customStyle={{ ...inLineCodeBlockCustomStyle, color: nodeColors[nodeTypeEnum.target] }}>target_node</SyntaxHighlighter>.</p>,\n        'pseudocode': <SyntaxHighlighter language=\"python\" style={atomOneDark} showLineNumbers={true} wrapLines={true} customStyle={codeBlockCustomStyle}>\n            {`min_pq = min_heap(start_node: 0)\ndist = { start_node: 0 }\nprev = {}\n\nfor node in nodes:\nif node != start_node:\n    dist[node] = Infinity\n    min_pq[node] = Infinity\n        \nwhile min_pq.len:\ncurr_node = min_pq.delete_min()\n\nif curr_node == target_node:\n    return create_path(prev) # found path to target\n    \nfor neighbour in curr_node.neighbours:\n    new_cost = distance[curr_node] + \n               edge(curr_node, neighbour).weight\n\n    if new_cost < dist[neighbour]:\n        # found better path, update the distance\n        dist[neighbour] = new_cost\n        min_pq[neighbour] = new_cost\n        prev[neighbour] = curr_node\n\n# no path found\nreturn`}\n        </SyntaxHighlighter>\n    }\n};\nObject.freeze(pathfindingAlgoInfo);\nexport { pathfindingAlgoInfo };\n\n"]},"metadata":{},"sourceType":"module"}