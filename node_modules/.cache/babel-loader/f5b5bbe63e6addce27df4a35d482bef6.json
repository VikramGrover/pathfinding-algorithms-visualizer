{"ast":null,"code":"import { getNodeTypeEnum, getNodeWeight, getNeighbourNodes, createPath } from '../../utils/util.js';\nexport const aStar = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n  let openSet = {\n    [startCord]: 0\n  };\n  let G = {\n    [startCord]: 0\n  }; // G(n) => tell us the current shortest distance from start node to node n\n\n  let H = {\n    [startCord]: 0\n  }; // H(n) => tells us the estimated distance from node n to target node\n\n  let F = {\n    [startCord]: 0\n  }; // F(n) = G(n) + H(n)\n\n  let prevNodes = {}; // intialize all the scores to infinity for all node !== start node\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      let cord = `${x}:${y}`;\n\n      if (cord !== startCord) {\n        F[cord] = G[cord] = H[cord] = Infinity;\n      }\n    }\n  }\n\n  while (Object.keys(openSet).length > 0) {\n    const currNode = findMinPriorityNode(openSet);\n    console.log('openSet:   ', openSet);\n    delete openSet[currNode];\n\n    if (currNode !== startCord && currNode !== targetCord) {\n      setTimeout(() => {\n        setGridState(prevState => ({ ...prevState,\n          [currNode]: [getNodeTypeEnum('visited'), ...prevState[currNode].slice(1)]\n        }));\n      }, timeout);\n    } else if (currNode === targetCord) {\n      // we have reached target, return path\n      return createPath(startCord, targetCord, prevNodes);\n    }\n\n    const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n\n    for (const neighbour of neighbours) {\n      const currGScore = G[currNode] + getNodeWeight(neighbour);\n\n      if (neighbour !== startCord && neighbour !== targetCord) {\n        setTimeout(() => {\n          setGridState(prevState => ({ ...prevState,\n            [neighbour]: [getNodeTypeEnum('visiting'), ...prevState[neighbour]]\n          }));\n        }, timeout);\n      }\n\n      console.log(getNodeWeight(neighbour));\n\n      if (currGScore < G[neighbour]) {\n        // newly calculated G score of neighbour is lower than the one in the table\n        // update all the scores\n        G[neighbour] = currGScore;\n        H[neighbour] = getHScoreEstimate(neighbour, targetCord);\n        F[neighbour] = G[neighbour] + H[neighbour];\n        prevNodes[neighbour] = currNode;\n        openSet[neighbour] = F[neighbour];\n      }\n    }\n  }\n\n  return [];\n};\n\nconst findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] === minPriority) {\n      return key;\n    }\n  }\n};\n\nconst getHScoreEstimate = (cord, targetCord) => {\n  if (cord === targetCord) {\n    return 0;\n  }\n\n  return 1;\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/aStar.js"],"names":["getNodeTypeEnum","getNodeWeight","getNeighbourNodes","createPath","aStar","startCord","targetCord","gridState","setGridState","rows","cols","timeout","openSet","G","H","F","prevNodes","x","y","cord","Infinity","Object","keys","length","currNode","findMinPriorityNode","console","log","setTimeout","prevState","slice","neighbours","neighbour","currGScore","getHScoreEstimate","minPQ","minPriority","Math","min","values","key"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight, getNeighbourNodes, createPath } from '../../utils/util.js'\n\nexport const aStar = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let G = { [startCord]: 0 }; // G(n) => tell us the current shortest distance from start node to node n\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = G(n) + H(n)\n    let prevNodes = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = G[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        console.log('openSet:   ', openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currNode]: [getNodeTypeEnum('visited'), ...prevState[currNode].slice(1)] }));\n            }, timeout);\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currGScore = G[currNode] + getNodeWeight(neighbour);\n\n            if (neighbour !== startCord && neighbour !== targetCord) {\n                setTimeout(() => {\n                    setGridState(prevState => ({ ...prevState, [neighbour]: [getNodeTypeEnum('visiting'), ...prevState[neighbour]] }));\n                }, timeout);\n            }\n\n            console.log(getNodeWeight(neighbour));\n            if (currGScore < G[neighbour]) {\n\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                G[neighbour] = currGScore;\n                H[neighbour] = getHScoreEstimate(neighbour, targetCord);\n                F[neighbour] = G[neighbour] + H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n    }\n\n    return [];\n};\n\nconst findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nconst getHScoreEstimate = (cord, targetCord) => {\n    if (cord === targetCord) {\n        return 0;\n    }\n\n    return 1;\n};"]},"metadata":{},"sourceType":"module"}