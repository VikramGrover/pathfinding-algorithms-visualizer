{"ast":null,"code":"import _toConsumableArray from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{getNodeTypeEnum,getNodeWeight,shuffleArray}from'../../utils/util.js';export var dijkstras=function dijkstras(startCord,targetCord,gridState,setGridState,rows,cols){console.log(\"STARTING DIJSTRAS\");if(startCord===targetCord){console.log(\"ENDING DIJSTRAS\");return[];}var totalCosts={};var prevNodes={};var minPQ={};var visited={};totalCosts[startCord]=0;minPQ[startCord]=0;for(var x=0;x<rows;x++){for(var y=0;y<cols;y++){var cord=\"\".concat(x,\":\").concat(y);if(cord!==startCord){totalCosts[cord]=Infinity;}}}var _loop=function _loop(){var minKey=findMinPriorityNode(minPQ);delete minPQ[minKey];visited[minKey]=1;if(minKey!==startCord&&minKey!==targetCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},minKey,[getNodeTypeEnum('visited')]));});},1);}else if(minKey===targetCord){console.log(\"ENDING DIJSTRAS\");return{v:createPath(startCord,targetCord,prevNodes)};}var neighbours=getNeighbourNodes(minKey,rows,cols,gridState);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbour=_step.value;var currPath=totalCosts[minKey]+getNodeWeight(gridState[neighbour][0]);if(neighbour in visited){continue;}if(neighbour in minPQ&&currPath<totalCosts[neighbour]||!(neighbour in minPQ)){totalCosts[neighbour]=currPath;prevNodes[neighbour]=minKey;minPQ[neighbour]=currPath;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(Object.keys(minPQ).length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}console.log(\"ENDING DIJSTRAS\");return[];};var createPath=function createPath(startCord,targetCord,prevNodes){var cord=targetCord;var path=[];while(true){cord=prevNodes[cord];if(cord===startCord){break;}path.push(cord);}return path;};var getNeighbourNodes=function getNeighbourNodes(node,rows,cols,gridState){var row=parseInt(node.split(':')[0]);var col=parseInt(node.split(':')[1]);var res=[];if(col+1<cols&&gridState[\"\".concat(row,\":\").concat(col+1)][0]!==getNodeTypeEnum('obstacle')){res.push(\"\".concat(row,\":\").concat(col+1));}if(row-1>=0&&gridState[\"\".concat(row-1,\":\").concat(col)][0]!==getNodeTypeEnum('obstacle')){res.push(\"\".concat(row-1,\":\").concat(col));}if(row+1<rows&&gridState[\"\".concat(row+1,\":\").concat(col)][0]!==getNodeTypeEnum('obstacle')){res.push(\"\".concat(row+1,\":\").concat(col));}if(col-1>=0&&gridState[\"\".concat(row,\":\").concat(col-1)][0]!==getNodeTypeEnum('obstacle')){res.push(\"\".concat(row,\":\").concat(col-1));}shuffleArray(res);return res;};var findMinPriorityNode=function findMinPriorityNode(minPQ){var minPriority=Math.min.apply(Math,_toConsumableArray(Object.values(minPQ)));for(var key in minPQ){if(minPQ[key]===minPriority){return key;}}};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNodeTypeEnum","getNodeWeight","shuffleArray","dijkstras","startCord","targetCord","gridState","setGridState","rows","cols","console","log","totalCosts","prevNodes","minPQ","visited","x","y","cord","Infinity","minKey","findMinPriorityNode","setTimeout","prevState","createPath","neighbours","getNeighbourNodes","neighbour","currPath","Object","keys","length","path","push","node","row","parseInt","split","col","res","minPriority","Math","min","values","key"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight, shuffleArray } from '../../utils/util.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n    console.log(\"STARTING DIJSTRAS\");\n\n    if (startCord === targetCord) {\n        console.log(\"ENDING DIJSTRAS\");\n        return [];\n    }\n\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [minKey]: [getNodeTypeEnum('visited')] }));\n            }, 1);\n        }\n        else if (minKey === targetCord) {\n            console.log(\"ENDING DIJSTRAS\");\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + getNodeWeight(gridState[neighbour][0]);\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n            }\n        }\n    }\n\n    console.log(\"ENDING DIJSTRAS\");\n    return [];\n};\n\nconst createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nconst getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0] !== getNodeTypeEnum('obstacle'))) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    shuffleArray(res);\n    return res;\n};\n\nconst findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};"]},"metadata":{},"sourceType":"module"}