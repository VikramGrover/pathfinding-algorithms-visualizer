{"ast":null,"code":"import _regeneratorRuntime from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{nodeTypeEnum}from'../../utils/constants.js';import{getRandomNum}from'../../utils/helper.js';export var randomWeighted=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var gridMap,x,_loop,y,_ret;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:gridMap={};x=0;case 2:if(!(x<rows)){_context.next=15;break;}_loop=function _loop(y){var currCord=\"\".concat(x,\":\").concat(y);var nodeStateFunc=gridState[currCord][1];var randomNum=getRandomNum(1,10);if(randomNum>=5){// don't place obstacle\nvar _newState=[nodeTypeEnum.none];if(currCord===startCord){_newState.unshift(nodeTypeEnum.start);}else if(currCord===targetCord){_newState.unshift(nodeTypeEnum.target);}gridMap[currCord]=[_newState,nodeStateFunc];return\"continue\";}// place a random obstacle\nvar randomObstacle=getRandomNum(nodeTypeEnum.wall,nodeTypeEnum.weighted20);var newState=[randomObstacle,nodeTypeEnum.none];if(currCord===startCord){newState.unshift(nodeTypeEnum.start);}else if(currCord===targetCord){newState.unshift(nodeTypeEnum.target);}nodeStateFunc(function(prevState){return newState;});gridMap[currCord]=[newState,nodeStateFunc];};y=0;case 5:if(!(y<cols)){_context.next=12;break;}_ret=_loop(y);if(!(_ret===\"continue\")){_context.next=9;break;}return _context.abrupt(\"continue\",9);case 9:y++;_context.next=5;break;case 12:x++;_context.next=2;break;case 15:setGridState(function(prevState){return gridMap;});case 16:case\"end\":return _context.stop();}}},_callee);}));return function randomWeighted(_x,_x2,_x3,_x4,_x5,_x6,_x7){return _ref.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/terrain/randomWeighted.js"],"names":["nodeTypeEnum","getRandomNum","randomWeighted","startCord","targetCord","gridState","setGridState","rows","cols","timeout","gridMap","x","y","currCord","nodeStateFunc","randomNum","newState","none","unshift","start","target","randomObstacle","wall","weighted20","prevState"],"mappings":"uXAAA,OAASA,YAAT,KAA6B,0BAA7B,CACA,OAASC,YAAT,KAA6B,uBAA7B,CAEA,MAAO,IAAMC,CAAAA,cAAc,0FAAG,iBAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,SAA9B,CAAyCC,YAAzC,CAAuDC,IAAvD,CAA6DC,IAA7D,CAAmEC,OAAnE,6IACtBC,OADsB,CACZ,EADY,CAEjBC,CAFiB,CAEb,CAFa,aAEVA,CAAC,CAAGJ,IAFM,gDAGbK,CAHa,EAIlB,GAAMC,CAAAA,QAAQ,WAAMF,CAAN,aAAWC,CAAX,CAAd,CACA,GAAME,CAAAA,aAAa,CAAGT,SAAS,CAACQ,QAAD,CAAT,CAAoB,CAApB,CAAtB,CACA,GAAME,CAAAA,SAAS,CAAGd,YAAY,CAAC,CAAD,CAAI,EAAJ,CAA9B,CAEA,GAAIc,SAAS,EAAI,CAAjB,CAAoB,CAChB;AACA,GAAIC,CAAAA,SAAQ,CAAG,CAAChB,YAAY,CAACiB,IAAd,CAAf,CAEA,GAAIJ,QAAQ,GAAKV,SAAjB,CAA4B,CACxBa,SAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACmB,KAA9B,EACH,CAFD,IAGK,IAAIN,QAAQ,GAAKT,UAAjB,CAA6B,CAC9BY,SAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACoB,MAA9B,EACH,CAEDV,OAAO,CAACG,QAAD,CAAP,CAAoB,CAACG,SAAD,CAAWF,aAAX,CAApB,CACA,iBACH,CAED;AACA,GAAMO,CAAAA,cAAc,CAAGpB,YAAY,CAACD,YAAY,CAACsB,IAAd,CAAoBtB,YAAY,CAACuB,UAAjC,CAAnC,CACA,GAAIP,CAAAA,QAAQ,CAAG,CAACK,cAAD,CAAiBrB,YAAY,CAACiB,IAA9B,CAAf,CAEA,GAAIJ,QAAQ,GAAKV,SAAjB,CAA4B,CACxBa,QAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACmB,KAA9B,EACH,CAFD,IAGK,IAAIN,QAAQ,GAAKT,UAAjB,CAA6B,CAC9BY,QAAQ,CAACE,OAAT,CAAiBlB,YAAY,CAACoB,MAA9B,EACH,CAEDN,aAAa,CAAC,SAAAU,SAAS,QAAIR,CAAAA,QAAJ,EAAV,CAAb,CACAN,OAAO,CAACG,QAAD,CAAP,CAAoB,CAACG,QAAD,CAAWF,aAAX,CAApB,CAnCkB,EAGbF,CAHa,CAGT,CAHS,aAGNA,CAAC,CAAGJ,IAHE,sCAGbI,CAHa,8FAGIA,CAAC,EAHL,+BAEAD,CAAC,EAFD,+BAuC1BL,YAAY,CAAC,SAAAkB,SAAS,QAAId,CAAAA,OAAJ,EAAV,CAAZ,CAvC0B,uDAAH,kBAAdR,CAAAA,cAAc,oEAApB","sourcesContent":["import { nodeTypeEnum } from '../../utils/constants.js';\nimport { getRandomNum } from '../../utils/helper.js'\n\nexport const randomWeighted = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            const currCord = `${x}:${y}`;\n            const nodeStateFunc = gridState[currCord][1];\n            const randomNum = getRandomNum(1, 10);\n\n            if (randomNum >= 5) {\n                // don't place obstacle\n                let newState = [nodeTypeEnum.none];\n\n                if (currCord === startCord) {\n                    newState.unshift(nodeTypeEnum.start);\n                }\n                else if (currCord === targetCord) {\n                    newState.unshift(nodeTypeEnum.target);\n                }\n\n                gridMap[currCord] = [newState, nodeStateFunc];\n                continue;\n            }\n\n            // place a random obstacle\n            const randomObstacle = getRandomNum(nodeTypeEnum.wall, nodeTypeEnum.weighted20);\n            let newState = [randomObstacle, nodeTypeEnum.none];\n\n            if (currCord === startCord) {\n                newState.unshift(nodeTypeEnum.start);\n            }\n            else if (currCord === targetCord) {\n                newState.unshift(nodeTypeEnum.target);\n            }\n\n            nodeStateFunc(prevState => newState);\n            gridMap[currCord] = [newState, nodeStateFunc];\n        }\n    }\n\n    setGridState(prevState => gridMap);\n};"]},"metadata":{},"sourceType":"module"}