{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _objectSpread from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _defineProperty from\"/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{getNeighbourNodes}from'../../utils/helper.js';import{nodeTypeEnum}from'../../utils/constants.js';export var dfs=function dfs(startCord,targetCord,gridState,setGridState,rows,cols,timeout){var stack=[startCord];var path=[];var visited=_defineProperty({},startCord,1);var _loop=function _loop(){var currCord=stack[0];if(currCord!==targetCord&&currCord!==startCord){setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[nodeTypeEnum.visiting,nodeTypeEnum.none]));});},timeout);}if(currCord===targetCord){stack.pop();stack.shift();return{v:stack};}if(currCord!==startCord){path.unshift(currCord);visited[currCord]=1;setTimeout(function(){setGridState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},currCord,[nodeTypeEnum.visited,nodeTypeEnum.none]));});},timeout);}var neighbours=getNeighbourNodes(currCord,rows,cols,gridState);var unvisitedNeighbourFound=false;var _iterator=_createForOfIteratorHelper(neighbours),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbour=_step.value;if(neighbour in visited){continue;}stack.unshift(neighbour);unvisitedNeighbourFound=true;break;}}catch(err){_iterator.e(err);}finally{_iterator.f();}if(!unvisitedNeighbourFound){stack.splice(0,1);}};while(stack.length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[];};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dfs.js"],"names":["getNeighbourNodes","nodeTypeEnum","dfs","startCord","targetCord","gridState","setGridState","rows","cols","timeout","stack","path","visited","currCord","setTimeout","prevState","visiting","none","pop","shift","unshift","neighbours","unvisitedNeighbourFound","neighbour","splice","length"],"mappings":"glBAAA,OAASA,iBAAT,KAAkC,uBAAlC,CACA,OAASC,YAAT,KAA6B,0BAA7B,CAEA,MAAO,IAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,SAAxB,CAAmCC,YAAnC,CAAiDC,IAAjD,CAAuDC,IAAvD,CAA6DC,OAA7D,CAAyE,CACxF,GAAMC,CAAAA,KAAK,CAAG,CAACP,SAAD,CAAd,CACA,GAAMQ,CAAAA,IAAI,CAAG,EAAb,CACA,GAAMC,CAAAA,OAAO,oBAAMT,SAAN,CAAkB,CAAlB,CAAb,CAHwF,2BAMpF,GAAMU,CAAAA,QAAQ,CAAGH,KAAK,CAAC,CAAD,CAAtB,CACA,GAAIG,QAAQ,GAAKT,UAAb,EAA2BS,QAAQ,GAAKV,SAA5C,CAAuD,CACnDW,UAAU,CAAC,UAAM,CACbR,YAAY,CAAC,SAAAS,SAAS,wCAAUA,SAAV,wBAAsBF,QAAtB,CAAiC,CAACZ,YAAY,CAACe,QAAd,CAAwBf,YAAY,CAACgB,IAArC,CAAjC,IAAV,CAAZ,CACH,CAFS,CAEPR,OAFO,CAAV,CAGH,CAED,GAAII,QAAQ,GAAKT,UAAjB,CAA6B,CACzBM,KAAK,CAACQ,GAAN,GACAR,KAAK,CAACS,KAAN,GACA,SAAOT,KAAP,EACH,CAED,GAAIG,QAAQ,GAAKV,SAAjB,CAA4B,CACxBQ,IAAI,CAACS,OAAL,CAAaP,QAAb,EACAD,OAAO,CAACC,QAAD,CAAP,CAAoB,CAApB,CACAC,UAAU,CAAC,UAAM,CACbR,YAAY,CAAC,SAAAS,SAAS,wCAAUA,SAAV,wBAAsBF,QAAtB,CAAiC,CAACZ,YAAY,CAACW,OAAd,CAAuBX,YAAY,CAACgB,IAApC,CAAjC,IAAV,CAAZ,CACH,CAFS,CAEPR,OAFO,CAAV,CAGH,CAED,GAAMY,CAAAA,UAAU,CAAGrB,iBAAiB,CAACa,QAAD,CAAWN,IAAX,CAAiBC,IAAjB,CAAuBH,SAAvB,CAApC,CACA,GAAIiB,CAAAA,uBAAuB,CAAG,KAA9B,CA5BoF,yCA6B5DD,UA7B4D,YA6BpF,+CAAoC,IAAzBE,CAAAA,SAAyB,aAChC,GAAIA,SAAS,GAAIX,CAAAA,OAAjB,CAA0B,CACtB,SACH,CAEDF,KAAK,CAACU,OAAN,CAAcG,SAAd,EACAD,uBAAuB,CAAG,IAA1B,CACA,MACH,CArCmF,qDAuCpF,GAAI,CAACA,uBAAL,CAA8B,CAC1BZ,KAAK,CAACc,MAAN,CAAa,CAAb,CAAgB,CAAhB,EACH,CAzCmF,EAKxF,MAAOd,KAAK,CAACe,MAAN,CAAe,CAAtB,CAAyB,0DAqCxB,CAED,MAAO,EAAP,CACH,CA7CM","sourcesContent":["import { getNeighbourNodes } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const path = [];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [nodeTypeEnum.visiting, nodeTypeEnum.none] }));\n            }, timeout);\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            path.unshift(currCord);\n            visited[currCord] = 1;\n            setTimeout(() => {\n                setGridState(prevState => ({ ...prevState, [currCord]: [nodeTypeEnum.visited, nodeTypeEnum.none] }));\n            }, timeout);\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n    }\n\n    return [];\n};"]},"metadata":{},"sourceType":"module"}