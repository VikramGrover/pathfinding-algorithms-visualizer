{"ast":null,"code":"import { getNodeTypeEnum, getNodeWeight } from '../../utils/util.js';\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n  let totalCosts = {};\n  let prevNodes = {};\n  let minPQ = {};\n  let visited = {};\n  totalCosts[startCordStr] = 0;\n  minPQ[startCordStr] = 0;\n\n  for (let x = 0; x < rows; x++) {\n    for (let y = 0; y < cols; y++) {\n      let cord = `${x}:${y}`;\n\n      if (cord !== startCord) {\n        totalCosts[cord] = Infinity;\n      }\n    }\n  }\n\n  while (Object.keys(minPQ).length) {\n    const {\n      minKey,\n      minPriority\n    } = findMinPriorityNode(minPQ);\n    delete minPQ[minKey];\n    visited[minKey] = 1;\n    setGridState(prevState => ({ ...prevState,\n      [minKey]: getNodeTypeEnum('visited')\n    }));\n\n    if (minKey === targetCord) {\n      console.log(\"WE ARE DONE DIJKSTRAS\");\n      return;\n    }\n\n    const neighbours = getNeighbourNodes(minKey, rows, cols);\n\n    for (const neighbour of neighbours) {\n      if (!(neighbour in visited)) {\n        const altPath = totalCosts[neighbour] + getNodeWeight(gridState[neighbour]);\n\n        if (altPath < totalCosts[neighbour]) {\n          totalCosts[neighbour] = altPath;\n          prevNodes[neighbour] = minKey;\n          minPQ[neighbour] = altPath;\n        }\n      } else if (!(neighbour in minPQ)) {\n        minPQ[neighbour] = totalCosts[minKey] + getNodeWeight(gridState[neighbour]);\n      }\n    }\n  }\n};\n\nconst getNeighbourNodes = (node, rows, cols) => {\n  const row = parseInt(node.split(':')[0]);\n  const col = parseInt(node.split(':')[1]);\n  let res = [];\n\n  if (row - 1 >= 0) {\n    res.push(`${row - 1}:${col}`);\n  }\n\n  if (row + 1 < rows) {\n    res.push(`${row + 1}:${col}`);\n  }\n\n  if (col - 1 >= 0) {\n    res.push(`${row}:${col - 1}`);\n  }\n\n  if (col + 1 < cols) {\n    res.push(`${row}:${col + 1}`);\n  }\n\n  return res;\n};\n\nconst findMinPriorityNode = minPQ => {\n  let minPriority = Math.min(...Object.values(minPQ));\n\n  for (const key in minPQ) {\n    if (minPQ[key] == minPriority) {\n      return {\n        key,\n        minPriority\n      };\n    }\n  }\n};","map":{"version":3,"sources":["/Users/vikramgrover/Documents/coding/pathfinding-algorithms-visualizer/src/algorithms/path_finding/dijkstras.js"],"names":["getNodeTypeEnum","getNodeWeight","dijkstras","startCord","targetCord","gridState","setGridState","rows","cols","totalCosts","prevNodes","minPQ","visited","startCordStr","x","y","cord","Infinity","Object","keys","length","minKey","minPriority","findMinPriorityNode","prevState","console","log","neighbours","getNeighbourNodes","neighbour","altPath","node","row","parseInt","split","col","res","push","Math","min","values","key"],"mappings":"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","sourcesContent":["import { getNodeTypeEnum, getNodeWeight } from '../../utils/util.js'\n\nexport const dijkstras = (startCord, targetCord, gridState, setGridState, rows, cols) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCordStr] = 0;\n    minPQ[startCordStr] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length) {\n        const { minKey, minPriority } = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n\n        visited[minKey] = 1;\n        setGridState(prevState => ({ ...prevState, [minKey]: getNodeTypeEnum('visited') }));\n\n        if (minKey === targetCord) {\n            console.log(\"WE ARE DONE DIJKSTRAS\");\n            return;\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols);\n        for (const neighbour of neighbours) {\n            if (!(neighbour in visited)) {\n                const altPath = totalCosts[neighbour] + getNodeWeight(gridState[neighbour]);\n\n                if (altPath < totalCosts[neighbour]) {\n                    totalCosts[neighbour] = altPath;\n                    prevNodes[neighbour] = minKey;\n                    minPQ[neighbour] = altPath;\n                }\n            }\n            else if (!(neighbour in minPQ)) {\n                minPQ[neighbour] = totalCosts[minKey] + getNodeWeight(gridState[neighbour]);\n            }\n        }\n    }\n};\n\nconst getNeighbourNodes = (node, rows, cols) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if (row - 1 >= 0) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if (row + 1 < rows) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if (col - 1 >= 0) {\n        res.push(`${row}:${col - 1}`)\n    }\n    if (col + 1 < cols) {\n        res.push(`${row}:${col + 1}`)\n    }\n\n    return res;\n};\n\nconst findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] == minPriority) {\n            return { key, minPriority };\n        }\n    }\n};"]},"metadata":{},"sourceType":"module"}