{"version":3,"sources":["utils/helper.js","algorithms/path_finding/dijkstras.js","algorithms/path_finding/dfs.js","algorithms/path_finding/bfs.js","algorithms/path_finding/aStar.js","algorithms/path_finding/bestFirst.js","algorithms/terrain/recursiveDivision.js","utils/constants.js","components/Node.js","components/Grid.js","components/Reset.js","components/Clear.js","components/Visualize.js","images/down_arrow.svg","images/weight.svg","images/weight_unfilled.svg","images/optimal.svg","images/optimal_unfilled.svg","components/CustomDropdown.js","components/ShowInfo.js","components/ChooseAlgorithm.js","components/GenerateTerrain.js","components/ChooseTerrain.js","components/ChooseObstacle.js","components/Header.js","images/close.svg","components/InfoBox.js","App.js","reportWebVitals.js","index.js"],"names":["getNeighbourNodes","node","rows","cols","gridState","row","parseInt","split","col","res","nodeTypeEnum","wall","push","createPath","startCord","targetCord","prevNodes","cord","path","findMinPriorityNode","minPQ","minPriority","Math","min","Object","values","key","isAlgoUnweighted","algo","unweightedPathAlgos","includes","sleep","ms","Promise","resolve","setTimeout","getRandomNum","num1","num2","max","floor","random","dijkstras","timeout","a","visited","totalCosts","x","y","Infinity","keys","length","minKey","nodeStateFunc","prevState","slice","neighbours","neighbour","currPath","nodeWeight","visiting","dfs","stack","currCord","none","pop","shift","unshift","unvisitedNeighbourFound","splice","bfs","queue","aStar","openSet","G","H","F","currNode","currGScore","h","currNodeCord","currRow","currCol","targetRow","targetCol","abs","bestFirst","console","log","recursiveDivision","setGridState","setWall","divide","startRow","endRow","startCol","endCol","orientation","width","height","sCol","sRow","skip","randRow","i","state","start","target","randCol","DIJKSTRAS","ASTAR","BFS","DFS","BEST_FIRST","algoFunctions","freeze","algoSleepTimes","allPathAlgos","optimalPathAlgos","RECURSIVE_DIVISION","terrainAlgos","terrainFunctions","pathfindingAlgoInfo","nodeColorClass","weighted100","weighted80","weighted60","weighted40","weighted20","nodeColors","obstacleTypes","obsEnum","Node","nodeId","size","draggingSelection","setDraggingSelection","setStartCord","setTargetCord","runningAlgo","selectedObstacle","startingState","useState","nodeState","setNodeState","useEffect","nodeColor","colorA","colorB","amount","match","map","c","rA","gA","bA","rB","gB","bB","round","toString","padStart","getNodeColor","nodeStyle","backgroundColor","border","cursor","style","className","remObstacle","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","Grid","React","memo","padding","nodeSize","nodes","gridDimensions","containerStyle","paddingLeft","paddingRight","Reset","clearObstacles","onClick","Clear","clearPath","Visualize","selectedAlgo","clearForReRun","setRunningAlgo","run","CustomDropdown","setSelection","items","disabled","dropDownWidth","isAlgoSelector","isObstacleSelector","dropDownOpen","setDropDownOpen","selectedVal","setSelectedVal","selectedId","setSelectedId","dropdownItems","id","src","weightUnfilled","title","alt","weight","optimal","optimalUnfilled","downArrow","display","ShowInfo","toggleInfoBox","ChooseAlgorithm","setSelectedAlgo","GenerateTerrain","selectedTerrainAlgo","resetGrid","ChooseTerrain","setSelectedTerrainAlgo","ChooseObstacle","setSelectedObstacle","weightedObsDisabled","obstacleName","Header","paddingBottom","InfoBox","infoBoxOpen","dragging","setDragging","boxCord","setBoxCord","disableDragging","e","left","top","onMouseMove","movementX","movementY","closeIcon","description","optimality","App","setInfoBoxOpen","setRows","setCols","setWeightedObsDisabled","initializeGrid","adjustedWinHeight","window","innerHeight","adjustedWinWidth","innerWidth","currRows","currCols","currState","gridMap","updateGrid","prev","algoName","unweightedAlgo","clearWeightedObstacles","newState","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ceb5fcdc.chunk.js","sourcesContent":["import { nodeTypeEnum, unweightedPathAlgos, optimalPathAlgos, nodeColors } from './constants.js'\n\nexport const getNodeColor = (nodeState) => {\n    if ((nodeState[0] === nodeTypeEnum.visited || nodeState[0] === nodeTypeEnum.visiting) && nodeState[1] > nodeTypeEnum.wall) {\n        let colorA = nodeColors[nodeState[0]];\n        const colorB = nodeColors[nodeState[1]];\n        let amount = 0.78;\n\n        if (nodeState[0] === nodeTypeEnum.visiting) {\n            colorA = nodeColors[nodeTypeEnum.visited];\n        }\n        // we need to mix colors\n        const [rA, gA, bA] = colorA.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const [rB, gB, bB] = colorB.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');\n        const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');\n        const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');\n        return '#' + r + g + b;\n    }\n\n    return nodeColors[nodeState[0]];\n};\n\nexport const getNeighbourNodes = (node, rows, cols, gridState) => {\n    const row = parseInt(node.split(':')[0]);\n    const col = parseInt(node.split(':')[1]);\n\n    let res = [];\n    if ((row - 1 >= 0) && (gridState[`${row - 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row - 1}:${col}`)\n    }\n    if ((col + 1 < cols) && (gridState[`${row}:${col + 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col + 1}`)\n    }\n    if ((row + 1) < rows && (gridState[`${row + 1}:${col}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row + 1}:${col}`)\n    }\n    if ((col - 1 >= 0) && (gridState[`${row}:${col - 1}`][0][0] !== nodeTypeEnum.wall)) {\n        res.push(`${row}:${col - 1}`)\n    }\n\n    return res;\n};\n\nexport const createPath = (startCord, targetCord, prevNodes) => {\n    let cord = targetCord;\n    let path = [];\n\n    while (true) {\n        cord = prevNodes[cord];\n\n        if (cord === startCord) {\n            break;\n        }\n\n        path.push(cord);\n    }\n\n    return path;\n};\n\nexport const findMinPriorityNode = (minPQ) => {\n    let minPriority = Math.min(...Object.values(minPQ));\n\n    for (const key in minPQ) {\n        if (minPQ[key] === minPriority) {\n            return key;\n        }\n    }\n};\n\nexport const isAlgoUnweighted = (algo) => {\n    return unweightedPathAlgos.includes(algo);\n};\n\nexport const isAlgoOptimal = (algo) => {\n    return optimalPathAlgos.includes(algo);\n};\n\nexport const sleep = (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n};\n\nexport const getRandomNum = (num1, num2) => {\n    if (num1 === num2) {\n        return num1;\n    }\n    const min = Math.min(num1, num2);\n    const max = Math.max(num1, num2);\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};","import { getNeighbourNodes, createPath, findMinPriorityNode, sleep } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dijkstras = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let totalCosts = {};\n    let prevNodes = {};\n    let minPQ = {};\n    let visited = {};\n\n    totalCosts[startCord] = 0;\n    minPQ[startCord] = 0;\n\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                totalCosts[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(minPQ).length > 0) {\n        const minKey = findMinPriorityNode(minPQ);\n        delete minPQ[minKey];\n        visited[minKey] = 1;\n\n        if (minKey !== startCord && minKey !== targetCord) {\n            const nodeStateFunc = gridState[minKey][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (minKey === targetCord) {\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(minKey, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currPath = totalCosts[minKey] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (neighbour in visited) {\n                continue;\n            }\n\n            if (((neighbour in minPQ) && currPath < totalCosts[neighbour]) || !(neighbour in minPQ)) {\n                totalCosts[neighbour] = currPath;\n                prevNodes[neighbour] = minKey;\n                minPQ[neighbour] = currPath;\n                if (neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};","import { getNeighbourNodes, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const dfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    const stack = [startCord];\n    const path = [];\n    const visited = { [startCord]: 1 };\n\n    while (stack.length > 0) {\n        const currCord = stack[0];\n        if (currCord !== targetCord && currCord !== startCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        if (currCord === targetCord) {\n            stack.pop();\n            stack.shift();\n            return stack;\n        }\n\n        if (currCord !== startCord) {\n            path.unshift(currCord);\n            visited[currCord] = 1;\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n        let unvisitedNeighbourFound = false;\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            stack.unshift(neighbour);\n            unvisitedNeighbourFound = true;\n            break;\n        }\n\n        if (!unvisitedNeighbourFound) {\n            stack.splice(0, 1);\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};","import { getNeighbourNodes, createPath, sleep } from '../../utils/helper.js'\nimport { nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bfs = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let queue = [startCord];\n    let visited = { [startCord]: 1 };\n    let prevNodes = {};\n\n    while (queue.length > 0) {\n        const currCord = queue.pop();\n        if (currCord !== startCord && currCord !== targetCord) {\n            const nodeStateFunc = gridState[currCord][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, nodeTypeEnum.none]));\n        }\n        const neighbours = getNeighbourNodes(currCord, rows, cols, gridState);\n\n        for (const neighbour of neighbours) {\n            if (neighbour in visited) {\n                continue;\n            }\n\n            prevNodes[neighbour] = currCord;\n            queue.unshift(neighbour);\n            visited[neighbour] = 1;\n\n            if (neighbour === targetCord) {\n                return createPath(startCord, targetCord, prevNodes);\n            }\n\n            const nodeStateFunc = gridState[neighbour][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visiting, nodeTypeEnum.none]));\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n","import { getNeighbourNodes, createPath, findMinPriorityNode, sleep } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const aStar = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let G = { [startCord]: 0 }; // G(n) => tell us the current shortest distance from start node to node n\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = G(n) + H(n)\n    let visited = {};\n    let prevNodes = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = G[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (currNode === targetCord) {\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            const currGScore = G[currNode] + nodeWeight[gridState[neighbour][0][0]];\n\n            if (currGScore < G[neighbour]) {\n                if (neighbour !== startCord && neighbour !== targetCord && !(neighbour in visited)) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n                visited[neighbour] = 1;\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                G[neighbour] = currGScore;\n                H[neighbour] = h(neighbour, targetCord);\n                F[neighbour] = G[neighbour] + H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst h = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};","import { getNeighbourNodes, createPath, findMinPriorityNode, sleep } from '../../utils/helper.js'\nimport { nodeWeight, nodeTypeEnum } from '../../utils/constants.js'\n\nexport const bestFirst = async (startCord, targetCord, gridState, rows, cols, timeout) => {\n    let openSet = { [startCord]: 0 };\n    let H = { [startCord]: 0 }; // H(n) => tells us the estimated distance from node n to target node\n    let F = { [startCord]: 0 }; // F(n) = H(n)\n    let prevNodes = {};\n    let visited = {};\n\n    // intialize all the scores to infinity for all node !== start node\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let cord = `${x}:${y}`\n\n            if (cord !== startCord) {\n                F[cord] = H[cord] = Infinity;\n            }\n        }\n    }\n\n    while (Object.keys(openSet).length > 0) {\n        const currNode = findMinPriorityNode(openSet);\n        delete openSet[currNode];\n\n        if (currNode !== startCord && currNode !== targetCord) {\n            const nodeStateFunc = gridState[currNode][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.visited, ...prevState.slice(1)]));\n        }\n        else if (currNode === targetCord) {\n            console.log(\"DONNEE\");\n            // we have reached target, return path\n            return createPath(startCord, targetCord, prevNodes);\n        }\n\n        const neighbours = getNeighbourNodes(currNode, rows, cols, gridState);\n        for (const neighbour of neighbours) {\n            if (!(neighbour in visited)) {\n                visited[neighbour] = 1;\n\n                if (neighbour !== startCord && neighbour !== targetCord) {\n                    const nodeStateFunc = gridState[neighbour][1];\n                    nodeStateFunc(prevState => ([nodeTypeEnum.visiting, ...prevState]));\n                }\n                // newly calculated G score of neighbour is lower than the one in the table\n                // update all the scores\n                H[neighbour] = h(neighbour, targetCord) + nodeWeight[gridState[neighbour][0][0]];\n                F[neighbour] = H[neighbour];\n                prevNodes[neighbour] = currNode;\n                openSet[neighbour] = F[neighbour];\n            }\n        }\n\n        await sleep(timeout);\n    }\n\n    return [];\n};\n\n// this implements our H score heuristic\n// current heuristic: take the absolute sum of the difference in node N's co-ordinates and target's co-ordinates. Hence, the greater the distance between N and target, the greater the H score for node N\nconst h = (currNodeCord, targetCord) => {\n    if (currNodeCord === targetCord) {\n        return 0;\n    }\n\n    const currRow = parseInt(currNodeCord.split(':')[0]);\n    const currCol = parseInt(currNodeCord.split(':')[1]);\n    const targetRow = parseInt(targetCord.split(':')[0]);\n    const targetCol = parseInt(targetCord.split(':')[1]);\n\n    return Math.abs(currRow - targetRow) + Math.abs(currCol - targetCol);\n};","import { nodeTypeEnum } from '../../utils/constants.js'\nimport { sleep, getRandomNum } from '../../utils/helper.js'\n\nconst HORIZONTAL = 0;\nconst VERTICAL = 1;\n\nexport const recursiveDivision = async (startCord, targetCord, gridState, setGridState, rows, cols, timeout) => {\n    // make border around the screen\n    for (let y = 0; y < cols; y++) {\n        const currCord = `${0}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = 1; y < rows; y++) {\n        const currCord = `${y}:${cols - 1}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = cols - 2; y >= 0; y--) {\n        const currCord = `${rows - 1}:${y}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    for (let y = rows - 2; y > 0; y--) {\n        const currCord = `${y}:${0}`;\n        setWall(currCord, startCord, targetCord, gridState, setGridState);\n        await sleep(timeout);\n    }\n\n    // await divide(1, 1, rows - 2, cols - 2, gridState, setGridState, timeout);\n    await divide(startCord, targetCord, gridState, setGridState, 1, rows - 2, 1, cols - 2, timeout, rows, cols);\n};\n\nconst divide = async (startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, endCol, timeout, rows, cols) => {\n    const width = endCol - startCol + 1;\n    const height = endRow - startRow + 1;\n\n    let orientation = HORIZONTAL;\n    if (width < height) {\n        orientation = HORIZONTAL;\n    }\n    else if (height < width) {\n        orientation = VERTICAL;\n    }\n    else {\n        orientation = getRandomNum(HORIZONTAL, VERTICAL);\n    }\n\n    if (orientation === HORIZONTAL) {\n        // cutting horizontally\n        if (height < 3 || (startRow % 2 === 1 && height === 3)) {\n            return;\n        }\n        let sCol = startCol;\n        if (startCol % 2 === 1) {\n            sCol += 1;\n        }\n\n        let sRow = startRow + 2;\n        if (startRow % 2 === 0) {\n            sRow = startRow + 1;\n        }\n\n        const skip = Math.floor(getRandomNum(sCol, endCol) / 2) * 2;\n        let randRow = getRandomNum(sRow, endRow - 2);\n        randRow = (Math.floor(randRow / 2) * 2) + 1;\n\n        for (let i = startCol; i <= endCol; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${randRow}:${i}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, randRow - 1, startCol, endCol, timeout, rows, cols);\n        await divide(startCord, targetCord, gridState, setGridState, randRow + 1, endRow, startCol, endCol, timeout, rows, cols);\n    }\n    else if (orientation === VERTICAL) {\n        // divide vertically \n        if (width < 3 || (startCol % 2 === 1 && width === 3)) {\n            return;\n        }\n        let sRow = startRow;\n        if (startRow % 2 === 1) {\n            sRow += 1;\n        }\n\n        let sCol = startCol + 2;\n        if (startCol % 2 === 0) {\n            sCol = startCol + 1;\n        }\n        const skip = Math.floor(getRandomNum(sRow, endRow) / 2) * 2;\n        let randCol = getRandomNum(sCol, endCol - 2);\n        randCol = (Math.floor(randCol / 2) * 2) + 1;\n\n        for (let i = startRow; i <= endRow; i++) {\n            if (i === skip) {\n                continue;\n            }\n            const currCord = `${i}:${randCol}`;\n            const nodeStateFunc = gridState[currCord][1];\n            let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n            if (currCord === startCord) {\n                state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            else if (currCord === targetCord) {\n                state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n            }\n            nodeStateFunc(prevState => state);\n            setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n            await sleep(timeout);\n        }\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, startCol, randCol - 1, timeout, rows, cols);\n\n        await divide(startCord, targetCord, gridState, setGridState, startRow, endRow, randCol + 1, endCol, timeout, rows, cols);\n    }\n};\n\nconst setWall = (currCord, startCord, targetCord, gridState, setGridState) => {\n    const nodeStateFunc = gridState[currCord][1];\n\n    let state = [nodeTypeEnum.wall, nodeTypeEnum.none];\n    if (currCord === startCord) {\n        state = [nodeTypeEnum.start, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n    else if (currCord === targetCord) {\n        state = [nodeTypeEnum.target, nodeTypeEnum.wall, nodeTypeEnum.none];\n    }\n\n    nodeStateFunc(prevState => state);\n    setGridState(prevState => ({ ...prevState, [currCord]: [state, prevState[currCord][1]] }));\n};","import { dijkstras } from '../algorithms/path_finding/dijkstras.js'\nimport { dfs } from '../algorithms/path_finding/dfs.js'\nimport { bfs } from '../algorithms/path_finding/bfs.js'\nimport { aStar } from '../algorithms/path_finding/aStar.js'\nimport { bestFirst } from '../algorithms/path_finding/bestFirst.js';\nimport { recursiveDivision } from '../algorithms/terrain/recursiveDivision.js'\n\n// PATHFINDING ALGORITHM CONSTANTS -------------------------------------------\nconst DIJKSTRAS = \"Dijkstra's\";\nconst ASTAR = 'A* (A-Star)';\nconst BFS = 'Breadth-first Search';\nconst DFS = 'Depth-first Search';\nconst BEST_FIRST = 'Best-first Search';\n\nconst algoFunctions = {\n    [DIJKSTRAS]: dijkstras,\n    [ASTAR]: aStar,\n    [BFS]: bfs,\n    [DFS]: dfs,\n    [BEST_FIRST]: bestFirst\n};\nObject.freeze(algoFunctions);\n\nconst PATH_CREATION_SLEEP = 7;\nconst algoSleepTimes = {\n    [DIJKSTRAS]: 1,\n    [ASTAR]: 4,\n    [BFS]: 5,\n    [DFS]: 10,\n    [BEST_FIRST]: 11\n};\nObject.freeze(algoSleepTimes);\n\nexport { DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST, algoFunctions, PATH_CREATION_SLEEP, algoSleepTimes };\n\nconst allPathAlgos = [DIJKSTRAS, ASTAR, BFS, DFS, BEST_FIRST];\nObject.freeze(allPathAlgos);\nconst unweightedPathAlgos = [DFS, BFS];\nObject.freeze(unweightedPathAlgos);\nconst optimalPathAlgos = [DIJKSTRAS, ASTAR, BFS];\nObject.freeze(optimalPathAlgos);\n\nexport { allPathAlgos, unweightedPathAlgos, optimalPathAlgos };\n\n// TERRAIN ALGORTHIM CONSTANTS -------------------------------------------\nconst MAZE_GENERATION_SLEEP = 5;\nconst RECURSIVE_DIVISION = \"Recursive Division\";\nconst ALGO2 = \"ALGO 2\";\nconst terrainAlgos = [RECURSIVE_DIVISION, ALGO2];\nObject.freeze(terrainAlgos);\n\nconst terrainFunctions = {\n    [RECURSIVE_DIVISION]: recursiveDivision\n};\nObject.freeze(terrainFunctions);\n\nexport { MAZE_GENERATION_SLEEP, RECURSIVE_DIVISION, ALGO2, terrainAlgos, terrainFunctions };\n\nconst pathfindingAlgoInfo = {\n    [DIJKSTRAS]: {\n        'description': <p>Dijkstra's algorithm to find the shortest path between a and b. It picks the unvisited vertex with the <strong>lowest distance</strong>, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors.</p>,\n        'optimality': <p>Dijkstra's is guranteed to find the shortest path.</p>\n    }\n};\nObject.freeze(pathfindingAlgoInfo);\nexport { pathfindingAlgoInfo };\n\n// NODE CONSTANTS ------------------------------------------------------------\nconst nodeTypeEnum = {\n    'path': 0,\n    'visited': 1,\n    'visiting': 2,\n    'none': 3,\n    'target': 4,\n    'start': 5,\n    'remObstacle': 6,\n    'wall': 7,\n    'weighted100': 8,\n    'weighted80': 9,\n    'weighted60': 10,\n    'weighted40': 11,\n    'weighted20': 12\n};\nObject.freeze(nodeTypeEnum);\n\nexport { nodeTypeEnum };\n\nconst nodeColorClass = {\n    [nodeTypeEnum.none]: 'none',\n    [nodeTypeEnum.target]: 'target',\n    [nodeTypeEnum.wall]: 'wall',\n    [nodeTypeEnum.visiting]: 'visiting',\n    [nodeTypeEnum.start]: 'start',\n    [nodeTypeEnum.visited]: 'visited',\n    [nodeTypeEnum.path]: 'path',\n    [nodeTypeEnum.weighted100]: 'weighted100',\n    [nodeTypeEnum.weighted80]: 'weighted80',\n    [nodeTypeEnum.weighted60]: 'weighted60',\n    [nodeTypeEnum.weighted40]: 'weighted40',\n    [nodeTypeEnum.weighted20]: 'weighted20'\n};\nObject.freeze(nodeColorClass);\n\nexport { nodeColorClass };\n\nconst EMPTY_NODE_BORDER_COLOR = '#3C4046';\nconst nodeColors = {\n    [nodeTypeEnum.none]: 'transparent',\n    [nodeTypeEnum.target]: '#f14846',\n    [nodeTypeEnum.wall]: '#18191c',\n    [nodeTypeEnum.visiting]: '#4988dc',\n    [nodeTypeEnum.start]: '#43b581',\n    [nodeTypeEnum.visited]: '#3f70dd',\n    [nodeTypeEnum.path]: '#f9a719',\n    [nodeTypeEnum.weighted100]: '#1b1c1e',\n    [nodeTypeEnum.weighted80]: '#1c1e21',\n    [nodeTypeEnum.weighted60]: '#222327',\n    [nodeTypeEnum.weighted40]: '#26272b',\n    [nodeTypeEnum.weighted20]: '#2b2c31'\n};\nObject.freeze(nodeColors);\n\nexport { EMPTY_NODE_BORDER_COLOR, nodeColors };\n\nconst nodeWeight = {\n    [nodeTypeEnum.none]: 1,\n    [nodeTypeEnum.target]: 1,\n    [nodeTypeEnum.wall]: Infinity,\n    [nodeTypeEnum.start]: 1,\n    [nodeTypeEnum.weighted100]: 100,\n    [nodeTypeEnum.weighted80]: 80,\n    [nodeTypeEnum.weighted60]: 60,\n    [nodeTypeEnum.weighted40]: 40,\n    [nodeTypeEnum.weighted20]: 20\n};\nObject.freeze(nodeWeight);\nexport { nodeWeight };\n\n// OBSTACLE TYPES --------------------------------------------------------\nconst obstacleTypes = ['Wall (∞)', 'Weighted (100)', 'Weighted (80)', 'Weighted (60)', 'Weighted (40)', 'Weighted (20)'];\nconst obsEnum = {\n    [obstacleTypes[0]]: nodeColorClass[nodeTypeEnum.wall],\n    [obstacleTypes[1]]: nodeColorClass[nodeTypeEnum.weighted100],\n    [obstacleTypes[2]]: nodeColorClass[nodeTypeEnum.weighted80],\n    [obstacleTypes[3]]: nodeColorClass[nodeTypeEnum.weighted60],\n    [obstacleTypes[4]]: nodeColorClass[nodeTypeEnum.weighted40],\n    [obstacleTypes[5]]: nodeColorClass[nodeTypeEnum.weighted20]\n};\nObject.freeze(obsEnum);\n\nexport { obstacleTypes, obsEnum };","import React from 'react'\nimport { useEffect, useState } from 'react'\nimport { EMPTY_NODE_BORDER_COLOR, nodeTypeEnum } from '../utils/constants.js'\nimport { getNodeColor } from '../utils/helper.js'\n\nconst Node = ({ nodeId, size, setGridState, draggingSelection, setDraggingSelection, setStartCord, setTargetCord, runningAlgo, selectedObstacle, startingState }) => {\n    const [nodeState, setNodeState] = useState(startingState);\n\n    useEffect(() => {\n        setGridState(prevState => ({ ...prevState, [nodeId]: [startingState, setNodeState] }));\n    }, []);\n\n    const nodeColor = getNodeColor(nodeState);\n    let nodeStyle = {\n        width: size,\n        height: size,\n        backgroundColor: nodeColor,\n        border: `1px solid ${nodeState[0] === nodeTypeEnum.none ? EMPTY_NODE_BORDER_COLOR : nodeColor}`\n    };\n\n    if (!runningAlgo) {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            nodeStyle.cursor = 'grabbing';\n        }\n        else if (draggingSelection === nodeTypeEnum.none && (nodeState[0] === nodeTypeEnum.start || nodeState[0] === nodeTypeEnum.target)) {\n            nodeStyle.cursor = 'grab';\n        }\n    }\n\n    const mouseDowned = () => {\n        if (nodeState[0] <= nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum[selectedObstacle]);\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n            return;\n        }\n        else if (nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n            setDraggingSelection(nodeTypeEnum.remObstacle);\n            return;\n        }\n        else if (nodeState[0] === nodeTypeEnum.start || nodeState[0] === nodeTypeEnum.target) {\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n\n        setDraggingSelection(nodeState[0]);\n    };\n\n    const mouseEntered = () => {\n        if (draggingSelection === nodeTypeEnum.remObstacle && nodeState[0] >= nodeTypeEnum.wall) {\n            setNodeState(prevState => prevState.slice(1));\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState.slice(1), setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum[selectedObstacle] && nodeState[0] <= nodeTypeEnum.none) {\n            setNodeState(prevState => [nodeTypeEnum[selectedObstacle], nodeTypeEnum.none]);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [[nodeTypeEnum[selectedObstacle], nodeTypeEnum.none], setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.start) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => [draggingSelection, ...prevState]);\n        }\n    };\n\n    const mouseLeft = () => {\n        if (draggingSelection === nodeTypeEnum.start || draggingSelection === nodeTypeEnum.target) {\n            setNodeState(prevState => prevState.slice(1));\n            return;\n        }\n    };\n\n    const mouseUped = () => {\n        if (draggingSelection === nodeTypeEnum.start) {\n            setStartCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        else if (draggingSelection === nodeTypeEnum.target) {\n            setTargetCord(nodeId);\n            setGridState(prevState => ({ ...prevState, [nodeId]: [nodeState, setNodeState] }));\n        }\n        if (draggingSelection !== nodeTypeEnum.none) {\n            setDraggingSelection(nodeTypeEnum.none);\n        }\n    };\n\n    return (\n        <div style={nodeStyle} className={`node ${draggingSelection === nodeTypeEnum.remObstacle && 'erasing'}`} onMouseDown={runningAlgo ? null : mouseDowned} onMouseUp={runningAlgo ? null : mouseUped} onMouseEnter={runningAlgo ? null : mouseEntered} onMouseLeave={runningAlgo ? null : mouseLeft} >\n        </div>\n    );\n};\n\nexport default Node\n","import Node from './Node.js'\nimport React from 'react'\nimport { useState } from 'react'\nimport { nodeTypeEnum } from '../utils/constants.js'\n\nconst Grid = React.memo(({ rows, cols, padding, nodeSize, setGridState, selectedObstacle, setStartCord, setTargetCord, runningAlgo }) => {\n    const [draggingSelection, setDraggingSelection] = useState(nodeTypeEnum.none);\n\n    // fill nodes in the grid\n    console.log(\"RERENDERING GRID\");\n    const nodes = [];\n    for (let x = 0; x < rows; x++) {\n        for (let y = 0; y < cols; y++) {\n            let nodeId = `${x}:${y}`\n\n            let startingState = [nodeTypeEnum.none];\n            if (x === 1 && y === 1) {\n                startingState.unshift(nodeTypeEnum.start);\n            }\n            else if (x === (rows - 2) && y === (cols - 2)) {\n                startingState.unshift(nodeTypeEnum.target);\n            }\n\n            nodes.push(<Node nodeId={nodeId}\n                size={nodeSize} setGridState={setGridState}\n                draggingSelection={draggingSelection}\n                setDraggingSelection={setDraggingSelection}\n                setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} selectedObstacle={selectedObstacle} startingState={startingState} key={nodeId} />);\n        }\n    }\n\n    const gridDimensions = {\n        width: (cols * nodeSize) + cols,\n        height: (rows * nodeSize) + rows\n    };\n\n    const containerStyle = {\n        paddingLeft: padding,\n        paddingRight: padding\n    }\n\n    return (\n        <div style={containerStyle}>\n            <div className='grid' style={gridDimensions}>\n                {nodes}\n            </div >\n        </div>\n    )\n});\n\nexport default Grid\n","const Reset = ({ clearObstacles, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'red'}`} onClick={runningAlgo ? null : clearObstacles}>\n            Clear Obstacles\n        </div >\n    )\n}\n\nexport default Reset\n","import React from 'react'\n\nconst Clear = ({ clearPath, runningAlgo }) => {\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'orange'}`} onClick={runningAlgo ? null : clearPath}>\n            Clear Path\n        </div >\n    )\n}\n\nexport default Clear\n","import { algoFunctions, nodeTypeEnum, PATH_CREATION_SLEEP, algoSleepTimes } from '../utils/constants.js'\nimport { sleep } from '../utils/helper.js'\n\nconst Visualize = ({ rows, cols, selectedAlgo, gridState, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo }) => {\n    const run = async () => {\n        if (startCord === targetCord) {\n            return;\n        }\n\n        clearForReRun();\n        setRunningAlgo(true);\n        console.log(\"STARTING: \", selectedAlgo);\n\n        let path = [];\n        path = await algoFunctions[selectedAlgo](startCord, targetCord, gridState, rows, cols, algoSleepTimes[selectedAlgo]);\n\n        console.log(\"ENDED: \", selectedAlgo);\n\n        for (let i = path.length - 1; i >= 0; i--) {\n            await sleep(PATH_CREATION_SLEEP);\n            const nodeStateFunc = gridState[path[i]][1];\n            nodeStateFunc(prevState => ([nodeTypeEnum.path, ...gridState[path[i]][0]]));\n        }\n\n        setRunningAlgo(false);\n    };\n\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'green'}`} onClick={runningAlgo ? null : run} >\n            Run\n        </div >\n    )\n}\n\nexport default Visualize\n","export default __webpack_public_path__ + \"static/media/down_arrow.8fed4a28.svg\";","export default __webpack_public_path__ + \"static/media/weight.e51e9729.svg\";","export default __webpack_public_path__ + \"static/media/weight_unfilled.cc3c5f2f.svg\";","export default __webpack_public_path__ + \"static/media/optimal.5649a19a.svg\";","export default __webpack_public_path__ + \"static/media/optimal_unfilled.e461ee2c.svg\";","import { useState, useEffect } from 'react'\nimport { isAlgoUnweighted, isAlgoOptimal } from '../utils/helper.js'\nimport { nodeColors, nodeTypeEnum, obsEnum } from '../utils/constants.js'\nimport downArrow from '../images/down_arrow.svg';\nimport weight from '../images/weight.svg'\nimport weightUnfilled from '../images/weight_unfilled.svg'\nimport optimal from '../images/optimal.svg'\nimport optimalUnfilled from '../images/optimal_unfilled.svg'\n\nconst CustomDropdown = ({ setSelection, items, disabled, dropDownWidth, isAlgoSelector, isObstacleSelector }) => {\n    const [dropDownOpen, setDropDownOpen] = useState(false);\n    const [selectedVal, setSelectedVal] = useState(items[0]);\n    const [selectedId, setSelectedId] = useState(0);\n\n    useEffect(() => {\n        if (disabled) {\n            setSelectedVal(items[0]);\n            setSelectedId(0);\n            setDropDownOpen(false);\n            setSelection(items[0]);\n        }\n    }, [disabled])\n\n    const toggle = () => {\n        setDropDownOpen(prevState => !prevState);\n    }\n\n    const madeSelection = (id) => {\n        setDropDownOpen(prevState => !prevState);\n        setSelectedVal(items[id]);\n        setSelectedId(id);\n        setSelection(items[id]);\n    };\n\n    const style = {\n        width: dropDownWidth\n    }\n\n    const dropdownItems = [];\n    for (let i = 0; i < items.length; i++) {\n        dropdownItems.push(<div style={style} className={`dropdown-list-item ${i === selectedId && 'selected'} ${i === items.length - 1 && 'last'}`} onClick={() => { madeSelection(i) }} key={i}>\n            {items[i]}\n            {isAlgoSelector && (!isAlgoUnweighted(items[i]) ? <img className=\"algo-property-badge\" src={weight} title={`${items[i]} is a weighted path-finding algorithm.`} alt={`${items[i]} is a weighted path-finding algorithm.`}></img> : <img className=\"algo-property-badge\" src={weightUnfilled} title={`${items[i]} is not a weighted path-finding algorithm.`} alt={`${items[i]} is not a weighted path-finding algorithm.`}></img>)}\n            {isAlgoSelector && (isAlgoOptimal(items[i]) ? <img className=\"algo-property-badge\" src={optimal} title={`${items[i]} guarantees shortest path.`} alt={`${items[i]} guarantees shortest path.`}></img> : <img className=\"algo-property-badge\" src={optimalUnfilled} title={`${items[i]} does not guarantee shortest path.`} alt={`${items[i]} does not guarantee shortest path.`}></img>)}\n            {isObstacleSelector && <div style={{ backgroundColor: nodeColors[nodeTypeEnum[obsEnum[items[i]]]] }} className=\"obstacle-preview\"> </div>}\n        </div >)\n    }\n\n    return (\n        <div className='dropdown'>\n            <div style={style} className={`dropdown-header ${dropDownOpen && 'open'} ${disabled && 'disabled'}`} onClick={disabled ? null : toggle}>\n                {selectedVal}\n                {!disabled && <img className=\"down-arrow\" src={downArrow} alt=\"\"></img>}\n            </div>\n            <div style={{ display: (dropDownOpen ? 'flex' : 'none') }} className='dropdown-list'>\n                {dropdownItems}\n            </div>\n        </div >\n    )\n}\n\nexport default CustomDropdown\n","const ShowInfo = ({ toggleInfoBox }) => {\n    return (\n        <div className={`button blue`} onClick={toggleInfoBox} >\n            Info\n        </div >\n    )\n}\n\nexport default ShowInfo\n","import Visualize from './Visualize.js'\nimport CustomDropdown from './CustomDropdown.js'\nimport ShowInfo from './ShowInfo.js'\n\nimport { allPathAlgos } from '../utils/constants.js'\n\nconst ChooseAlgorithm = ({ rows, cols, gridState, setGridState, startCord, targetCord, clearForReRun, runningAlgo, setRunningAlgo, dropDownWidth, toggleInfoBox, selectedAlgo, setSelectedAlgo }) => {\n\n    return (\n        <div className={`choose-algo`}>\n            <CustomDropdown setSelection={setSelectedAlgo} items={allPathAlgos} disabled={false} dropDownWidth={dropDownWidth} isAlgoSelector={true} isObstacleSelector={false} />\n            <ShowInfo toggleInfoBox={toggleInfoBox} />\n            <Visualize rows={rows} cols={cols} selectedAlgo={selectedAlgo} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearForReRun} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} />\n        </div >\n    )\n}\n\nexport default ChooseAlgorithm\n","import { terrainFunctions, MAZE_GENERATION_SLEEP } from '../utils/constants.js'\n\nconst GenerateTerrain = ({ rows, cols, selectedTerrainAlgo, gridState, setGridState, startCord, targetCord, runningAlgo, setRunningAlgo, resetGrid }) => {\n    const run = async () => {\n        resetGrid();\n\n        setRunningAlgo(true);\n        console.log(\"STARTING: \", selectedTerrainAlgo);\n\n        await terrainFunctions[selectedTerrainAlgo](startCord, targetCord, gridState, setGridState, rows, cols, MAZE_GENERATION_SLEEP);\n\n        console.log(\"ENDED: \", selectedTerrainAlgo);\n        setRunningAlgo(false);\n    };\n\n    return (\n        <div className={`button ${runningAlgo ? 'disabled' : 'green'}`} onClick={runningAlgo ? null : run} >\n            Run\n        </div >\n    )\n}\n\nexport default GenerateTerrain\n","import CustomDropdown from './CustomDropdown.js'\nimport { useState } from 'react'\nimport { terrainAlgos } from '../utils/constants.js'\nimport GenerateTerrain from './GenerateTerrain.js'\n\nconst ChooseTerrain = ({ rows, cols, gridState, setGridState, startCord, targetCord, runningAlgo, setRunningAlgo, dropDownWidth, resetGrid }) => {\n    const [selectedTerrainAlgo, setSelectedTerrainAlgo] = useState(terrainAlgos[0]);\n\n    return (\n        <div className={`choose-terrain`}>\n            <CustomDropdown setSelection={setSelectedTerrainAlgo} items={terrainAlgos} disabled={false} dropDownWidth={dropDownWidth} isAlgoSelector={false} isObstacleSelector={false} />\n            <GenerateTerrain rows={rows} cols={cols} selectedTerrainAlgo={selectedTerrainAlgo} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} resetGrid={resetGrid} />\n        </div >\n    )\n}\n\nexport default ChooseTerrain\n","import CustomDropdown from './CustomDropdown.js'\nimport { obstacleTypes, obsEnum } from '../utils/constants.js'\n\nconst ChooseObstacle = ({ setSelectedObstacle, weightedObsDisabled, dropDownWidth }) => {\n    const setObstacle = (obstacleName) => {\n        console.log(\"selected obs: \", obsEnum[obstacleName]);\n        setSelectedObstacle(obsEnum[obstacleName]);\n    };\n\n    return (\n        <div className={`choose-obstacle`}>\n            <CustomDropdown setSelection={setObstacle} items={obstacleTypes} disabled={weightedObsDisabled} dropDownWidth={dropDownWidth} isAlgoSelector={false} isObstacleSelector={true} />\n        </div >\n    )\n}\n\nexport default ChooseObstacle\n","import Reset from './Reset.js'\nimport Clear from './Clear.js'\nimport ChooseAlgorithm from './ChooseAlgorithm.js'\nimport ChooseTerrain from './ChooseTerrain.js'\nimport ChooseObstacle from './ChooseObstacle.js'\n\nconst Header = ({ rows, cols, runningAlgo, setRunningAlgo, padding, height, gridState, setGridState, startCord, targetCord, clearObstacles, clearPath, setSelectedObstacle, weightedObsDisabled, toggleInfoBox, selectedAlgo, setSelectedAlgo, resetGrid }) => {\n    const style = {\n        padding: padding,\n        paddingBottom: padding / 2,\n        height: height\n    };\n\n    return (\n        <div style={style} className='header'>\n            <Reset clearObstacles={clearObstacles} runningAlgo={runningAlgo} />\n            <Clear clearPath={clearPath} runningAlgo={runningAlgo} />\n            <ChooseAlgorithm rows={rows} cols={cols} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearForReRun={clearPath} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} dropDownWidth={220} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} setSelectedAlgo={setSelectedAlgo} />\n            <ChooseObstacle setSelectedObstacle={setSelectedObstacle} weightedObsDisabled={weightedObsDisabled} dropDownWidth={190} />\n            <ChooseTerrain rows={rows} cols={cols} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} resetGrid={resetGrid} dropDownWidth={200} />\n        </div>\n    )\n}\n\nexport default Header\n","export default __webpack_public_path__ + \"static/media/close.494fd48f.svg\";","import { useState } from 'react'\nimport closeIcon from '../images/close.svg'\nimport { pathfindingAlgoInfo } from '../utils/constants.js'\n\nconst InfoBox = ({ infoBoxOpen, toggleInfoBox, selectedAlgo }) => {\n    const [dragging, setDragging] = useState(false);\n    const [boxCord, setBoxCord] = useState([300, 0]);\n\n    const enableDragging = (e) => {\n        setDragging(true);\n    };\n\n    const beingDragged = (e) => {\n        if (dragging) {\n            setBoxCord(prevState => [prevState[0] + e.movementX, prevState[1] + e.movementY]);\n        }\n    };\n\n    const disableDragging = (e) => {\n        setDragging(false);\n    };\n\n    return (\n        <div style={{ left: `${boxCord[0]}px`, top: `${boxCord[1]}px` }} className={`info-box ${infoBoxOpen ? 'visible' : 'hidden'}`} onMouseMove={beingDragged} onMouseUp={disableDragging} onMouseLeave={disableDragging}>\n            <img className='close-info-icon' src={closeIcon} onClick={toggleInfoBox} alt='Close info box' />\n            <h1 onMouseDown={enableDragging} >{selectedAlgo}</h1>\n            {(pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].description) || <p>No information.</p>}\n            {(pathfindingAlgoInfo[selectedAlgo] && pathfindingAlgoInfo[selectedAlgo].optimality)}\n        </div >\n    )\n}\n\nexport default InfoBox\n","import Grid from './components/Grid.js'\nimport Header from './components/Header.js'\nimport InfoBox from './components/InfoBox.js'\n\nimport { allPathAlgos, nodeTypeEnum } from './utils/constants.js'\nimport { useState, useEffect } from 'react'\nimport { isAlgoUnweighted } from './utils/helper.js'\n\nfunction App() {\n  const [gridState, setGridState] = useState({});\n  const [selectedObstacle, setSelectedObstacle] = useState('wall');\n  const [infoBoxOpen, setInfoBoxOpen] = useState(false);\n  const [selectedAlgo, setSelectedAlgo] = useState(allPathAlgos[0]);\n  const [rows, setRows] = useState(0);\n  const [cols, setCols] = useState(0);\n  const [startCord, setStartCord] = useState('0:0');\n  const [targetCord, setTargetCord] = useState('0:0');\n  const [runningAlgo, setRunningAlgo] = useState(false);\n  const [weightedObsDisabled, setWeightedObsDisabled] = useState(false);\n  const margin = 30;\n  const nodeSize = 28;\n  const navBarHeight = 90;\n\n  useEffect(() => {\n    console.log(\"RESETTING BOARD\");\n    initializeGrid();\n  }, []);\n\n  // useEffect(() => {\n  //   window.addEventListener(\"resize\", resetBoard);\n  //   return () => window.removeEventListener(\"resize\", resetBoard)\n  // }, []);\n\n  const initializeGrid = () => {\n    const adjustedWinHeight = window.innerHeight - (navBarHeight + (margin * 3));\n    const adjustedWinWidth = window.innerWidth - (2 * margin);\n\n    const currRows = parseInt(adjustedWinHeight / (nodeSize + 1));\n    const currCols = parseInt(adjustedWinWidth / (nodeSize + 1));\n\n    setRunningAlgo(false);\n    setRows(currRows);\n    setCols(currCols);\n    setStartCord('1:1');\n    setTargetCord(`${currRows - 2}:${currCols - 2}`);\n  };\n\n  const clearPath = () => {\n    console.log(\"CLEARING PATH\");\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] <= nodeTypeEnum.visiting)) {\n          nodeState.splice(1, 1);\n        }\n        else if (currState <= nodeTypeEnum.visiting) {\n          nodeState.splice(0, 1);\n        }\n\n        nodeStateFunc(prevState => nodeState);\n      }\n    }\n  };\n\n  const clearObstacles = () => {\n    let gridMap = {};\n    let updateGrid = false;\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        gridMap[id] = [nodeState, nodeStateFunc];\n\n        // check under start and target node for obstacle\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] >= nodeTypeEnum.wall)) {\n          updateGrid = true;\n          nodeState.splice(1, 1);\n          nodeStateFunc(prev => nodeState);\n          gridMap[id] = [nodeState, nodeStateFunc];\n          continue;\n        }\n\n        if (currState <= nodeTypeEnum.visiting) {\n          currState = nodeState[1];\n        }\n\n        if (currState >= nodeTypeEnum.wall) {\n          updateGrid = true;\n          nodeStateFunc(prev => [nodeTypeEnum.none]);\n          gridMap[id] = [[nodeTypeEnum.none], nodeStateFunc];\n        }\n      }\n    }\n\n    if (updateGrid) {\n      setGridState(prevState => gridMap);\n    }\n  };\n\n  const clearWeightedObstacles = () => {\n    let gridMap = {};\n    let updateGrid = false;\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n\n        gridMap[id] = [nodeState, nodeStateFunc];\n\n        // check under start and target node for weighted obstacle\n        if ((currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) && (nodeState[1] > nodeTypeEnum.wall)) {\n          updateGrid = true;\n          nodeState.splice(1, 1);\n          nodeStateFunc(prev => nodeState);\n          gridMap[id] = [nodeState, nodeStateFunc];\n          continue;\n        }\n\n        if (currState <= nodeTypeEnum.visiting) {\n          currState = nodeState[1];\n        }\n\n        if (currState > nodeTypeEnum.wall) {\n          updateGrid = true;\n          nodeStateFunc(prev => [nodeTypeEnum.none]);\n          gridMap[id] = [[nodeTypeEnum.none], nodeStateFunc];\n        }\n      }\n    }\n\n    if (updateGrid) {\n      setGridState(prevState => gridMap);\n    }\n  };\n\n  const resetGrid = () => {\n    let gridMap = {};\n    for (let x = 0; x < rows; x++) {\n      for (let y = 0; y < cols; y++) {\n        let id = `${x}:${y}`;\n        let nodeState = gridState[id][0];\n        let nodeStateFunc = gridState[id][1];\n        let currState = nodeState[0];\n        let newState = [nodeTypeEnum.none];\n\n        if (currState === nodeTypeEnum.start || currState === nodeTypeEnum.target) {\n          newState.unshift(currState);\n        }\n\n        nodeStateFunc(prev => newState);\n        gridMap[id] = [newState, nodeStateFunc];\n      }\n    }\n\n    setGridState(prevState => gridMap);\n  };\n\n  const toggleInfoBox = () => {\n    setInfoBoxOpen(prevState => !prevState);\n  };\n\n  const alteredSetSelectedAlgo = (algoName) => {\n    const unweightedAlgo = isAlgoUnweighted(algoName);\n    setWeightedObsDisabled(unweightedAlgo);\n    setSelectedAlgo(algoName);\n    if (unweightedAlgo) {\n      clearPath();\n      clearWeightedObstacles();\n    }\n  };\n\n  return (\n    <>\n      <Header rows={rows} cols={cols} runningAlgo={runningAlgo} setRunningAlgo={setRunningAlgo} padding={margin} height={navBarHeight} gridState={gridState} setGridState={setGridState} startCord={startCord} targetCord={targetCord} clearObstacles={clearObstacles} clearPath={clearPath} setSelectedObstacle={setSelectedObstacle} weightedObsDisabled={weightedObsDisabled} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} setSelectedAlgo={alteredSetSelectedAlgo} resetGrid={resetGrid} />\n      <Grid rows={rows} cols={cols} padding={margin} nodeSize={nodeSize} setGridState={setGridState} selectedObstacle={selectedObstacle} setStartCord={setStartCord} setTargetCord={setTargetCord} runningAlgo={runningAlgo} />\n      <InfoBox infoBoxOpen={infoBoxOpen} toggleInfoBox={toggleInfoBox} selectedAlgo={selectedAlgo} />\n    </>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}